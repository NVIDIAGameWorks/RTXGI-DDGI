diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin b/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin
new file mode 100644
index 00000000000..df851f14812
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin
@@ -0,0 +1,29 @@
+{
+	"FileVersion" : 3,
+	"Version" : 0,
+	"VersionName" : "0.0",
+	"FriendlyName" : "NVIDIA RTXGI Plugin",
+	"Description" : "Plugin to support dynamic Global Illumination",
+	"Category" : "Lighting",
+	"CreatedBy" : "Epic Games, Inc.",
+	"CreatedByURL" : "http://epicgames.com",
+	"DocsURL" : "",
+	"MarketplaceURL" : "",
+	"SupportURL" : "",
+	"EnabledByDefault" : false,
+	"CanContainContent" : true,
+	"IsBetaVersion" : true,
+	"Installed" : false,
+	"Modules" :
+	[
+		{
+			"Name" : "RTXGI",
+			"Type" : "Runtime",
+			"LoadingPhase" : "PostConfigInit",
+			"WhitelistPlatforms" :
+			[
+				"Win64",				
+			]
+		}
+	]
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf
new file mode 100644
index 00000000000..3d594e7bc08
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf
@@ -0,0 +1,217 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Public/Platform.ush"
+#include "/Engine/Private/GammaCorrectionCommon.ush"
+
+struct DDGIVolumeDescGPU
+{
+	// need to set
+	float3      origin;
+	float       probeIrradianceEncodingGamma;
+	float3      probeGridSpacing;
+	float       normalBias;
+	int3        probeGridCounts;
+	int         probeNumIrradianceTexels;
+	int         probeNumDistanceTexels;
+	float       viewBias;
+	int3        probeScrollOffsets;
+};
+
+#include "/Plugin/RTXGI/Private/SDK/ddgi/Irradiance.ush"
+
+// VOLUME_LIST is defined by DDGIVolumeComponent.cpp and is a macro list like: VOLUME_ENTRY(0), VOLUME_ENTRY(1), etc
+
+Texture2D<float4>		Normals;
+Texture2D<float>		Depth;
+Texture2D<float4>		BaseColor;
+Texture2D<float4>		Metallic;
+
+SamplerState LinearClampSampler;
+
+#if USE_LIGHTING_CHANNELS
+Texture2D<uint>			LightingChannelsTexture;
+#endif
+
+float4x4 ScreenToTranslatedWorld;
+float3 WorldCameraOrigin;
+float PreExposure;
+float4 InvDeviceZToWorldZTransform;
+uint ShouldUsePreExposure;
+uint NumVolumes;
+
+// generate an array of structures for each probe volume
+#define VOLUME_ENTRY(x) \
+	Texture2D<float4> DDGIVolume_##x##_ProbeIrradiance; \
+	Texture2D<float4> DDGIVolume_##x##_ProbeDistance; \
+	RWTexture2D<float4> DDGIVolume_##x##_ProbeOffsets; \
+	float3 DDGIVolume_##x##_Position; \
+	float3 DDGIVolume_##x##_Radius; \
+	float3 DDGIVolume_##x##_ProbeGridSpacing; \
+	int3   DDGIVolume_##x##_ProbeGridCounts; \
+	uint   DDGIVolume_##x##_LightingChannelMask; \
+	int    DDGIVolume_##x##_ProbeNumIrradianceTexels; \
+	int    DDGIVolume_##x##_ProbeNumDistanceTexels; \
+	float  DDGIVolume_##x##_ProbeIrradianceEncodingGamma; \
+	float  DDGIVolume_##x##_NormalBias; \
+	float  DDGIVolume_##x##_ViewBias; \
+	float  DDGIVolume_##x##_BlendDistance; \
+	float  DDGIVolume_##x##_ApplyLighting; \
+	int3   DDGIVolume_##x##_ProbeScrollOffsets;
+VOLUME_LIST
+#undef VOLUME_ENTRY
+
+float ConvertFromDeviceZ(float DeviceZ)
+{
+	// Supports ortho and perspective, see CreateInvDeviceZToWorldZTransform()
+	return DeviceZ * InvDeviceZToWorldZTransform[0] + InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * InvDeviceZToWorldZTransform[2] - InvDeviceZToWorldZTransform[3]);
+}
+
+void MainVS(
+	in uint VertexId : SV_VertexID,
+	out float4 OutPosition : SV_POSITION,
+	out float3 OutScreenVector : TEXCOORD0)
+{
+	float2 uv = float2((VertexId << 1) & 2, VertexId & 2);
+	OutPosition = float4(uv * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), 0.0f, 1.0f);
+	OutScreenVector = mul(float4(OutPosition.xy, 1, 0), ScreenToTranslatedWorld).xyz;
+}
+
+bool ApplyVolumeLightingContribution(out float4 lightWeight, in Texture2D<float4> ProbeIrradiance, in Texture2D<float4> ProbeDistance, in RWTexture2D<float4> ProbeOffsets, in float3 WorldPosition, in float3 Normal, in float3 CameraDirection,
+uint pixelLightingMask, in uint volumeLightingChannelMask, in float3 volumeRadius, in DDGIVolumeDescGPU DDGIVolume, in float3 albedo, in float BlendDistance, in float ApplyLighting)
+{
+	lightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+
+	// ignore the volume if the lighting mask doesn't overlap
+	#if USE_LIGHTING_CHANNELS
+	if ((pixelLightingMask & volumeLightingChannelMask) == 0)
+		return false;
+	#endif
+
+	// ignore the volume if the pixel is outside of the volume
+	float3 relPos = abs(WorldPosition - DDGIVolume.origin);
+	if((relPos.x > volumeRadius.x || relPos.y > volumeRadius.y || relPos.z > volumeRadius.z))
+		return false;
+
+	// fill out a DDGIVolumeResources
+	DDGIVolumeResources resources;
+	{
+		resources.probeIrradianceSRV = ProbeIrradiance;
+		resources.probeDistanceSRV = ProbeDistance;
+		resources.trilinearSampler = LinearClampSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+		resources.probeOffsets = ProbeOffsets;
+#endif
+// It doesn't actually need this, so not passing it through
+//#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+		//resources.probeStates = ProbeStates;
+//#endif
+	}
+
+    // Get irradiance from the DDGIVolume
+	if (ApplyLighting > 0.0f)
+	{
+		float3 surfaceBias = DDGIGetSurfaceBias(Normal, CameraDirection, DDGIVolume);
+		float3 irradiance = DDGIGetVolumeIrradiance(
+			WorldPosition,
+			surfaceBias,
+			Normal,
+			DDGIVolume,
+			resources
+		);
+
+		lightWeight.rgb = irradiance * albedo;
+	}
+	else
+	{
+		lightWeight.rgb = float3(0.0f, 0.0f, 0.0f);
+	}
+
+	float3 edgeDist = (volumeRadius - abs(relPos));
+	lightWeight.a = (BlendDistance == 0.0f) ? 1.0f : clamp(min(edgeDist.x, min(edgeDist.y, edgeDist.z)) / BlendDistance, 0.0f, 1.0f);
+	return true;
+}
+
+void MainPS(
+	float4 SvPosition : SV_POSITION,
+	float3 InScreenVector : TEXCOORD0,
+	out float4 OutColor : SV_Target0
+	)
+{
+	int2 PixelPos = int2(SvPosition.xy);
+
+	// get information about our pixel
+	float DeviceZ = Depth.Load(int3(PixelPos, 0));
+	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
+	float3 WorldPosition = InScreenVector * SceneDepth + WorldCameraOrigin;
+	float3 Normal = normalize(Normals.Load(int3(PixelPos, 0)).xyz * 2.0f - 1.0f);
+	float3 baseColor = sRGBToLinear(BaseColor.Load(int3(PixelPos, 0)).rgb);
+	float metallic = Metallic.Load(int3(PixelPos, 0)).r;
+	float3 CameraDirection = normalize(InScreenVector);
+
+	float3 albedo = baseColor - baseColor * metallic;
+
+	#if USE_LIGHTING_CHANNELS
+	uint pixelLightingMask = uint(LightingChannelsTexture.Load(int3(PixelPos, 0)).x);
+	#else
+	uint pixelLightingMask = 0;
+	#endif
+
+	// Make DDGIVolumeDescGPU's. Rely on inlining and deadstripping to make this a noop.
+	#define VOLUME_ENTRY(x) \
+		DDGIVolumeDescGPU DDGIVolume_##x; \
+		DDGIVolume_##x.origin = DDGIVolume_##x##_Position; \
+		DDGIVolume_##x.probeGridSpacing = DDGIVolume_##x##_ProbeGridSpacing; \
+		DDGIVolume_##x.probeGridCounts = DDGIVolume_##x##_ProbeGridCounts; \
+		DDGIVolume_##x.probeNumIrradianceTexels = DDGIVolume_##x##_ProbeNumIrradianceTexels; \
+		DDGIVolume_##x.probeNumDistanceTexels = DDGIVolume_##x##_ProbeNumDistanceTexels; \
+		DDGIVolume_##x.probeIrradianceEncodingGamma = DDGIVolume_##x##_ProbeIrradianceEncodingGamma; \
+		DDGIVolume_##x.normalBias = DDGIVolume_##x##_NormalBias; \
+		DDGIVolume_##x.viewBias = DDGIVolume_##x##_ViewBias; \
+		DDGIVolume_##x.probeScrollOffsets = DDGIVolume_##x##_ProbeScrollOffsets;
+	VOLUME_LIST
+	#undef VOLUME_ENTRY
+
+	// NOTE: if wanting to visualize / debug the blend, it's useful to hard code some colors temporarily.
+	// like have volume zero be red, and volume one be yellow
+
+	// Gather up to 2 lighting contributions
+	float4 primaryLightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+	float4 secondaryLightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+	float4 lightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+	#define VOLUME_ENTRY(x) \
+	if (x < NumVolumes && primaryLightWeight.a < 1.0f && secondaryLightWeight.a == 0.0f && ApplyVolumeLightingContribution(lightWeight, DDGIVolume_##x##_ProbeIrradiance, DDGIVolume_##x##_ProbeDistance, DDGIVolume_##x##_ProbeOffsets, WorldPosition, Normal, CameraDirection, pixelLightingMask, \
+		uint(DDGIVolume_##x##_LightingChannelMask), DDGIVolume_##x##_Radius, DDGIVolume_##x, albedo, DDGIVolume_##x##_BlendDistance, DDGIVolume_##x##_ApplyLighting)) \
+		{ \
+			if (primaryLightWeight.a == 0.0f) \
+				primaryLightWeight = lightWeight; \
+			else \
+				secondaryLightWeight = lightWeight; \
+		}
+	VOLUME_LIST
+	#undef VOLUME_ENTRY
+
+	float preExposure = ShouldUsePreExposure ? PreExposure : 1.0f;
+
+	// Explanation of the statements below
+	// 1) If the pixel is not inside of any volume, return black.
+	// 2) If the pixel is inside of 1 volume, we want to fade it out by multiplying the primaryLightWeight color by the weight.
+	// 3) If we are in the non fade region of the primary volume, just use that color.
+	// 4) if we are in the fade region of both volumes, do something that preserves luminance of fade, since the color is going to be real similar anyways (this is the case for the max usage)
+	if (primaryLightWeight.a == 0.0f || secondaryLightWeight.a == 0.0f || primaryLightWeight.a == 1.0f || secondaryLightWeight.a < 1.0f)
+	{
+		OutColor = float4(primaryLightWeight.rgb * max(primaryLightWeight.a, secondaryLightWeight.a) * preExposure, 1.0f);
+	}
+	// else we are in the fade region of the primary volume, but not the fade region of the secondary volume, so blend between primary and secondary
+	else
+	{
+		OutColor = float4(lerp(secondaryLightWeight.rgb, primaryLightWeight.rgb, primaryLightWeight.a) * preExposure, 1.0f);
+	}
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf
new file mode 100644
index 00000000000..98938ad98c7
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf
@@ -0,0 +1,286 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#define OcclusionCullDirection 0
+
+#include "/Engine/Private/Common.ush"
+
+struct DDGIVolumeDescGPU
+{
+	float3 origin;
+	int numRaysPerProbe;
+	float3 probeGridSpacing;
+	float probeMaxRayDistance;
+	int3 probeGridCounts;
+	float4x4 probeRayRotationTransform;
+	float normalBias;
+	float viewBias;
+	float probeNumIrradianceTexels;
+	float probeNumDistanceTexels;
+	float probeIrradianceEncodingGamma;
+	int3 probeScrollOffsets;
+};
+
+// RTXGI SDK
+#include "/Plugin/RTXGI/Private/SDK/ddgi/Irradiance.ush"
+
+// needed by DeferredLightingCommon included indirectly
+#define SUPPORT_CONTACT_SHADOWS		0
+
+// from RayTracingPrimaryRays.usf - see that .cpp for how to pass all these params properly
+#define LTCMatTexture				RaytracingLightsDataPacked.LTCMatTexture
+#define LTCMatSampler				RaytracingLightsDataPacked.LTCMatSampler
+#define LTCAmpTexture				RaytracingLightsDataPacked.LTCAmpTexture
+#define LTCAmpSampler				RaytracingLightsDataPacked.LTCAmpSampler
+#define PreIntegratedGF				ReflectionStruct.PreIntegratedGF			
+#define PreIntegratedGFSampler		ReflectionStruct.PreIntegratedGFSampler	
+
+#include "/Engine/Private/DeferredLightingCommon.ush"
+#include "/Engine/Private/DeferredShadingCommon.ush"
+#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush" 
+#include "/Engine/Private/SceneTextureParameters.ush"
+#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDeferredShadingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingLightingCommon.ush"
+#include "/Engine/Private/ReflectionEnvironmentShared.ush"
+#include "/Engine/Private/Montecarlo.ush"
+#include "/Engine/Private/HeightFogCommon.ush"
+#include "/Engine/Private/SobolRandom.ush"
+
+// START RGS PARAMS
+RaytracingAccelerationStructure TLAS;
+
+RWTexture2D<float4> RadianceOutput;
+RWTexture2D<float4> DebugOutput;
+
+uint   FrameRandomSeed;
+
+Texture2D<float4>   DDGIVolume_ProbeIrradiance;
+Texture2D<float4>   DDGIVolume_ProbeDistance;
+RWTexture2D<float4> DDGIVolume_ProbeOffsets;
+RWTexture2D<uint>   DDGIVolume_ProbeStates;
+float3              DDGIVolume_Origin;
+float3              DDGIVolume_ProbeGridSpacing;
+float               DDGIVolume_ProbeMaxRayDistance;
+int3                DDGIVolume_ProbeGridCounts;
+float4x4            DDGIVolume_ProbeRayRotationTransform;
+int                 DDGIVolume_NumRaysPerProbe;
+float3              DDGIVolume_Radius;
+int                 DDGIVolume_ProbeNumIrradianceTexels;
+int                 DDGIVolume_ProbeNumDistanceTexels;
+float               DDGIVolume_ProbeIrradianceEncodingGamma;
+float               DDGIVolume_NormalBias;
+float               DDGIVolume_ViewBias;
+SamplerState        DDGIVolume_LinearClampSampler;
+int3                DDGIVolume_ProbeScrollOffsets;
+
+float3              Sky_Color;
+TextureCube<float4> Sky_Texture;
+SamplerState        Sky_TextureSampler;
+
+// END RGS PARAMS
+
+float3 GetEnvironmentalRadiance(in float3 direction)
+{
+	return Sky_Color * TextureCubeSampleLevel(Sky_Texture, Sky_TextureSampler, direction, 0).rgb;
+}
+
+void WriteRadianceOutput(uint2 DispatchIndex, float4 value)
+{
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+	RadianceOutput[DispatchIndex.xy] = value;
+#else
+	RadianceOutput[DispatchIndex.xy] = float4(asfloat(RTXGIFloat3ToUint(value.xyz)), value.w, 0.f, 0.f);
+#endif
+}
+
+RAY_TRACING_ENTRY_RAYGEN(ProbeUpdateRGS)
+{
+	DDGIVolumeDescGPU DDGIVolume;
+	DDGIVolume.origin = DDGIVolume_Origin;
+	DDGIVolume.numRaysPerProbe = DDGIVolume_NumRaysPerProbe;	
+	DDGIVolume.probeGridSpacing = DDGIVolume_ProbeGridSpacing;
+	DDGIVolume.probeMaxRayDistance = DDGIVolume_ProbeMaxRayDistance;
+	DDGIVolume.probeGridCounts = DDGIVolume_ProbeGridCounts;
+	DDGIVolume.probeRayRotationTransform = DDGIVolume_ProbeRayRotationTransform;
+	DDGIVolume.normalBias = DDGIVolume_NormalBias;
+	DDGIVolume.viewBias = DDGIVolume_ViewBias;
+	DDGIVolume.probeNumIrradianceTexels = DDGIVolume_ProbeNumIrradianceTexels;
+	DDGIVolume.probeNumDistanceTexels = DDGIVolume_ProbeNumDistanceTexels;
+	DDGIVolume.probeIrradianceEncodingGamma = DDGIVolume_ProbeIrradianceEncodingGamma;
+	DDGIVolume.probeScrollOffsets = DDGIVolume_ProbeScrollOffsets;
+
+	// Adapted from ProbeTraceRGS.hlsl in the test harness aiming for minimal changes to help future merges.
+
+    float4 result = 0.f;
+
+    uint2 DispatchIndex = DispatchRaysIndex().xy;
+    int rayIndex = DispatchIndex.x;                    // index of ray within a probe
+    int probeIndex = DispatchIndex.y;                  // index of current probe
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume.probeGridCounts, DDGIVolume.probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    int2 texelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume.probeGridCounts);
+    int  probeState = DDGIVolume_ProbeStates[texelPosition];
+    if (probeState == PROBE_STATE_INACTIVE && rayIndex >= NUM_FIXED_TEST_RAYS)
+    {
+       // if the probe is inactive, do not shoot rays, unless it is one of the fixed rays that could potentially reactivate the probe
+       return;
+    }
+#endif
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+	#if RTXGI_DDGI_PROBE_SCROLL
+	float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume.probeScrollOffsets, DDGIVolume_ProbeOffsets);
+	#else
+    float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume_ProbeOffsets);
+	#endif
+#else
+    float3 probeWorldPosition = DDGIGetProbeWorldPosition(probeIndex, DDGIVolume.origin, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing);
+#endif
+
+	float3 probeRayDirection = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+
+	// Setup the probe ray
+	RayDesc Ray;
+	Ray.Origin = probeWorldPosition;
+	Ray.Direction = probeRayDirection;
+	Ray.TMin = 0.f;
+	Ray.TMax = DDGIVolume.probeMaxRayDistance;
+
+	const int ReflectedShadowsType = 1; // = hard shadows.  make configurable?
+	const uint RefractionRayFlags = 0;
+	const uint RefractionInstanceInclusionMask = RAY_TRACING_MASK_ALL;
+	const bool bRefractionRayTraceSkyLightContribution = false;
+	const bool bRefractionDecoupleSampleGeneration = true;
+	const bool bRefractionEnableSkyLightContribution = true;
+	const bool ShouldDoDirectLighting = true;
+	const bool ShouldDoEmissiveAndIndirectLighting = true;
+	float3 PathVertexRadiance = float3(0, 0, 0);
+	FRayCone RayCone = (FRayCone)0;
+	float MaxNormalBias = 0.01f;
+
+	// Trace
+	uint linear_rand = DispatchIndex.x + DispatchIndex.y * 9973;
+	RandomSequence RandSequence;
+	RandomSequence_Initialize(RandSequence, linear_rand, FrameRandomSeed);
+	uint2 PixelCoord = DispatchRaysIndex().xy; // Hmmmm.... does TraceRayAndAccumulateResults() assume screen-space trace or is this just for stochastics?  hopefully the latter but fixme:checkme
+
+	FMaterialClosestHitPayload Payload = TraceRayAndAccumulateResults(
+		Ray,
+		TLAS,
+		RefractionRayFlags,
+		RefractionInstanceInclusionMask,
+		RandSequence,
+		PixelCoord,
+		MaxNormalBias,
+		ReflectedShadowsType,
+		ShouldDoDirectLighting,
+		ShouldDoEmissiveAndIndirectLighting,
+		bRefractionRayTraceSkyLightContribution,
+		bRefractionDecoupleSampleGeneration,
+		RayCone,
+		bRefractionEnableSkyLightContribution,
+		PathVertexRadiance);
+
+	result = float4(PathVertexRadiance.xyz, Payload.HitT);
+
+	// Ray miss. Set hit distance to a large value and exit early.
+	if (Payload.IsMiss())
+	{
+		result.rgb += GetEnvironmentalRadiance(Ray.Direction);
+
+		result.w = 1e27f;
+		WriteRadianceOutput(DispatchIndex.xy, result);
+
+		#if DDGIVolumeUpdateDebug != 0
+		DebugOutput[DispatchIndex.xy] = result;
+		#endif
+
+		return;
+	}
+
+	// Hit a surface backface. Set the radiance to black and exit early.
+	if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
+	{
+        // Shorten the hit distance on a backface hit by 80%
+        // Make distance negative to encode backface for the probe position preprocess.
+        WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, -Payload.HitT * 0.2f));
+
+		#if DDGIVolumeUpdateDebug != 0
+		DebugOutput[DispatchIndex.xy] = float4(0.f, 0.f, 0.f, -Payload.HitT * 0.2f);
+		#endif
+
+		return;
+	}
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    // hit a frontface, but probe is inactive, so this ray will only be used for reclassification, don't need any lighting
+    if (probeState == PROBE_STATE_INACTIVE)
+    {
+		WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, Payload.HitT));
+        return;
+    }
+#endif
+
+	float3 probeLighting = float3(0.0f, 0.0f, 0.0f);
+	{
+		float3 albedo = Payload.BaseColor - Payload.BaseColor * Payload.Metallic;
+
+		// fill out a DDGIVolumeResources
+		DDGIVolumeResources resources;
+		{
+			resources.probeIrradianceSRV = DDGIVolume_ProbeIrradiance;
+			resources.probeDistanceSRV = DDGIVolume_ProbeDistance;
+			resources.trilinearSampler = DDGIVolume_LinearClampSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+			resources.probeOffsets = DDGIVolume_ProbeOffsets;
+#endif
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+			resources.probeStates = DDGIVolume_ProbeStates;
+#endif
+		}
+
+		// Get irradiance from the DDGIVolume
+		float3 surfacePosWS = Ray.Origin + Ray.Direction * Payload.HitT;
+		float3 surfaceBias = DDGIGetSurfaceBias(Payload.WorldNormal, Ray.Direction, DDGIVolume);
+		float3 irradiance = DDGIGetVolumeIrradiance(
+			surfacePosWS,
+			surfaceBias,
+			Payload.WorldNormal,
+			DDGIVolume,
+			resources
+		);
+
+		probeLighting = irradiance * albedo / 3.14159265359f;
+
+		// don't apply volume lighting outside the volume
+		float3 relPos = abs(surfacePosWS - DDGIVolume_Origin);
+		if((relPos.x > DDGIVolume_Radius.x || relPos.y > DDGIVolume_Radius.y || relPos.z > DDGIVolume_Radius.z))
+			probeLighting = float3(0.0f, 0.0f, 0.0f);
+	}
+
+	WriteRadianceOutput(DispatchIndex.xy, float4(PathVertexRadiance.xyz + probeLighting, Payload.HitT));
+
+	#if DDGIVolumeUpdateDebug != 0
+	DebugOutput[DispatchIndex.xy] = float4(PathVertexRadiance.xyz + probeLighting, Payload.HitT);
+	#endif
+}
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf
new file mode 100644
index 00000000000..ce2105e973e
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf
@@ -0,0 +1,176 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+/*
+This shader shoots a viewport of rays so you can see what the volume sees, copying the logic of ProbeUpdateRGS.usf.
+
+r.RTXGI.DDGIProbeVis 0 - turn it off
+r.RTXGI.DDGIProbeVis 1 - render the scene color.  (VOLUME_DEBUG_VIEW == 0)
+r.RTXGI.DDGIProbeVis 2 - render misses (blue), hits (green), back face hits (red).  (VOLUME_DEBUG_VIEW == 1)
+
+then "vis DDGIProbeVis" to see the texture
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// needed by DeferredLightingCommon included indirectly
+#define SUPPORT_CONTACT_SHADOWS		0
+
+//macro to deal with parameter not used by miss shaders
+#define OcclusionCullDirection 0
+
+// from RayTracingPrimaryRays.usf - see that .cpp for how to pass all these params properly
+#define LTCMatTexture				RaytracingLightsDataPacked.LTCMatTexture
+#define LTCMatSampler				RaytracingLightsDataPacked.LTCMatSampler
+#define LTCAmpTexture				RaytracingLightsDataPacked.LTCAmpTexture
+#define LTCAmpSampler				RaytracingLightsDataPacked.LTCAmpSampler
+#define PreIntegratedGF				ReflectionStruct.PreIntegratedGF			
+#define PreIntegratedGFSampler		ReflectionStruct.PreIntegratedGFSampler	
+
+#include "/Engine/Private/DeferredLightingCommon.ush"
+#include "/Engine/Private/DeferredShadingCommon.ush"
+#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush" 
+#include "/Engine/Private/SceneTextureParameters.ush"
+#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDeferredShadingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingLightingCommon.ush"
+#include "/Engine/Private/ReflectionEnvironmentShared.ush"
+#include "/Engine/Private/Montecarlo.ush"
+#include "/Engine/Private/HeightFogCommon.ush"
+#include "/Engine/Private/SobolRandom.ush"
+
+// START RGS PARAMS
+RaytracingAccelerationStructure TLAS;
+
+uint        FrameRandomSeed;
+
+float3      CameraPos;
+float4x4    CameraMatrix;
+
+float       DDGIVolume_PreExposure;
+uint        DDGIVolume_ShouldUsePreExposure;
+
+float3              Sky_Color;
+TextureCube<float4> Sky_Texture;
+SamplerState        Sky_TextureSampler;
+
+RWTexture2D<float4> RadianceOutput;
+
+// END RGS PARAMS
+
+float3 GetEnvironmentalRadiance(in float3 direction)
+{
+	return Sky_Color * TextureCubeSampleLevel(Sky_Texture, Sky_TextureSampler, direction, 0).rgb;
+}
+
+// This should match the logic of ProbeUpdateRGS above, for best results.
+// It isn't sampling DDGI volumes though so is only direct lighting.
+RAY_TRACING_ENTRY_RAYGEN(ProbeViewRGS)
+{
+    uint2 DispatchIndex = DispatchRaysIndex().xy;
+
+	// This is to make the radiance be in a viewable range
+	float radianceMultiplier = DDGIVolume_ShouldUsePreExposure ? DDGIVolume_PreExposure : 1.0f;
+
+	RayDesc Ray;
+	Ray.Origin = CameraPos;
+	float3 rayTarget = float3(float2(DispatchIndex.xy) / float2(DispatchRaysDimensions().xy) * 2.0f - 1.0f, 1.0f);
+	rayTarget.y *= -1.0f;
+	float3 rayDir = mul(float4(normalize(rayTarget), 0.0f), CameraMatrix).xyz;
+	Ray.Direction = rayDir;
+	Ray.TMin = 0.f;
+	Ray.TMax = 10000.0f;
+
+	const int ReflectedShadowsType = 1; // = hard shadows.  make configurable?
+	const uint RefractionRayFlags = 0;
+	const uint RefractionInstanceInclusionMask = RAY_TRACING_MASK_ALL;
+	const bool bRefractionRayTraceSkyLightContribution = false;
+	const bool bRefractionDecoupleSampleGeneration = true;
+	const bool bRefractionEnableSkyLightContribution = true;
+	const bool ShouldDoDirectLighting = true;
+	const bool ShouldDoEmissiveAndIndirectLighting = true;
+	float3 PathVertexRadiance = float3(0, 0, 0);
+	FRayCone RayCone = (FRayCone)0;
+	float MaxNormalBias = 0.01f;
+
+	// Trace
+	uint linear_rand = DispatchIndex.x + DispatchIndex.y * 9973;
+	RandomSequence RandSequence;
+	RandomSequence_Initialize(RandSequence, linear_rand, FrameRandomSeed);
+	uint2 PixelCoord = DispatchRaysIndex().xy;
+
+	FMaterialClosestHitPayload Payload;
+	Payload.SetEnableSkyLightContribution();
+	
+	Payload = TraceRayAndAccumulateResults(
+		Ray,
+		TLAS,
+		RefractionRayFlags,
+		RefractionInstanceInclusionMask,
+		RandSequence,
+		PixelCoord,
+		MaxNormalBias,
+		ReflectedShadowsType,
+		ShouldDoDirectLighting,
+		ShouldDoEmissiveAndIndirectLighting,
+		bRefractionRayTraceSkyLightContribution,
+		bRefractionDecoupleSampleGeneration,
+		RayCone,
+		bRefractionEnableSkyLightContribution,
+		PathVertexRadiance);
+
+	float4 result = float4(PathVertexRadiance.xyz, Payload.HitT);
+
+	// show ray miss / hit / back face hit
+	#if VOLUME_DEBUG_VIEW == 1
+	{
+		if (Payload.IsMiss())
+		{
+			RadianceOutput[DispatchIndex.xy] = float4(0.0f, 0.0f, 100.0f, 1e27f);
+		}
+		else
+		{
+			if (Payload.IsFrontFace() || Payload.ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE)
+				RadianceOutput[DispatchIndex.xy] = float4(0.0f, 100.0f, 0.0f, Payload.HitT);
+			else
+				RadianceOutput[DispatchIndex.xy] = float4(100.0f, 0.0f, 0.0f, Payload.HitT);
+		}
+		return;
+	}
+	#endif
+
+	// Ray miss. Set hit distance to a large value and exit early.
+	if (Payload.IsMiss())
+	{
+		result.rgb += GetEnvironmentalRadiance(Ray.Direction);
+		result.rgb *= radianceMultiplier;
+
+		result.w = 1e27f;
+		RadianceOutput[DispatchIndex.xy] = result;
+		return;
+	}
+
+	// Hit a surface backface. Set the radiance to black and exit early.
+	if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
+	{
+        // Shorten the hit distance on a backface hit by 20%
+        // Make distance negative to encode backface for the probe position preprocess.
+        RadianceOutput[DispatchIndex.xy] = float4(0.f, 0.f, 0.f, -Payload.HitT * 0.2f);
+		return;
+	}
+
+	RadianceOutput[DispatchIndex.xy] = float4(PathVertexRadiance.xyz * radianceMultiplier, Payload.HitT);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush
new file mode 100644
index 00000000000..32ea123563c
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush
@@ -0,0 +1,82 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_COMMON_HLSL
+#define RTXGI_COMMON_HLSL
+
+#include "DDGIVolumeDefines.ush"
+
+// Number of fixed rays that should be used for probe relocation and classification
+// these rays will intentionally not vary in between frames for more temporally stable results
+#define NUM_FIXED_TEST_RAYS 32
+
+const static float RTXGI_PI = 3.1415926535897932f;
+
+//------------------------------------------------------------------------
+// Math Helpers
+//------------------------------------------------------------------------
+
+/**
+* Finds the largest component of the vector.
+*/
+float RTXGIMaxComponent(float3 a)
+{
+    return max(a.x, max(a.y, a.z));
+}
+
+/**
+* Returns either -1 or 1 based on the sign of the input value.
+* If the input is zero, 1 is returned.
+*/
+float RTXGISignNotZero(float v)
+{
+    return (v >= 0.f) ? 1.f : -1.f;
+}
+
+/**
+* 2-component version of RTXGISignNotZero.
+*/
+float2 RTXGISignNotZero(float2 v)
+{
+    return float2(RTXGISignNotZero(v.x), RTXGISignNotZero(v.y));
+}
+
+/**
+* Return the given float value as an unsigned integer within the given numerical scale.
+*/
+uint RTXGIFloatToUint(float v, float scale)
+{
+    return (uint)floor(v * scale + 0.5f);
+}
+
+/**
+* Pack a float3 into a 32-bit unsigned integer.
+* Red and green channels use 11 bits, the blue channel uses 10 bits.
+* Compliment of RTXGIUintToFloat3().
+*/
+uint RTXGIFloat3ToUint(float3 input)
+{
+    return (RTXGIFloatToUint(input.r, 2047.f)) | (RTXGIFloatToUint(input.g, 2047) << 11) | (RTXGIFloatToUint(input.b, 1023) << 22);
+}
+
+/**
+* Unpack a packed 32-bit unsigned integer to a float3.
+* Compliment of RTXGIFloat3ToUint().
+*/
+float3 RTXGIUintToFloat3(uint packed)
+{
+    float3 unpacked;
+    unpacked.x = (float)(packed & 0x000007FF) / 2047.f;
+    unpacked.y = (float)((packed >> 11) & 0x000007FF) / 2047.f;
+    unpacked.z = (float)((packed >> 22) & 0x000003FF) / 1023.f;
+    return unpacked;
+}
+
+#endif /* RTXGI_COMMON_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush
new file mode 100644
index 00000000000..1133ba77eb9
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush
@@ -0,0 +1,90 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_VOLUME_DEFINES_H
+#define RTXGI_DDGI_VOLUME_DEFINES_H
+
+// --- Resources -------------------------------------
+
+#ifndef RTXGI_DDGI_SDK_MANAGED_RESOURCES
+#define RTXGI_DDGI_SDK_MANAGED_RESOURCES 0
+#endif
+
+// low bit depth irradiance will set this to 0 for shaders, high bit depth will set it to 1.
+/*
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+#define RTXGI_DDGI_DEBUG_FORMAT_RADIANCE 0
+#endif
+*/
+
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_OFFSETS
+#define RTXGI_DDGI_DEBUG_FORMAT_OFFSETS 0
+#endif
+
+// --- Probe Update ----------------------------------
+
+#ifndef RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+#define RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY 1
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_PROBE_INDEXING
+#define RTXGI_DDGI_DEBUG_PROBE_INDEXING 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING
+#define RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING
+#define RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING 0
+#endif
+
+// --- Probe Movement --------------------------------
+
+// a per volume setting, so a shader permutation
+/*
+#ifndef RTXGI_DDGI_PROBE_SCROLL
+#define RTXGI_DDGI_PROBE_SCROLL 0
+#endif
+*/
+
+// --- Indirect Lighting -----------------------------
+
+#ifndef RTXGI_DDGI_COMPUTE_IRRADIANCE
+#define RTXGI_DDGI_COMPUTE_IRRADIANCE 1
+#endif
+
+#ifndef RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE
+#define RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE 1
+#endif
+
+// --- Early Access Features -------------------------
+
+// a per volume setting, so a shader permutation
+/*
+#ifndef RTXGI_DDGI_PROBE_RELOCATION
+#define RTXGI_DDGI_PROBE_RELOCATION 0
+#endif
+*/
+
+// always on, but defined to be 1 in code
+/*
+#ifndef RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+#define RTXGI_DDGI_PROBE_STATE_CLASSIFIER 0
+#endif
+*/
+
+// ---------------------------------------------------
+
+#endif /* RTXGI_DDGI_VOLUME_DEFINES_H */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDescGPU.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDescGPU.ush
new file mode 100644
index 00000000000..a64350dd7cb
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDescGPU.ush
@@ -0,0 +1,60 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_VOLUME_DESC_GPU_H
+#define RTXGI_DDGI_VOLUME_DESC_GPU_H
+
+/**
+ * DDGIVolumeDescGPU
+ * The condensed DDGIVolume descriptor for use on the GPU.
+ */
+struct DDGIVolumeDescGPU_TempRename
+{
+    float3      origin;
+    int         numRaysPerProbe;
+    float3      probeGridSpacing;
+    float       probeMaxRayDistance;
+    int3        probeGridCounts;
+    float       probeDistanceExponent;
+    float       probeHysteresis;
+    float       probeChangeThreshold;
+    float       probeBrightnessThreshold;
+    float       probeIrradianceEncodingGamma;
+    float       probeInverseIrradianceEncodingGamma;
+    int         probeNumIrradianceTexels;
+    int         probeNumDistanceTexels;
+    float       normalBias;
+    float       viewBias;
+    float3      probeVariablePad0;
+    float4x4    probeRayRotationTransform;      // 160B
+
+#if RTXGI_DDGI_PROBE_SCROLL
+    int         volumeMovementType;             // 0: default, 1: scrolling
+    int3        probeScrollOffsets;             // 176B
+#else
+    float4      probeVariablePad1;              // 176B
+#endif
+
+#if !RTXGI_DDGI_PROBE_RELOCATION && !RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    float4      padding[5];                     // 176B + 80B = 256B
+#elif !RTXGI_DDGI_PROBE_RELOCATION && RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    float       probeBackfaceThreshold;         // 180B
+    float3      padding;                        // 192B
+    float4      padding1[4];                    // 192B + 64B = 256B
+#elif RTXGI_DDGI_PROBE_RELOCATION /* && (RTXGI_DDGI_PROBE_STATE_CLASSIFIER || !RTXGI_DDGI_PROBE_STATE_CLASSIFIER) */
+    float       probeBackfaceThreshold;         // 180B
+    float       probeMinFrontfaceDistance;      // 184B
+    float2      padding;                        // 192B
+    float4      padding1[4];                    // 192B + 64B = 256B
+#endif
+
+};
+
+#endif /* RTXGI_DDGI_VOLUME_DESC_GPU_H */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush
new file mode 100644
index 00000000000..2be444d525d
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush
@@ -0,0 +1,202 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_IRRADIANCE_HLSL
+#define RTXGI_DDGI_IRRADIANCE_HLSL
+
+#include "ProbeCommon.ush"
+
+struct DDGIVolumeResources
+{
+    Texture2D<float4> probeIrradianceSRV;
+    Texture2D<float4> probeDistanceSRV;
+    SamplerState trilinearSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+    RWTexture2D<float4> probeOffsets;
+#endif
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    RWTexture2D<uint> probeStates;
+#endif
+};
+
+/**
+* Computes the surfaceBias parameter used by DDGIGetVolumeIrradiance().
+* The surfaceNormal and cameraDirection arguments are expected to be normalized.
+*/
+float3 DDGIGetSurfaceBias(float3 surfaceNormal, float3 cameraDirection, DDGIVolumeDescGPU DDGIVolume)
+{
+    return (surfaceNormal * DDGIVolume.normalBias) + (-cameraDirection * DDGIVolume.viewBias);
+}
+
+/**
+* Computes a blending weight for the given volume for blending between multiple volumes. 
+* Return value of 1.0 means full contribution from this volume while 0.0 means no contribution.
+*/ 
+float DDGIGetVolumeBlendWeight(float3 worldPosition, DDGIVolumeDescGPU volume)
+{
+    // Start fully weighted
+    float volumeBlendWeight = 1.f;
+    
+    // Shift from [-n/2, n/2] to [0, n]
+    float3 position = (worldPosition - volume.origin) + (volume.probeGridSpacing * (volume.probeGridCounts - 1)) * 0.5f;
+    float3 probeCoords = (position / volume.probeGridSpacing);
+
+    // Map numbers over the max to the range 0 to 1 for blending
+    float3 overProbeMax = (volume.probeGridCounts - 1.f) - probeCoords;
+
+    // Use the geometric mean across all axes for weight
+    volumeBlendWeight *= clamp(probeCoords.x, 0.f, 1.f);
+    volumeBlendWeight *= clamp(probeCoords.y, 0.f, 1.f);
+    volumeBlendWeight *= clamp(probeCoords.z, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.x, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.y, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.z, 0.f, 1.f);
+
+    return volumeBlendWeight;
+}
+
+/**
+* Samples irradiance from the given volume's probes using information about the surface, sampling direction, and volume.
+*/
+float3 DDGIGetVolumeIrradiance( 
+    float3 worldPosition,
+    float3 surfaceBias,
+    float3 direction,
+    DDGIVolumeDescGPU volume,
+    DDGIVolumeResources resources)
+{
+    float3 irradiance = float3(0.f, 0.f, 0.f);
+    float  accumulatedWeights = 0.f;
+
+    // Bias the world space position
+    float3 biasedWorldPosition = (worldPosition + surfaceBias);
+    
+    // Get the 3D grid coordinates of the base probe (near the biased world position)
+    int3   baseProbeCoords = DDGIGetBaseProbeGridCoords(biasedWorldPosition, volume.origin, volume.probeGridCounts, volume.probeGridSpacing);
+
+    // Get the world space position of the base probe
+    float3 baseProbeWorldPosition = DDGIGetProbeWorldPosition(baseProbeCoords, volume.origin, volume.probeGridCounts, volume.probeGridSpacing);
+
+    // Clamp the distance between the given point and the base probe's world position (on each axis) to [0, 1]
+    float3 alpha = clamp(((biasedWorldPosition - baseProbeWorldPosition) / volume.probeGridSpacing), float3(0.f, 0.f, 0.f), float3(1.f, 1.f, 1.f));
+
+    // Iterate over the 8 closest probes and accumulate their contributions
+    for(int probeIndex = 0; probeIndex < 8; probeIndex++)
+    {
+        // Compute the offset to the adjacent probe in grid coordinates by
+        // sourcing the offsets from the bits of the loop index: x = bit 0, y = bit 1, z = bit 2
+        int3 adjacentProbeOffset = int3(probeIndex, probeIndex >> 1, probeIndex >> 2) & int3(1, 1, 1);
+
+        // Get the 3D grid coordinates of the adjacent probe by adding the offset to the base probe
+        // Clamp to the grid boundaries
+        int3 adjacentProbeCoords = clamp(baseProbeCoords + adjacentProbeOffset, int3(0, 0, 0), volume.probeGridCounts - int3(1, 1, 1));
+
+        // Get the adjacent probe's world position
+#if RTXGI_DDGI_PROBE_RELOCATION
+#if RTXGI_DDGI_PROBE_SCROLL
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPositionWithOffset(adjacentProbeCoords, volume.origin, volume.probeGridCounts, volume.probeGridSpacing, volume.probeScrollOffsets, resources.probeOffsets);
+#else
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPositionWithOffset(adjacentProbeCoords, volume.origin, volume.probeGridCounts, volume.probeGridSpacing, resources.probeOffsets);
+#endif
+#else
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPosition(adjacentProbeCoords, volume.origin, volume.probeGridCounts, volume.probeGridSpacing);
+#endif
+
+        // Get the adjacent probe's index (used for texture lookups)
+        int adjacentProbeIndex = DDGIGetProbeIndex(adjacentProbeCoords, volume.probeGridCounts);
+
+        // Compute the distance and direction from the (biased and non-biased) shading point and the adjacent probe
+        float3 worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
+        float3 biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
+        float  biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);
+
+        // Compute trilinear weights based on the distance to each adjacent probe
+        // to smoothly transition between probes. adjacentProbeOffset is binary, so we're
+        // using a 1-alpha when adjacentProbeOffset = 0 and alpha when adjacentProbeOffset = 1.
+        float3 trilinear = max(0.001f, lerp(1.f - alpha, alpha, adjacentProbeOffset));
+        float  trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
+        float  weight = 1.f;
+
+        // A naive soft backface weight would ignore a probe when
+        // it is behind the surface. That's good for walls, but for
+        // small details inside of a room, the normals on the details
+        // might rule out all of the probes that have mutual visibility 
+        // to the point. We instead use a "wrap shading" test. The small
+        // offset at the end reduces the "going to zero" impact.
+        float wrapShading = (dot(worldPosToAdjProbe, direction) + 1.f) * 0.5f;
+        weight *= (wrapShading * wrapShading) + 0.2f;
+
+        // Compute the texture coordinates of this adjacent probe and sample the probe's filtered distance
+        float2 octantCoords = DDGIGetOctahedralCoordinates(-biasedPosToAdjProbe);
+#if RTXGI_DDGI_PROBE_SCROLL
+        float2 probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumDistanceTexels, volume.probeScrollOffsets);
+#else
+        float2 probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumDistanceTexels);
+#endif
+        float2 filteredDistance = resources.probeDistanceSRV.SampleLevel(resources.trilinearSampler, probeTextureCoords, 0).rg;
+
+        float meanDistanceToSurface = filteredDistance.x;
+        float variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);
+
+        float chebyshevWeight = 1.f;
+        if(biasedPosToAdjProbeDist > meanDistanceToSurface) // In "shadow"
+        {
+            // v must be greater than 0, which is guaranteed by the if condition above.
+            float v = biasedPosToAdjProbeDist - meanDistanceToSurface;
+            chebyshevWeight = variance / (variance + (v * v));
+        
+            // Increase the contrast in the weight
+            chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.f);
+        }
+
+        // Avoid visibility weights ever going all the way to zero because
+        // when *no* probe has visibility we need a fallback value
+        weight *= max(0.05f, chebyshevWeight);
+
+        // Avoid a weight of zero
+        weight = max(0.000001f, weight);
+
+        // A small amount of light is visible due to logarithmic perception, so
+        // crush tiny weights but keep the curve continuous
+        const float crushThreshold = 0.2f;
+        if (weight < crushThreshold)
+        {
+            weight *= (weight * weight) * (1.f / (crushThreshold * crushThreshold));
+        }
+
+        // Apply the trilinear weights
+        weight *= trilinearWeight;
+
+        // Sample the probe irradiance
+        octantCoords = DDGIGetOctahedralCoordinates(direction);
+#if RTXGI_DDGI_PROBE_SCROLL
+        probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumIrradianceTexels, volume.probeScrollOffsets);
+#else
+        probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumIrradianceTexels);
+#endif
+        float3 probeIrradiance = resources.probeIrradianceSRV.SampleLevel(resources.trilinearSampler, probeTextureCoords, 0).rgb;
+
+        // Decode the tone curve, but leave a gamma = 2 curve to approximate sRGB blending for the trilinear
+        float3 exponent = volume.probeIrradianceEncodingGamma * 0.5f;
+        probeIrradiance = pow(probeIrradiance, exponent);
+
+        // Accumulate the weighted irradiance
+        irradiance += (weight * probeIrradiance);
+        accumulatedWeights += weight;
+    }
+
+    irradiance *= (1.f / accumulatedWeights);   // Normalize by the accumulated weights
+    irradiance *= irradiance;                   // Go back to linear irradiance
+    irradiance *= (0.5f * RTXGI_PI);            // Factored out of the probes
+
+    return irradiance;
+}
+
+#endif /* RTXGI_DDGI_IRRADIANCE_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf
new file mode 100644
index 00000000000..6639f55aa73
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf
@@ -0,0 +1,332 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// This needs to match EDDGIRaysPerProbe in DDGIVolumeComponent.h
+#if RAYS_PER_PROBE_ENUM == 0
+	#define RAYS_PER_PROBE 144
+#elif RAYS_PER_PROBE_ENUM == 1
+	#define RAYS_PER_PROBE 288
+#elif RAYS_PER_PROBE_ENUM == 2
+	#define RAYS_PER_PROBE 432
+#elif RAYS_PER_PROBE_ENUM == 3
+	#define RAYS_PER_PROBE 576
+#elif RAYS_PER_PROBE_ENUM == 4
+	#define RAYS_PER_PROBE 720
+#elif RAYS_PER_PROBE_ENUM == 5
+	#define RAYS_PER_PROBE 864
+#elif RAYS_PER_PROBE_ENUM == 6
+	#define RAYS_PER_PROBE 1008
+#endif
+
+// Below is Adapted from ProbeBlendingCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+struct DDGIVolumeDescGPU_Local
+{
+	int3        probeGridCounts;
+	int         numRaysPerProbe;
+	float4x4    probeRayRotationTransform;
+	float3      probeGridSpacing;
+	float       probeDistanceExponent;
+	float       probeInverseIrradianceEncodingGamma;
+	float       probeHysteresis;
+	float       probeChangeThreshold;
+	float       probeBrightnessThreshold;
+	int3        probeScrollOffsets;
+};
+
+#include "ProbeCommon.ush"
+
+// Note: PROBE_NUM_TEXELS must be passed in as a define at shader compilation time
+// See Harness.cpp::CompileShaders() in the Test Harness application
+//#define PROBE_NUM_TEXELS [6|14]
+
+int3        DDGIVolume_probeGridCounts;
+int         DDGIVolume_numRaysPerProbe;
+float4x4    DDGIVolume_probeRayRotationTransform;
+float3      DDGIVolume_probeGridSpacing;
+float       DDGIVolume_probeDistanceExponent;
+float       DDGIVolume_probeInverseIrradianceEncodingGamma;
+float       DDGIVolume_probeHysteresis;
+float       DDGIVolume_probeChangeThreshold;
+float       DDGIVolume_probeBrightnessThreshold;
+int3		DDGIVolume_probeScrollOffsets;
+
+// Probe ray traced radiance and hit distance
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+
+// Probe irradiance or filtered distance
+RWTexture2D<float4> DDGIProbeUAV;
+RWTexture2D<float4> DebugOutput;
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+// Probe states
+RWTexture2D<uint>   DDGIProbeStates;
+#endif
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+// Note: When using shared memory, RAYS_PER_PROBE must be passed in as a define at shader compilation time 
+// See Harness.cpp::CompileShaders() in the Test Harness application
+// #define RAYS_PER_PROBE 144
+
+// Shared Memory (example for default settings):
+// Radiance (float3) x 144 rays/probe = 432 floats (~1.7 KB)
+// Distance (float) x 144 rays/probe = 144 floats (~0.56 KB)
+// Ray Directions (float3 x 144 rays/probe) = 432 floats (~1.7 KB)
+//
+// Max shared memory usage = ~3.96 KB (~1.7 KB radiance + ~0.56 KB distance + ~1.7 KB directions)
+
+// Example usage:
+// Irradiance thread groups as 6 x 6 = 36 threads
+//     Group threads load 144 ray radiance & distance values / 36 threads = 4 ray radiance & distance values / thread
+//     Group threads compute 144 ray directions / 36 threads = 4 directions / thread
+// Distance thread groups are 14 x 14 = 196 threads
+//     Group threads load 144 ray distances / 196 threads = ~0.73 ray distance values / thread
+//     Group threads compute 144 ray directions / 196 threads = ~0.73 ray directions / thread
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+groupshared float3 RTRadiance[RAYS_PER_PROBE];
+#endif
+groupshared float  RTDistance[RAYS_PER_PROBE];
+groupshared float3 RayDirection[RAYS_PER_PROBE];
+#endif
+
+[numthreads(PROBE_NUM_TEXELS, PROBE_NUM_TEXELS, 1)]
+void DDGIProbeBlendingCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+	// I couldn't get UE4 to accept using a struct for the shader parameter, despite structs being used elsewhere.
+	DDGIVolumeDescGPU_Local DDGIVolume;
+	DDGIVolume.probeGridCounts = DDGIVolume_probeGridCounts;
+	DDGIVolume.numRaysPerProbe = DDGIVolume_numRaysPerProbe;
+	DDGIVolume.probeRayRotationTransform = DDGIVolume_probeRayRotationTransform;
+	DDGIVolume.probeGridSpacing = DDGIVolume_probeGridSpacing;
+	DDGIVolume.probeDistanceExponent = DDGIVolume_probeDistanceExponent;
+	DDGIVolume.probeInverseIrradianceEncodingGamma = DDGIVolume_probeInverseIrradianceEncodingGamma;
+	DDGIVolume.probeHysteresis = DDGIVolume_probeHysteresis;
+	DDGIVolume.probeChangeThreshold = DDGIVolume_probeChangeThreshold;
+	DDGIVolume.probeBrightnessThreshold = DDGIVolume_probeBrightnessThreshold;
+	DDGIVolume.probeScrollOffsets = DDGIVolume_probeScrollOffsets;
+
+    float4 result = float4(0.f, 0.f, 0.f, 0.f);
+
+    // Find the index of the probe that this thread maps to (for reading the RT radiance buffer)
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume.probeGridCounts, PROBE_NUM_TEXELS);
+	float3 probeRayDirection = float3(1.0f, 0.0f, 0.0f);
+	uint2 probeTexCoords = uint2(0, 0);
+	bool exitEarly = false;
+    while (probeIndex >= 0)  // we have to do it this way so the GroupMemoryBarrierWithGroupSync() call isn't conditional when UE compiles this shader.
+    {
+#if RTXGI_DDGI_PROBE_SCROLL
+		int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume.probeGridCounts, DDGIVolume.probeScrollOffsets);
+		// Transform the probe index into probe texel coordinates
+		// Offset 1 texel on X and Y to account for the 1 texel probe border
+		uint2 intraProbeTexelOffset = DispatchThreadID.xy % uint2(PROBE_NUM_TEXELS, PROBE_NUM_TEXELS);
+		probeTexCoords = DDGIGetThreadBaseCoords(storageProbeIndex, DDGIVolume.probeGridCounts, PROBE_NUM_TEXELS) + intraProbeTexelOffset;
+		probeTexCoords.xy = probeTexCoords.xy + uint2(1, 1) + (probeTexCoords.xy / PROBE_NUM_TEXELS) * 2;
+#else
+		int storageProbeIndex = probeIndex;
+		// Transform the thread dispatch index into probe texel coordinates
+		// Offset 1 texel on X and Y to account for the 1 texel probe border
+		probeTexCoords = DispatchThreadID.xy + uint2(1, 1);
+		probeTexCoords.xy += (DispatchThreadID.xy / PROBE_NUM_TEXELS) * 2;
+#endif
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+		int2 texelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume.probeGridCounts);
+		int  probeState = DDGIProbeStates[texelPosition];
+		if (probeState == PROBE_STATE_INACTIVE)
+		{
+			exitEarly = true;
+			break; // If the probe is inactive, do not blend (it didn't shoot rays to get new radiance values)
+		}
+#endif /* RTXGI_DDGI_PROBE_STATE_CLASSIFIER */
+
+#if RTXGI_DDGI_BLEND_RADIANCE && RTXGI_DDGI_DEBUG_PROBE_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+		// Visualize the probe index
+		DDGIProbeUAV[0][probeTexCoords] = float4(probeIndex, 0, 0, 1);
+		return;
+#endif
+
+		float2 probeOctantUV = float2(0.f, 0.f);
+
+#if RTXGI_DDGI_BLEND_RADIANCE && RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING
+		probeOctantUV = DDGIGetNormalizedOctahedralCoordinates(int2(DispatchThreadID.xy), PROBE_NUM_TEXELS);
+		if (all(abs(probeOctantUV) <= 1.f))
+		{
+			float3 probeDirection = DDGIGetOctahedralDirection(probeOctantUV);
+			probeDirection = (abs(probeDirection) >= 0.001f) * sign(probeDirection);    // Robustness for when the octant size is not a power of 2.
+			result = float4((probeDirection * 0.5f) + 0.5f, 1.f);
+		}
+		DDGIProbeUAV[0][probeTexCoords] = result;
+		return;
+#endif
+
+		// Get the probe ray direction associated with this thread
+		probeOctantUV = DDGIGetNormalizedOctahedralCoordinates(int2(DispatchThreadID.xy), PROBE_NUM_TEXELS);
+		probeRayDirection = DDGIGetOctahedralDirection(probeOctantUV);
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+		// Cooperatively load the ray traced radiance and hit distance values into shared memory
+		// Cooperatively compute the probe ray directions
+		int totalIterations = int(ceil(float(RAYS_PER_PROBE) / float(PROBE_NUM_TEXELS * PROBE_NUM_TEXELS)));
+		for (int iteration = 0; iteration < totalIterations; iteration++)
+		{
+			int rayIndex = (GroupIndex * totalIterations) + iteration;
+			if (rayIndex >= RAYS_PER_PROBE) break;
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+			RTRadiance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].rgb;
+#else
+			RTRadiance[rayIndex] = RTXGIUintToFloat3(asuint(DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].r));
+#endif
+#endif
+
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+			RTDistance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].a;
+#else
+			RTDistance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].g;
+#endif
+
+			RayDirection[rayIndex] = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+		}
+#endif /* RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY */
+		break;
+	}
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+	// Wait for all threads in the group to finish shared memory operations
+	GroupMemoryBarrierWithGroupSync();
+#endif /* RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY */
+
+    if (probeIndex < 0 || exitEarly)
+    {
+        return; // Probe doesn't exist, or we want to exit for other reasons
+    }
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+    // Backface hits are ignored when blending radiance
+    // Allow a maximum of 10% of the rays to hit backfaces. If that limit is exceeded, don't blend anything into this probe.
+    uint backfaces = 0;
+    uint maxBackfaces = DDGIVolume.numRaysPerProbe * 0.1f;
+#endif
+
+    int rayIndex = 0;
+#if RTXGI_DDGI_PROBE_RELOCATION || RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    rayIndex = NUM_FIXED_TEST_RAYS;
+#endif
+
+    // Blend radiance or distance values from each ray to compute irradiance or fitered distance
+    for ( /*rayIndex*/; rayIndex < DDGIVolume.numRaysPerProbe; rayIndex++)
+    {
+        // Get the direction for this probe ray
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float3 rayDirection = RayDirection[rayIndex];
+#else
+        float3 rayDirection = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+#endif
+
+        // Find the weight of the contribution for this ray
+        // Weight is based on the cosine of the angle between the ray direction and the direction of the probe octant's texel
+        float weight = max(0.f, dot(probeRayDirection, rayDirection));
+
+        // The indices of the probe ray in the radiance buffer
+        int2 probeRayIndex = int2(rayIndex, probeIndex);
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+        // Load the ray traced radiance and hit distance
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float3 probeRayRadiance = RTRadiance[rayIndex];
+        float  probeRayDistance = RTDistance[rayIndex];
+#else
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float3 probeRayRadiance = DDGIProbeRTRadianceUAV[probeRayIndex].rgb;
+        float  probeRayDistance = DDGIProbeRTRadianceUAV[probeRayIndex].a;
+#else
+        float3 probeRayRadiance = RTXGIUintToFloat3(asuint(DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].r));
+        float  probeRayDistance = DDGIProbeRTRadianceUAV[probeRayIndex].g;
+#endif
+#endif
+
+        // Backface hit, don't blend this sample
+        if (probeRayDistance < 0.f)
+        {
+            backfaces++;
+            if (backfaces >= maxBackfaces) return;
+            continue;
+        }
+
+        // Blend the ray's radiance
+        result += float4(probeRayRadiance * weight, weight);
+
+#else /* !RTXGI_DDGI_BLEND_RADIANCE */
+
+        // Initialize the probe hit distance to three quarters of the distance of the grid cell diagonal
+        float probeMaxRayDistance = length(DDGIVolume.probeGridSpacing) * 0.75f;
+
+        // Increase or decrease the filtered distance value's "sharpness"
+        weight = pow(weight, DDGIVolume.probeDistanceExponent);
+
+        // Load the ray traced distance
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float probeRayDistance = min(abs(RTDistance[rayIndex]), probeMaxRayDistance);
+#else
+        // HitT is negative on backface hits for the probe relocation, so take the absolute value
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float probeRayDistance = min(abs(DDGIProbeRTRadianceUAV[probeRayIndex].a), probeMaxRayDistance);
+#else
+        float probeRayDistance = min(abs(DDGIProbeRTRadianceUAV[probeRayIndex].g), probeMaxRayDistance);
+#endif
+#endif
+
+        // Filter the ray distance
+        result += float4(probeRayDistance * weight, (probeRayDistance * probeRayDistance) * weight, 0.f, weight);
+#endif
+    }
+
+    // Normalize the blended irradiance (or filtered distance), if the combined weight is not close to zero
+    const float epsilon = 1e-9f * float(DDGIVolume.numRaysPerProbe);
+    result.rgb *= 1.f / max(result.a, epsilon);
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+    // Tone-mapping gamma adjustment
+    result.rgb = pow(result.rgb, DDGIVolume.probeInverseIrradianceEncodingGamma);
+#endif
+
+    float  hysteresis = DDGIVolume.probeHysteresis;
+    float3 previous = DDGIProbeUAV[probeTexCoords].rgb;
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+    if (RTXGIMaxComponent(previous.rgb - result.rgb) > DDGIVolume.probeChangeThreshold)
+    {
+        // Lower the hysteresis when a large lighting change is detected
+        hysteresis = max(0.f, hysteresis - 0.15f);
+    }
+    
+    float3 delta = (result.rgb - previous.rgb);
+    if (length(delta) > DDGIVolume.probeBrightnessThreshold)
+    {
+        // Clamp the maximum change in irradiance when a large brightness change is detected
+        result.rgb = previous.rgb + (delta * 0.25f);
+    }
+#endif
+
+    // Interpolate the new blended irradiance (or filtered distance) with the existing 
+    // irradiance (or filtered distance) in the probe. A high hysteresis value emphasizes
+    // the existing probe irradiance (or filtered distance).
+    result = float4(lerp(result.rgb, previous.rgb, hysteresis), 1.f);
+
+    DDGIProbeUAV[probeTexCoords] = result;
+
+	#if DDGIIrradianceBlendDebug != 0 || DDGIDistanceBlendDebug != 0
+	DebugOutput[probeTexCoords] = result;
+	#endif
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf
new file mode 100644
index 00000000000..9b5c6243a98
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf
@@ -0,0 +1,126 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeBorderUpdateCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "../DDGIVolumeDefines.ush"
+#include "../DDGIVolumeDescGPU.ush"
+
+uint    ProbeNumIrradianceOrDistanceTexels;
+
+// Probe irradiance or filtered distance
+RWTexture2D<float4> DDGIProbeUAV;
+
+[numthreads(8, 8, 1)]
+void DDGIProbeBorderRowUpdateCS(uint3 DispatchThreadID : SV_DispatchThreadID)
+{
+    uint probeSideLength = (ProbeNumIrradianceOrDistanceTexels + 2);
+    uint probeSideLengthMinusOne = (probeSideLength - 1);
+
+    // Map thread index to border row texel coordinates
+    uint2 threadCoordinates = DispatchThreadID.xy;
+    threadCoordinates.y *= probeSideLength;
+
+    // Ignore the corner texels
+    int mod = (DispatchThreadID.x % probeSideLength);
+    if (mod == 0 || mod == int(probeSideLengthMinusOne))
+    {
+        return;
+    }
+
+    // Compute the interior texel coordinates to copy (top row)
+    uint probeStart = uint(threadCoordinates.x / probeSideLength) * probeSideLength;
+    uint offset = probeSideLengthMinusOne - (threadCoordinates.x % probeSideLength);
+
+    uint2 copyCoordinates = uint2(probeStart + offset, (threadCoordinates.y + 1));
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    threadCoordinates.y += probeSideLengthMinusOne;
+    copyCoordinates = uint2(probeStart + offset, threadCoordinates.y - 1);
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    return;
+#endif
+
+    // Top row
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+
+    // Compute the interior texel coordinate to copy (bottom row)
+    threadCoordinates.y += probeSideLengthMinusOne;
+    copyCoordinates = uint2(probeStart + offset, threadCoordinates.y - 1);
+
+    // Bottom row   
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+}
+
+[numthreads(8, 8, 1)]
+void DDGIProbeBorderColumnUpdateCS(uint3 DispatchThreadID : SV_DispatchThreadID)
+{
+    uint probeSideLength = (ProbeNumIrradianceOrDistanceTexels + 2);
+    uint probeSideLengthMinusOne = (probeSideLength - 1);
+
+    // Map thread index to border row texel coordinates
+    uint2 threadCoordinates = DispatchThreadID.xy;
+    threadCoordinates.x *= probeSideLength;
+
+    uint2 copyCoordinates = uint2(0, 0);
+
+    // Handle the corner texels
+    int mod = (threadCoordinates.y % probeSideLength);
+    if (mod == 0 || mod == int(probeSideLengthMinusOne))
+    {
+        // Left corner
+        copyCoordinates.x = threadCoordinates.x + ProbeNumIrradianceOrDistanceTexels;
+        copyCoordinates.y = threadCoordinates.y - sign(mod - 1) * ProbeNumIrradianceOrDistanceTexels;
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+        DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+#else
+        DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+#endif
+
+        // Right corner
+        threadCoordinates.x += probeSideLengthMinusOne;
+        copyCoordinates.x = threadCoordinates.x - ProbeNumIrradianceOrDistanceTexels;
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING & RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+        DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+#else
+        DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+#endif
+        return;
+    }
+
+    // Compute the interior texel coordinates to copy (left column)
+    uint probeStart = uint(threadCoordinates.y / probeSideLength) * probeSideLength;
+    uint offset = probeSideLengthMinusOne - (threadCoordinates.y % probeSideLength);
+
+    copyCoordinates = uint2(threadCoordinates.x + 1, probeStart + offset);
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    threadCoordinates.x += probeSideLengthMinusOne;
+    copyCoordinates = uint2(threadCoordinates.x - 1, probeStart + offset);
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    return;
+#endif
+
+    // Left column
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+
+    // Compute the interior texel coordinate to copy (right column)
+    threadCoordinates.x += probeSideLengthMinusOne;
+    copyCoordinates = uint2(threadCoordinates.x - 1, probeStart + offset);
+
+    // Right column
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+}
\ No newline at end of file
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush
new file mode 100644
index 00000000000..0e40fd8f746
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush
@@ -0,0 +1,494 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_PROBE_COMMON_HLSL
+#define RTXGI_DDGI_PROBE_COMMON_HLSL
+
+#include "../Common.ush"
+#include "../../SDKDefines.ush"
+#include "../DDGIVolumeDefines.ush"
+#include "../DDGIVolumeDescGPU.ush"
+
+//------------------------------------------------------------------------
+// Probe Indexing Helpers
+//------------------------------------------------------------------------
+
+/**
+* Gets the number of probes on a horizontal plane in the active coordinate system.
+*/
+int DDGIGetProbesPerPlane(int3 probeGridCounts)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return (probeGridCounts.x * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return (probeGridCounts.x * probeGridCounts.y);
+#endif
+}
+
+/**
+* Get the index of the horizontal plane that the thread coordinates map to in the active coordinate system.
+*/
+int DDGIGetPlaneIndex(uint2 threadCoords, int3 probeGridCounts, int probeNumTexels)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return int(threadCoords.x / (probeGridCounts.x * probeNumTexels));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return int(threadCoords.x / (probeGridCounts.y * probeNumTexels));
+#endif
+}
+
+/**
+* Gets the index of a probe within a given horizontal plane in the active coordinate system.
+*/
+int DDGIGetProbeIndexInPlane(uint2 threadCoords, int planeIndex, int3 probeGridCounts, int probeNumTexels)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return int(threadCoords.x / probeNumTexels) - (planeIndex * probeGridCounts.x) + (probeGridCounts.x * int(threadCoords.y / probeNumTexels));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return int(threadCoords.x / probeNumTexels) - (planeIndex * probeGridCounts.y) + (probeGridCounts.y * int(threadCoords.y / probeNumTexels));
+#endif
+}
+
+//------------------------------------------------------------------------
+// Octahedral Paramerization
+//------------------------------------------------------------------------
+
+/**
+* Compute the offset and state texel position for the given probeIndex.
+*/
+int2 DDGIGetProbeTexelPosition(int probeIndex, int3 probeGridCounts)
+{
+    // Compute the probe index for this thread
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return int2(probeIndex % (probeGridCounts.x * probeGridCounts.y), probeIndex / (probeGridCounts.x * probeGridCounts.y));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return int2(probeIndex % (probeGridCounts.y * probeGridCounts.z), probeIndex / (probeGridCounts.y * probeGridCounts.z));
+#endif
+}
+
+/**
+* Computes the normalized texture coordinates of the given probe,
+* using the probe index, octant coordinates, probe grid counts,
+* and the number of texels used by a probe.
+*/
+#if RTXGI_DDGI_PROBE_SCROLL
+float2 DDGIGetProbeUV(uint probeIndex, float2 octantCoordinates, int3 probeGridCounts, int numTexels, int3 probeScrollOffsets)
+#else
+float2 DDGIGetProbeUV(uint probeIndex, float2 octantCoordinates, int3 probeGridCounts, int numTexels)
+#endif
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = int(probeIndex / probesPerPlane);
+
+    float probeInteriorTexels = float(numTexels);
+    float probeTexels = (probeInteriorTexels + 2.f);
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int gridSpaceX = (probeIndex % probeGridCounts.x);
+    int gridSpaceY = (probeIndex / probeGridCounts.x);
+#if RTXGI_DDGI_PROBE_SCROLL
+    gridSpaceX = (gridSpaceX + probeScrollOffsets.x) % probeGridCounts.x;
+    gridSpaceY = (gridSpaceY + probeScrollOffsets.z) % probeGridCounts.z;
+    planeIndex = (planeIndex + probeScrollOffsets.y) % probeGridCounts.y;
+#endif
+    int x = gridSpaceX + (planeIndex * probeGridCounts.x);
+    int y = gridSpaceY % probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int gridSpaceX = (probeIndex % probeGridCounts.y);
+    int gridSpaceY = (probeIndex / probeGridCounts.y);
+#if RTXGI_DDGI_PROBE_SCROLL
+    gridSpaceX = (gridSpaceX + probeScrollOffsets.y) % probeGridCounts.y;
+    gridSpaceY = (gridSpaceY + probeScrollOffsets.x) % probeGridCounts.x;
+    planeIndex = (planeIndex + probeScrollOffsets.z) % probeGridCounts.z;
+#endif
+    int x = gridSpaceX + (planeIndex * probeGridCounts.y);
+    int y = gridSpaceY % probeGridCounts.x;
+#endif
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    float textureWidth = probeTexels * (probeGridCounts.x * probeGridCounts.y);
+    float textureHeight = probeTexels * probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    float textureWidth = probeTexels * (probeGridCounts.y * probeGridCounts.z);
+    float textureHeight = probeTexels * probeGridCounts.x;
+#endif
+
+    float2 uv = float2(x * probeTexels, y * probeTexels) + (probeTexels * 0.5f);
+    uv += octantCoordinates.xy * (probeInteriorTexels * 0.5f);
+    uv /= float2(textureWidth, textureHeight);
+    return uv;
+}
+
+/**
+* Computes normalized octahedral coordinates for the given thread/pixel coordinates.
+* Maps the top left texel to (-1,-1).
+*/
+float2 DDGIGetNormalizedOctahedralCoordinates(int2 threadCoords, int numTexels)
+{
+    // Map thread coordinates to a normalized octahedral space
+    float2 octahedralTexelCoord = float2(threadCoords.x % numTexels, threadCoords.y % numTexels);
+
+    // Move to the center of a texel
+    octahedralTexelCoord.xy += 0.5f;
+
+    // Normalize
+    octahedralTexelCoord.xy /= float(numTexels);
+
+    // Shift to [-1, 1);
+    octahedralTexelCoord *= 2.f;
+    octahedralTexelCoord -= float2(1.f, 1.f);
+
+    return octahedralTexelCoord;
+}
+
+/**
+* Computes the normalized octahedral direction that corresponds to the
+* given normalized coordinates on the [-1, 1] square.
+* The opposite of DDGIGetOctahedralCoordinates().
+*/
+float3 DDGIGetOctahedralDirection(float2 coords)
+{
+    float3 direction = float3(coords.x, coords.y, 1.f - abs(coords.x) - abs(coords.y));
+    if (direction.z < 0.f)
+    {
+        direction.xy = (1.f - abs(direction.yx)) * RTXGISignNotZero(direction.xy);  
+    }
+    return normalize(direction);
+}
+
+/**
+* Computes the octant coordinates in the normalized [-1, 1] square, for the given a unit direction vector.
+* The opposite of DDGIGetOctahedralDirection().
+*/
+float2 DDGIGetOctahedralCoordinates(float3 direction)
+{
+    float l1norm = abs(direction.x) + abs(direction.y) + abs(direction.z);
+    float2 uv = direction.xy * (1.f / l1norm);
+    if (direction.z < 0.f)
+    {
+        uv = (1.f - abs(uv.yx)) * RTXGISignNotZero(uv.xy);
+    }
+    return uv;
+}
+
+//------------------------------------------------------------------------
+// Probe Ray Direction
+//------------------------------------------------------------------------
+
+/*
+* Computes a low discrepancy spherically distributed direction on the unit sphere,
+* for the given index in a set of samples. Each direction is unique in 
+* the set, but the set of directions is always the same.
+*/
+float3 DDGISphericalFibonacci(float index, float numSamples)
+{
+    const float b = (sqrt(5.f) * 0.5f + 0.5f) - 1.f;
+    float phi = 2.f * RTXGI_PI * frac(index * b);
+    float cosTheta = 1.f - (2.f * index + 1.f) * (1.f / numSamples);
+    float sinTheta = sqrt(saturate(1.f - (cosTheta * cosTheta)));
+
+    return float3((cos(phi) * sinTheta), (sin(phi) * sinTheta), cosTheta);
+}
+
+/**
+* Computes a ray direction for the given ray index.
+* Generate a spherically distributed normalized ray direction, then apply the given rotation transformation.
+*/
+float3 DDGIGetProbeRayDirection(int rayIndex, int numRaysPerProbe, matrix<float, 4, 4> rotationTransform)
+{
+#if RTXGI_DDGI_PROBE_RELOCATION || RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    bool useFixedRays = rayIndex < NUM_FIXED_TEST_RAYS;
+    int correctedRayIndex = useFixedRays ? rayIndex : rayIndex - NUM_FIXED_TEST_RAYS;
+    int correctedNumRays = useFixedRays ? min(NUM_FIXED_TEST_RAYS, numRaysPerProbe) : numRaysPerProbe - NUM_FIXED_TEST_RAYS;
+    float3 direction = DDGISphericalFibonacci(correctedRayIndex, correctedNumRays);
+    if (useFixedRays)
+    {
+        // we intentionally never rotate the fixed rays so that relocation/classification is temporally stable
+        return normalize(direction);
+    }
+#else
+    float3 direction = DDGISphericalFibonacci(rayIndex, numRaysPerProbe);
+#endif
+    return normalize(mul(float4(direction, 0.f), rotationTransform).xyz);
+}
+
+//------------------------------------------------------------------------
+// Probe Indexing
+//------------------------------------------------------------------------
+
+/**
+* Computes the probe index from 2D texture coordinates and probe counts.
+*/
+int DDGIGetProbeIndex(int2 texcoord, int3 probeGridCounts)
+{
+    // Compute the probe index for this thread
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return texcoord.x + (texcoord.y * (probeGridCounts.x * probeGridCounts.y));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return texcoord.x + (texcoord.y * (probeGridCounts.y * probeGridCounts.z));
+#endif
+}
+
+/**
+* Computes the probe index from 3D grid coordinates and probe counts.
+* The opposite of DDGIGetProbeCoords().
+*/
+int DDGIGetProbeIndex(int3 probeCoords, int3 probeGridCounts)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return probeCoords.x + (probeGridCounts.x * probeCoords.z) + (probeGridCounts.x * probeGridCounts.z) * probeCoords.y;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    return probeCoords.y + (probeGridCounts.y * probeCoords.x) + (probeGridCounts.y * probeGridCounts.x) * probeCoords.z;
+#endif
+}
+
+/**
+* Computes the probe index from the given thread coordinates of the irradiance and distance textures
+* the number of probes in the volume, and the number of texels per probe.
+*/
+int DDGIGetProbeIndex(uint2 threadCoords, int3 probeGridCounts, int probeNumTexels)
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = DDGIGetPlaneIndex(threadCoords, probeGridCounts, probeNumTexels);
+    int probeIndexInPlane = DDGIGetProbeIndexInPlane(threadCoords, planeIndex, probeGridCounts, probeNumTexels);
+
+    return (planeIndex * probesPerPlane) + probeIndexInPlane;
+}
+
+/**
+* Reverses the above DDGIGetProbeIndex(threadCoords, probeGridCounts, probeNumTexels)
+*/
+uint2 DDGIGetThreadBaseCoords(int probeIndex, int3 probeGridCounts, int probeNumTexels)
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = probeIndex / probesPerPlane;
+    int probeIndexInPlane = probeIndex % probesPerPlane;
+
+    // trying to get the top left texel for a given probe
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int planeWidthInProbes = probeGridCounts.x;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int planeWidthInProbes = probeGridCounts.y;
+#endif
+    int2 probeCoordInPlane = int2(probeIndexInPlane % planeWidthInProbes, probeIndexInPlane / planeWidthInProbes);
+    int baseCoordX = (planeWidthInProbes * planeIndex + probeCoordInPlane.x) * probeNumTexels;
+    int baseCoordY = probeCoordInPlane.y * probeNumTexels;
+    return uint2(baseCoordX, baseCoordY);
+}
+
+/**
+* Computes the 3D grid coordinates for the probe at the given probe index.
+* The opposite of DDGIGetProbeIndex().
+*/
+int3 DDGIGetProbeCoords(int probeIndex, int3 probeGridCounts)
+{
+    int3 probeCoords;
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    probeCoords.x = probeIndex % probeGridCounts.x;
+    probeCoords.y = probeIndex / (probeGridCounts.x * probeGridCounts.z);
+    probeCoords.z = (probeIndex / probeGridCounts.x) % probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    probeCoords.x = (probeIndex / probeGridCounts.y) % probeGridCounts.x;
+    probeCoords.y = probeIndex % probeGridCounts.y;
+    probeCoords.z = probeIndex / (probeGridCounts.x * probeGridCounts.y);
+#endif
+
+    return probeCoords;
+}
+
+/**
+* Computes the 3D grid coordinates of the base probe (i.e. floor of xyz) of the 8-probe 
+* cube that surrounds the given world space position. The other seven probes are offset 
+* by 0 or 1 in grid space along each axis.
+*/
+int3 DDGIGetBaseProbeGridCoords(float3 worldPosition, float3 origin, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    // Shift from [-n/2, n/2] to [0, n]
+    float3 position = (worldPosition - origin) + (probeGridSpacing * (probeGridCounts - 1)) * 0.5f;
+
+    int3 probeCoords = int3(position / probeGridSpacing);
+
+    // Clamp to [0, probeGridCounts - 1]
+    // Snaps positions outside of grid to the grid edge
+    probeCoords = clamp(probeCoords, int3(0, 0, 0), (probeGridCounts - int3(1, 1, 1)));
+
+    return probeCoords;
+}
+
+/**
+* Computes the world space position of a probe at the given 3D grid coordinates.
+*/
+float3 DDGIGetProbeWorldPosition(int3 probeCoords, float3 origin, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    // Multiply the grid coordinates by the grid spacing
+    float3 probeGridWorldPosition = (probeCoords * probeGridSpacing);
+
+    // Shift the grid by half of each axis extent to center the volume about its origin
+    float3 probeGridShift = (probeGridSpacing * (probeGridCounts - 1)) * 0.5f;
+
+    // Compute the probe's world position
+    return (origin + probeGridWorldPosition - probeGridShift);
+}
+
+/*
+* Computes the world space position of the probe at the given probe index (without the probe offsets).
+*/
+float3 DDGIGetProbeWorldPosition(int probeIndex, float3 origin, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    float3 probeCoords = DDGIGetProbeCoords(probeIndex, probeGridCounts);
+    return DDGIGetProbeWorldPosition(probeCoords, origin, probeGridCounts, probeGridSpacing);
+}
+
+//------------------------------------------------------------------------
+// Probe Relocation
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+
+/*
+* Reads the probe offset and transforms it into a world space offset.
+*/
+float3 DDGIDecodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+    return probeOffsets[probeOffsetTexcoord].xyz * probeGridSpacing;
+}
+float3 DDGIDecodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, Texture2D<float4> probeOffsets)
+{
+    return probeOffsets.Load(int3(probeOffsetTexcoord, 0)).xyz * probeGridSpacing;
+}
+
+/*
+* Normalizes the world space offset and writes it to the probe offset texture.
+* Probe Position Preprocess effectively limits this range to [0.f, 0.45f).
+*/
+void DDGIEncodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, float3 wsOffset, RWTexture2D<float4> probeOffsets)
+{
+    probeOffsets[probeOffsetTexcoord] = float4(wsOffset / probeGridSpacing, 0.0f);
+}
+
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int2 offsetTexcoords = int2(probeIndex % textureWidth, probeIndex / textureWidth);
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, probeGridCounts, probeGridSpacing);
+}
+// Copy paste of the above but using a Texture2D instead of a RWTexture2D
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, Texture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int2 offsetTexcoords = int2(probeIndex % textureWidth, probeIndex / textureWidth);
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, probeGridCounts, probeGridSpacing);
+}
+
+/**
+* Compute the world space position from the 3D grid coordinates, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int3 probeCoords, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+    int probeIndex = DDGIGetProbeIndex(probeCoords, probeGridCounts);
+    return DDGIGetProbeWorldPositionWithOffset(probeIndex, origin, probeGridCounts, probeGridSpacing, probeOffsets);
+}
+
+#endif /* RTXGI_DDGI_PROBE_RELOCATION */
+
+//------------------------------------------------------------------------
+// Probe State Classification
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+
+#define PROBE_STATE_ACTIVE      0   // probe shoots rays and may be sampled by a front facing surface or another probe (recursive irradiance)
+#define PROBE_STATE_INACTIVE    1   // probe doesn't need to shoot rays, it isn't near a front facing surface or another active probe
+
+#endif /* RTXGI_DDGI_PROBE_STATE_CLASSIFIER */
+
+//------------------------------------------------------------------------
+// Probe scroll movement
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_SCROLL
+
+/**
+* Gets the index of a probe that is offset from a base probe
+*/
+int DDGIGetProbeIndexOffset(int baseProbeIndex, int3 probeGridCounts, int3 probeScrollOffsets)
+{
+    int3 probeGridCoord = DDGIGetProbeCoords(baseProbeIndex, probeGridCounts);
+    int3 offsetProbeGridCoord = (probeGridCoord + probeScrollOffsets) % probeGridCounts;
+    int  offsetProbeIndex = DDGIGetProbeIndex(offsetProbeGridCoord, probeGridCounts);
+    return offsetProbeIndex;
+}
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+// modified versions of the GetProbeWorldPositionWithOffset functions that correct for probeScrollOffsets
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, RWTexture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, probeGridCounts, probeScrollOffsets);
+    int2 offsetTexcoords = int2(storageProbeIndex % textureWidth, storageProbeIndex / textureWidth);
+    // the key observation here is that the probe offset lookup needs to compensate for the scroll offset, but GetProbeWorldPosition should use the original probeIndex
+    // this requirement prevents us from just passing in a compensated probeIndex to the normalGetProbeWorldPositionWithOffset function
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, probeGridCounts, probeGridSpacing);
+}
+// Copy paste of the above but using a Texture2D instead of a RWTexture2D
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, Texture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_UNREAL
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, probeGridCounts, probeScrollOffsets);
+    int2 offsetTexcoords = int2(storageProbeIndex % textureWidth, storageProbeIndex / textureWidth);
+    // the key observation here is that the probe offset lookup needs to compensate for the scroll offset, but GetProbeWorldPosition should use the original probeIndex
+    // this requirement prevents us from just passing in a compensated probeIndex to the normalGetProbeWorldPositionWithOffset function
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, probeGridCounts, probeGridSpacing);
+}
+
+/**
+* Compute the world space position from the 3D grid coordinates, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int3 probeCoords, float3 origin, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, RWTexture2D<float4> probeOffsets)
+{
+    int probeIndex = DDGIGetProbeIndex(probeCoords, probeGridCounts);
+    return DDGIGetProbeWorldPositionWithOffset(probeIndex, origin, probeGridCounts, probeGridSpacing, probeScrollOffsets, probeOffsets);
+}
+#endif
+
+#endif /* RTXGI_DDGI_PROBE_SCROLL */
+
+#endif /* RTXGI_DDGI_PROBE_COMMON_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf
new file mode 100644
index 00000000000..406b16737b3
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf
@@ -0,0 +1,140 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeBorderUpdateCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "ProbeCommon.ush"
+
+float    ProbeDistanceScale;
+float3   DDGIVolume_probeGridSpacing;
+int3     DDGIVolume_probeGridCounts;
+int      DDGIVolume_numRaysPerProbe;
+float    DDGIVolume_probeBackfaceThreshold;
+float4x4 DDGIVolume_probeRayRotationTransform;
+float    DDGIVolume_probeMinFrontfaceDistance;
+int3     DDGIVolume_probeScrollOffsets;
+
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+RWTexture2D<float4> DDGIProbeOffsets;
+
+[numthreads(8, 4, 1)]
+void DDGIProbeRelocationCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+    // Compute the probe index for this thread
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume_probeGridCounts);
+
+    // we might have excess threads due to launching in threadgroups of 32, so early-out if necessary
+    int numTotalProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+    if (probeIndex >= numTotalProbes)
+    {
+        return;
+    }
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume_probeGridCounts, DDGIVolume_probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    uint2 offsetTexelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume_probeGridCounts);
+
+    // Get the current world position offset
+    float3 currentOffset = DDGIDecodeProbeOffset(offsetTexelPosition, DDGIVolume_probeGridSpacing, DDGIProbeOffsets);
+
+    // Initialize
+    int   closestBackfaceIndex = -1;
+    int   closestFrontfaceIndex = -1;
+    int   farthestFrontfaceIndex = -1;
+    float closestBackfaceDistance = 1e27f;
+    float closestFrontfaceDistance = 1e27f;
+    float farthestFrontfaceDistance = 0.f;
+    float backfaceCount = 0.f;
+
+    int numSphereSamples = min(DDGIVolume_numRaysPerProbe, NUM_FIXED_TEST_RAYS);
+    // Loop over the probe rays to find the number of backfaces and closest/farthest distances to them
+    for (int rayIndex = 0; rayIndex < numSphereSamples; rayIndex++)
+    {
+        int2 rayTexCoord = int2(rayIndex, probeIndex);
+
+        // Load the hit distance from the ray cast
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].a;
+#else
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].g;
+#endif
+        if (hitDistance < 0.f) 
+        {
+            backfaceCount++;
+
+            // Negate the hit distance on a backface hit and scale back to the full distance
+            hitDistance = hitDistance * -5.f;
+            if (hitDistance < closestBackfaceDistance) 
+            {
+                // Make up for the shortening of backfaces
+                closestBackfaceDistance = hitDistance;
+                closestBackfaceIndex = rayIndex;
+            }
+        }
+
+        if (hitDistance > 0.f) 
+        {
+            if (hitDistance < closestFrontfaceDistance) 
+            {
+                closestFrontfaceDistance = hitDistance;
+                closestFrontfaceIndex = rayIndex;
+            }
+            else if (hitDistance > farthestFrontfaceDistance) 
+            {
+                farthestFrontfaceDistance = hitDistance;
+                farthestFrontfaceIndex = rayIndex;
+            }
+        }
+    }
+
+    float3 fullOffset = float3(1e27f, 1e27f, 1e27f);
+
+    if (closestBackfaceIndex != -1 && (float(backfaceCount) / numSphereSamples) > DDGIVolume_probeBackfaceThreshold)
+    {
+        // If there's a close backface AND more than 25% of the hit geometry is backfaces, assume the probe is inside geometry
+        float3 closestBackfaceDirection = closestBackfaceDistance * normalize(DDGIGetProbeRayDirection(closestBackfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+        fullOffset = currentOffset + closestBackfaceDirection * (ProbeDistanceScale + 1.f);
+    }
+    else if (closestFrontfaceDistance < DDGIVolume_probeMinFrontfaceDistance) 
+    {
+        // don't move the probe if moving towards the farthest frontface will also bring us closer to the nearest frontface
+        float3 closestFrontfaceDirection = normalize(DDGIGetProbeRayDirection(closestFrontfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+        float3 farthestFrontfaceDirection = normalize(DDGIGetProbeRayDirection(farthestFrontfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+
+        if (dot(closestFrontfaceDirection, farthestFrontfaceDirection) <= 0.f)
+        {
+            // this clamp/scale factor ensures that we never move through the farthest frontface
+            farthestFrontfaceDistance *= min(farthestFrontfaceDistance, 1.f);
+            // ProbeDistanceScale decreases from 1.f - 0.f for backface movement
+            // It can go to 0 to ensure some movement away from close surfaces
+            fullOffset = currentOffset + farthestFrontfaceDirection * ProbeDistanceScale;
+        }
+    }
+    else if (closestFrontfaceDistance > DDGIVolume_probeMinFrontfaceDistance + ProbeDistanceScale)
+    {
+        // the probe is far from everything, try to move back towards zero offset
+        float moveBackMargin = min(closestFrontfaceDistance - DDGIVolume_probeMinFrontfaceDistance, length(currentOffset));
+        float3 moveBackDirection = normalize(-currentOffset);
+        fullOffset = currentOffset + (moveBackMargin * moveBackDirection);
+    }
+
+    // Absolute maximum distance probe could be moved is 0.5 * probeSpacing
+    // Clamp to less than maximum distance to avoid degenerate cases
+    if (all(abs(fullOffset) < 0.45f * DDGIVolume_probeGridSpacing)) 
+    {
+        currentOffset = fullOffset;
+    }
+
+    DDGIEncodeProbeOffset(offsetTexelPosition.xy, DDGIVolume_probeGridSpacing, currentOffset, DDGIProbeOffsets);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf
new file mode 100644
index 00000000000..df19d459791
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf
@@ -0,0 +1,90 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeStateClassifierCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "ProbeCommon.ush"
+
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+RWTexture2D<uint> DDGIProbeStates;
+
+float3   DDGIVolume_probeGridSpacing;
+int3     DDGIVolume_probeGridCounts;
+int      DDGIVolume_numRaysPerProbe;
+float    DDGIVolume_probeBackfaceThreshold;
+int3     DDGIVolume_probeScrollOffsets;
+
+[numthreads(8, 4, 1)]
+void DDGIProbeStateClassifierCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+    float closestFrontfaceDistance = 1e27f;
+    int   backfaceCount = 0;
+
+    // Compute the probe index for this thread
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume_probeGridCounts);
+    // we might have excess threads due to launching in threadgroups of 32, so early-out if necessary
+    int numTotalProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+    if (probeIndex >= numTotalProbes)
+    {
+        return;
+    }
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume_probeGridCounts, DDGIVolume_probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    uint2 offsetTexelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume_probeGridCounts);
+
+    // Compute the bounds used to check for surrounding geometry
+    float3 geometryBounds = DDGIVolume_probeGridSpacing;
+
+    // Conservatively increase the geometry search area
+    geometryBounds *= 2.f;
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+    // A conservative bound that assumes the maximum offset value for this probe
+    geometryBounds *= 1.45f;
+#endif
+
+    int numSphereSamples = min(DDGIVolume_numRaysPerProbe, NUM_FIXED_TEST_RAYS);
+    // Iterate over the rays cast for this probe
+    for (int rayIndex = 0; rayIndex < numSphereSamples; rayIndex++)
+    {
+        int2 rayTexCoord = int2(rayIndex, probeIndex);
+
+        // Load the hit distance from the ray cast
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].a;
+#else
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].g;
+#endif
+
+        // Don't include backface hit distances
+        if (hitDistance < 0.f) 
+        {
+            backfaceCount++;
+            continue;
+        }
+
+        // Store the closest front face hit distance
+        closestFrontfaceDistance = min(closestFrontfaceDistance, hitDistance);      
+    }
+
+    // If this probe is near geometry, wake it up unless backface percentage is above probeBackfaceThreshold
+    if (all(closestFrontfaceDistance <= geometryBounds) && (float(backfaceCount) / numSphereSamples < DDGIVolume_probeBackfaceThreshold))
+    {
+        DDGIProbeStates[offsetTexelPosition] = PROBE_STATE_ACTIVE;
+        return;
+    }
+
+    DDGIProbeStates[offsetTexelPosition] = PROBE_STATE_INACTIVE;
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush
new file mode 100644
index 00000000000..2c9c6ee921d
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush
@@ -0,0 +1,30 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DEFINES_H
+#define RTXGI_DEFINES_H
+
+#ifndef RTXGI_NAME_D3D_OBJECTS
+#define RTXGI_NAME_D3D_OBJECTS 1
+#endif 
+
+#ifndef RTXGI_PERF_MARKERS
+#define RTXGI_PERF_MARKERS 1
+#endif
+
+#define RTXGI_COORDINATE_SYSTEM_LEFT 0
+#define RTXGI_COORDINATE_SYSTEM_RIGHT 1
+#define RTXGI_COORDINATE_SYSTEM_UNREAL 2
+
+#ifndef RTXGI_COORDINATE_SYSTEM
+#define RTXGI_COORDINATE_SYSTEM RTXGI_COORDINATE_SYSTEM_UNREAL
+#endif
+
+#endif /* RTXGI_DEFINES_H */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf
new file mode 100644
index 00000000000..c72021293a1
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf
@@ -0,0 +1,137 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Public/Platform.ush"
+
+#include "/Plugin/RTXGI/Private/SDK/ddgi/ProbeCommon.ush"
+
+Texture2D<float4> ProbeIrradianceTexture;
+Texture2D<float4> ProbeDistanceTexture;
+Texture2D<float4> ProbeOffsets;
+RWTexture2D<uint> ProbeStates;
+SamplerState ProbeSampler;
+
+int Mode;
+float ProbeRadius;
+float DepthScale;
+int VolumeProbeNumIrradianceTexels;
+int VolumeProbeNumDistanceTexels;
+float VolumeProbeIrradianceEncodingGamma;
+float3 VolumePosition;
+float3 VolumeProbeGridSpacing;
+int3   VolumeProbeGridCounts;
+float4x4 WorldToClip;
+float3 CameraPosition;
+float PreExposure;
+uint ShouldUsePreExposure;
+int3 VolumeProbeScrollOffsets;
+
+struct FVisualizeDDGIProbesVSToPS
+{
+	nointerpolation float3 ProbeOrigin : TEXCOORD0;
+	nointerpolation uint InstanceId : TEXCOORD1;
+	float4 WorldPosition : TEXCOORD2;
+};
+
+void VisualizeDDGIProbesVS(
+	in float4 InPosition : ATTRIBUTE0,
+	uint InstanceId : SV_InstanceID,
+	out FVisualizeDDGIProbesVSToPS Output,
+	out float4 OutPosition : SV_POSITION
+)
+{
+#if RTXGI_DDGI_PROBE_RELOCATION
+	#if RTXGI_DDGI_PROBE_SCROLL
+		float3 Translation = DDGIGetProbeWorldPositionWithOffset(InstanceId, VolumePosition, VolumeProbeGridCounts, VolumeProbeGridSpacing, VolumeProbeScrollOffsets, ProbeOffsets);
+	#else
+		float3 Translation = DDGIGetProbeWorldPositionWithOffset(InstanceId, VolumePosition, VolumeProbeGridCounts, VolumeProbeGridSpacing, ProbeOffsets);
+	#endif
+#else
+	float3 Translation = DDGIGetProbeWorldPosition(InstanceId, VolumePosition, VolumeProbeGridCounts, VolumeProbeGridSpacing);
+#endif
+
+	matrix<float, 4, 4> Transform = {	ProbeRadius, 0.f, 0.f, 0.f,
+									0.f, ProbeRadius, 0.f, 0.f,
+									0.f, 0.f, ProbeRadius, 0.f,
+									Translation.x, Translation.y, Translation.z, 1.f};
+	
+	Output.ProbeOrigin = Translation;
+	Output.InstanceId = InstanceId;
+	Output.WorldPosition = float4(InPosition.xyz, 1.f);
+	Output.WorldPosition = mul(Output.WorldPosition, Transform);
+
+	OutPosition = mul(Output.WorldPosition, WorldToClip);
+}
+
+void VisualizeDDGIProbesPS(
+	in FVisualizeDDGIProbesVSToPS Input,
+	out float4 OutColor : SV_Target0)
+{
+	// Compute UVs based on ProbeID and direction of the fragment on the sphere
+	float3 WorldPos = Input.WorldPosition.xyz;
+	float3 Direction = normalize(Input.WorldPosition.xyz - Input.ProbeOrigin);
+	float2 OctantCoordinates = DDGIGetOctahedralCoordinates(Direction);
+
+	float3 Output = float3(0.0f, 0.0f, 0.0f);
+
+	#if RTXGI_DDGI_PROBE_SCROLL
+		float2 ProbeUVDistance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumDistanceTexels, VolumeProbeScrollOffsets);
+		float2 ProbeUVIrradiance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumIrradianceTexels, VolumeProbeScrollOffsets);
+	#else
+		float2 ProbeUVDistance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumDistanceTexels);
+		float2 ProbeUVIrradiance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumIrradianceTexels);
+	#endif
+
+	if (Mode == 1)
+	{
+		Output = ProbeIrradianceTexture.SampleLevel(ProbeSampler, ProbeUVIrradiance, 0).rgb;
+		Output = pow(Output.rgb, VolumeProbeIrradianceEncodingGamma);
+		Output *= (0.5f * RTXGI_PI);            // Factored out of the probes
+		Output /= RTXGI_PI;
+	}
+	else if(Mode == 2)
+	{
+		float Distance = ProbeDistanceTexture.SampleLevel(ProbeSampler, ProbeUVDistance, 0).r;
+		Output = float3(Distance / DepthScale, Distance / DepthScale, Distance / DepthScale);
+	}
+	else if(Mode == 3)
+	{
+		float Distance = ProbeDistanceTexture.SampleLevel(ProbeSampler, ProbeUVDistance, 0).g;
+		Output = float3(Distance / DepthScale, Distance / DepthScale, Distance / DepthScale);
+	}
+	else
+	{
+		discard;
+	}
+
+	Output *= ShouldUsePreExposure ? PreExposure : 1.0f;
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+	{
+		#if RTXGI_DDGI_PROBE_SCROLL
+			int probeIndex = DDGIGetProbeIndexOffset(Input.InstanceId, VolumeProbeGridCounts, VolumeProbeScrollOffsets);
+		#else
+			int probeIndex = Input.InstanceId;
+		#endif
+
+		int2 texelPosition = DDGIGetProbeTexelPosition(probeIndex, VolumeProbeGridCounts);
+		int  probeState = ProbeStates[texelPosition];
+		if(probeState == PROBE_STATE_INACTIVE)
+		{
+			float3 SurfaceToCamera = normalize(CameraPosition - Input.WorldPosition);
+			if (dot(SurfaceToCamera, Direction) < 0.5f)
+				Output = float3(1.0f, 0.0f, 0.0f);
+		}
+	}
+#endif
+
+	OutColor = float4(Output, 1.f);
+}
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIBlueprintLibrary.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIBlueprintLibrary.cpp
new file mode 100644
index 00000000000..e65f6661585
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIBlueprintLibrary.cpp
@@ -0,0 +1,31 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIBlueprintLibrary.h"
+#include "DDGIVolumeComponent.h"
+#include "RenderingThread.h"
+
+UDDGIBlueprintLibrary::UDDGIBlueprintLibrary(const FObjectInitializer& ObjectInitializer)
+	: Super(ObjectInitializer)
+{ }
+
+void UDDGIBlueprintLibrary::ClearProbeData(
+	const UDDGIVolumeComponent* DDGIVolumeComponent
+)
+{
+	FDDGIVolumeSceneProxy* DDGIProxy = DDGIVolumeComponent->SceneProxy;
+
+	ENQUEUE_RENDER_COMMAND(DDGIClearProbeData)(
+		[DDGIProxy, DDGIVolumeComponent](FRHICommandListImmediate& RHICmdList)
+		{
+			DDGIVolumeComponent->SceneProxy->ResetTextures_RenderThread(RHICmdList);
+		}
+	);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolume.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolume.cpp
new file mode 100644
index 00000000000..d64c3818810
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolume.cpp
@@ -0,0 +1,71 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolume.h"
+#include "DDGIVolumeComponent.h"
+#include "Components/BoxComponent.h"
+#include "Components/BillboardComponent.h"
+#include "Engine/CollisionProfile.h"
+#include "UObject/ConstructorHelpers.h"
+
+ADDGIVolume::ADDGIVolume(const FObjectInitializer& ObjectInitializer)
+	: Super(ObjectInitializer)
+{
+	DDGIVolumeComponent = CreateDefaultSubobject<UDDGIVolumeComponent>(TEXT("DDGI"));
+	DDGIVolumeComponent->bHiddenInGame = false;
+	RootComponent = DDGIVolumeComponent;
+
+	BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT("Volume"));
+	BoxComponent->SetBoxExtent(FVector{ 100.0f, 100.0f, 100.0f });
+	BoxComponent->SetupAttachment(RootComponent);
+
+#if WITH_EDITORONLY_DATA
+	SpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT("Sprite"));
+	if (!IsRunningCommandlet() && (SpriteComponent != nullptr))
+	{
+		static ConstructorHelpers::FObjectFinderOptional<UTexture2D> DecalTexture(TEXT("/Engine/EditorResources/EmptyActor"));
+
+		SpriteComponent->Sprite = DecalTexture.Get();
+		SpriteComponent->SetRelativeScale3D_Direct(FVector(0.5f, 0.5f, 0.5f));
+		SpriteComponent->bHiddenInGame = true;
+		SpriteComponent->SetUsingAbsoluteScale(true);
+		SpriteComponent->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);
+		SpriteComponent->bIsScreenSizeScaled = true;
+
+		SpriteComponent->SetupAttachment(RootComponent);
+	}
+#endif // WITH_EDITORONLY_DATA
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	PrimaryActorTick.bCanEverTick = true;
+	PrimaryActorTick.bStartWithTickEnabled = true;
+#endif
+}
+
+#if WITH_EDITOR
+void ADDGIVolume::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
+{
+	// only allow axis aligned volumes
+	Super::PostEditChangeProperty(PropertyChangedEvent);
+	SetActorRotation(FQuat::Identity);
+	DDGIVolumeComponent->UpdateRenderThreadData();
+}
+
+void ADDGIVolume::PostEditMove(bool bFinished)
+{
+	// only allow axis aligned volumes
+	Super::PostEditMove(bFinished);
+	//if (bFinished)
+	{
+		SetActorRotation(FQuat::Identity);
+		DDGIVolumeComponent->UpdateRenderThreadData();
+	}
+}
+#endif
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeComponent.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeComponent.cpp
new file mode 100644
index 00000000000..985f31c5783
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeComponent.cpp
@@ -0,0 +1,872 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeComponent.h"
+#include "DDGIVolume.h"
+#include "DDGIVolumeUpdate.h"
+#include "RenderGraphBuilder.h"
+#include "ShaderParameterStruct.h"
+#include "ShaderParameterUtils.h"
+#include "SystemTextures.h"
+#include "RTXGIPluginSettings.h"
+
+// UE4 private interfaces
+#include "PostProcess/SceneRenderTargets.h"
+#include "SceneRendering.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+DECLARE_GPU_STAT_NAMED(RTXGI, TEXT("RTXGI"));
+
+static TAutoConsoleVariable<bool> CVarUseDDGI(
+	TEXT("r.RTXGI.DDGI"),
+	true,
+	TEXT("If false, this will disable the lighting contribution and functionality of DDGI volumes.\n"),
+	ECVF_RenderThreadSafe | ECVF_Cheat);
+
+BEGIN_SHADER_PARAMETER_STRUCT(FVolumeData, )
+	SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradiance)
+	SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistance)
+	SHADER_PARAMETER_UAV(RWTexture2D<float4>, ProbeOffsets)
+	SHADER_PARAMETER(FVector, Position)
+	SHADER_PARAMETER(FVector, Radius)
+	SHADER_PARAMETER(FVector, ProbeGridSpacing)
+	SHADER_PARAMETER(FIntVector, ProbeGridCounts)
+	SHADER_PARAMETER(FIntVector, ProbeScrollOffsets)
+	SHADER_PARAMETER(uint32, LightingChannelMask)
+	SHADER_PARAMETER(int, ProbeNumIrradianceTexels)
+	SHADER_PARAMETER(int, ProbeNumDistanceTexels)
+	SHADER_PARAMETER(float, ProbeIrradianceEncodingGamma)
+	SHADER_PARAMETER(float, NormalBias)
+	SHADER_PARAMETER(float, ViewBias)
+	SHADER_PARAMETER(float, BlendDistance)
+	SHADER_PARAMETER(float, ApplyLighting)
+END_SHADER_PARAMETER_STRUCT()
+
+BEGIN_SHADER_PARAMETER_STRUCT(FApplyLightingDeferredShaderParameters, )
+	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Normals)
+	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Depth)
+	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, BaseColor)
+	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Metallic)
+	SHADER_PARAMETER_RDG_TEXTURE(Texture2D, LightingChannelsTexture)
+	SHADER_PARAMETER(FMatrix, ScreenToTranslatedWorld)
+	SHADER_PARAMETER(FVector, WorldCameraOrigin)
+	SHADER_PARAMETER(float, PreExposure)
+	SHADER_PARAMETER(FVector4, InvDeviceZToWorldZTransform)
+	SHADER_PARAMETER(int32, ShouldUsePreExposure)
+	SHADER_PARAMETER(int32, NumVolumes)
+	// Volumes are sorted from densest probes to least dense probes
+	SHADER_PARAMETER_STRUCT_ARRAY(FVolumeData, DDGIVolume, [FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES])
+	SHADER_PARAMETER_SAMPLER(SamplerState, LinearClampSampler)
+	RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+class FApplyLightingDeferredShaderVS : public FGlobalShader
+{
+public:
+	DECLARE_GLOBAL_SHADER(FApplyLightingDeferredShaderVS);
+	SHADER_USE_PARAMETER_STRUCT(FApplyLightingDeferredShaderVS, FGlobalShader);
+	
+	using FParameters = FApplyLightingDeferredShaderParameters;
+
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+		
+		FString volumeMacroList;
+		for (int i = 0; i < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++i)
+			volumeMacroList += FString::Printf(TEXT(" VOLUME_ENTRY(%i)"), i);
+		OutEnvironment.SetDefine(TEXT("VOLUME_LIST"), volumeMacroList.GetCharArray().GetData());
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+	}
+};
+
+class FApplyLightingDeferredShaderPS : public FGlobalShader
+{
+public:
+	DECLARE_GLOBAL_SHADER(FApplyLightingDeferredShaderPS);
+	SHADER_USE_PARAMETER_STRUCT(FApplyLightingDeferredShaderPS, FGlobalShader);
+
+	using FParameters = FApplyLightingDeferredShaderParameters;
+
+	class FLightingChannelsDim : SHADER_PERMUTATION_BOOL("USE_LIGHTING_CHANNELS");
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FLightingChannelsDim, FEnableRelocation, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		FString volumeMacroList;
+		for (int i = 0; i < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++i)
+			volumeMacroList += FString::Printf(TEXT(" VOLUME_ENTRY(%i)"), i);
+		OutEnvironment.SetDefine(TEXT("VOLUME_LIST"), volumeMacroList.GetCharArray().GetData());
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+	}
+};
+
+IMPLEMENT_GLOBAL_SHADER(FApplyLightingDeferredShaderVS, "/Plugin/RTXGI/Private/ApplyLightingDeferred.usf", "MainVS", SF_Vertex);
+IMPLEMENT_GLOBAL_SHADER(FApplyLightingDeferredShaderPS, "/Plugin/RTXGI/Private/ApplyLightingDeferred.usf", "MainPS", SF_Pixel);
+
+TSet<FDDGIVolumeSceneProxy*> FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread;
+TMap<const FSceneInterface*, float> FDDGIVolumeSceneProxy::SceneRoundRobinValue;
+FDelegateHandle FDDGIVolumeSceneProxy::OnRenderVisualizationDelegateHandle;
+FDelegateHandle FDDGIVolumeSceneProxy::OnRenderDiffuseLightingDelegateHandle;
+FTexture2DRHIRef FDDGIVolumeSceneProxy::DummyTex = nullptr;
+FUnorderedAccessViewRHIRef FDDGIVolumeSceneProxy::DummyUAV = nullptr;
+
+void FDDGIVolumeSceneProxy::OnIrradianceBitsChange()
+{
+	bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+
+	// tell all the proxies about the change
+	ENQUEUE_RENDER_COMMAND(DDGIOnIrradianceBitsChange)(
+		[highBitCount](FRHICommandListImmediate& RHICmdList)
+		{
+			for (FDDGIVolumeSceneProxy* DDGIProxy : AllProxiesReadyForRender_RenderThread)
+			{
+				DDGIProxy->ReallocateSurfaces_RenderThread(RHICmdList, highBitCount);
+				DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+			}
+		}
+	);
+}
+
+void FDDGIVolumeSceneProxy::ReallocateSurfaces_RenderThread(FRHICommandListImmediate& RHICmdList, bool highBitCount)
+{
+	FIntPoint ProxyDims = ComponentData.Get2DProbeCount();
+
+	// Irradiance
+	{
+		int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+		FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+		FRHIResourceCreateInfo createInfo(TEXT("DDGIIrradiance"));
+		ProbesIrradianceTex = RHICreateTexture2D(ProxyTexDims.X, ProxyTexDims.Y, highBitCount ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceLowBitDepth, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+		ProbesIrradianceUAV = RHICreateUnorderedAccessView(ProbesIrradianceTex, 0);
+	}
+
+	// Distance
+	{
+		int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+		FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+		FRHIResourceCreateInfo createInfo(TEXT("DDGIDistance"));
+		ProbesDistanceTex = RHICreateTexture2D(ProxyTexDims.X, ProxyTexDims.Y, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistance, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+		ProbesDistanceUAV = RHICreateUnorderedAccessView(ProbesDistanceTex, 0);
+	}
+
+	// Offsets - only pay the cost of this resource if this volume is actually doing relocation
+	if (ComponentData.EnableProbeRelocation)
+	{
+		FRHIResourceCreateInfo createInfo(TEXT("DDGIOffsets"));
+		ProbesOffsetsTex = RHICreateTexture2D(ProxyDims.X, ProxyDims.Y, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatOffsets, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+		ProbesOffsetsUAV = RHICreateUnorderedAccessView(ProbesOffsetsTex, 0);
+	}
+	else
+	{
+		ProbesOffsetsTex = nullptr;
+		ProbesOffsetsUAV = nullptr;
+	}
+
+	// probe classifications
+	if (FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER)
+	{
+		FRHIResourceCreateInfo createInfo(TEXT("DDGIStates"));
+		ProbesStatesTex = RHICreateTexture2D(ProxyDims.X, ProxyDims.Y, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatStates, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+		ProbesStatesUAV = RHICreateUnorderedAccessView(ProbesStatesTex, 0);
+	}
+	else
+	{
+		ProbesStatesTex = nullptr;
+		ProbesStatesUAV = nullptr;
+	}
+}
+
+void FDDGIVolumeSceneProxy::ResetTextures_RenderThread(FRHICommandListImmediate& RHICmdList)
+{
+	// reset textures to pristine initial state
+	RHICmdList.ClearUAVFloat(ProbesIrradianceUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+	RHICmdList.ClearUAVFloat(ProbesDistanceUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+
+	if (ProbesOffsetsUAV)
+		RHICmdList.ClearUAVFloat(ProbesOffsetsUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+	
+	if (ProbesStatesUAV)
+		RHICmdList.ClearUAVUint(ProbesStatesUAV, FUintVector4{ 0, 0, 0, 0 });
+}
+
+void FDDGIVolumeSceneProxy::RenderDiffuseLighting_RenderThread(
+	const FScene& Scene,
+	const FViewInfo& View,
+	FRDGBuilder& GraphBuilder,
+	FSceneRenderTargets& SceneContext)
+{
+	// no DDGI if it's disabled
+	if (!CVarUseDDGI.GetValueOnRenderThread())
+		return;
+
+	RDG_GPU_STAT_SCOPE(GraphBuilder, RTXGI);
+	RDG_EVENT_SCOPE(GraphBuilder, "RTXGI");
+
+	// Let DDGIVolumeUpdate update all/any volumes as it sees fit
+	DDGIVolumeUpdate::DDGIUpdatePerFrame_RenderThread(Scene, View, GraphBuilder);
+
+	// Get the volumes, sorted from densest to least dense
+	struct FProxyEntry
+	{
+		FVector Position;
+		FVector Scale;
+		float Density;
+		uint32 lightingChannelMask;
+		const FDDGIVolumeSceneProxy* proxy;
+	};
+	TArray<FProxyEntry> proxyEntries;
+	{
+		for (FDDGIVolumeSceneProxy* proxy : AllProxiesReadyForRender_RenderThread)
+		{
+			if (proxy->OwningScene != &Scene)
+				continue;
+
+			FVector ProxyPosition = proxy->ComponentData.Transform.GetLocation();
+			FVector ProxyScale = proxy->ComponentData.Transform.GetScale3D();
+
+			// frustum culling
+			FVector ProxyExtent = ProxyScale * 100.0f;
+			if (!View.ViewFrustum.IntersectBox(ProxyPosition, ProxyExtent))
+				continue;
+
+			float ProxyDensity = float(proxy->ComponentData.ProbeCounts.X * proxy->ComponentData.ProbeCounts.Y * proxy->ComponentData.ProbeCounts.Z) / (ProxyScale.X * ProxyScale.Y * ProxyScale.Z);
+			uint32 ProxyLightingChannelMask =
+				(proxy->ComponentData.LightingChannels.bChannel0 ? 1 : 0) |
+				(proxy->ComponentData.LightingChannels.bChannel1 ? 2 : 0) |
+				(proxy->ComponentData.LightingChannels.bChannel2 ? 4 : 0);
+			proxyEntries.Add(FProxyEntry{ ProxyPosition, ProxyScale, ProxyDensity, ProxyLightingChannelMask, proxy });
+
+			if (proxyEntries.Num() == FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES)
+				break;
+		}
+
+		Algo::Sort(proxyEntries, [](const FProxyEntry& A, const FProxyEntry& B)
+			{
+				return A.Density > B.Density;
+			}
+		);
+	}
+
+	// only do this pass if we have proxy entries that can contribute light to pixels
+	if (proxyEntries.Num() == 0)
+		return;
+
+	// get the textures we'll need
+	FRDGTextureRef GBufferATexture = GraphBuilder.RegisterExternalTexture(SceneContext.GBufferA);
+	FRDGTextureRef GBufferBTexture = GraphBuilder.RegisterExternalTexture(SceneContext.GBufferB);
+	FRDGTextureRef GBufferCTexture = GraphBuilder.RegisterExternalTexture(SceneContext.GBufferC);
+	FRDGTextureRef SceneDepthTexture = GraphBuilder.RegisterExternalTexture(SceneContext.SceneDepthZ);
+	FRDGTextureRef LightingChannelsTexture = (View.bUsesLightingChannels && SceneContext.LightingChannels) ? GraphBuilder.RegisterExternalTexture(SceneContext.LightingChannels) : nullptr;
+	FRDGTextureRef SceneColorTexture = GraphBuilder.RegisterExternalTexture(SceneContext.GetSceneColor());
+
+	// calculate some things we'll need
+	FMatrix ScreenToTranslatedWorld = FMatrix(
+		FPlane(1, 0, 0, 0),
+		FPlane(0, 1, 0, 0),
+		FPlane(0, 0, View.ProjectionMatrixUnadjustedForRHI.M[2][2], 1),
+		FPlane(0, 0, View.ProjectionMatrixUnadjustedForRHI.M[3][2], 0))
+		* View.ViewMatrices.GetInvTranslatedViewProjectionMatrix();
+
+	for (int permutationIndex = 0; permutationIndex < 4; ++permutationIndex)
+	{
+		bool enableRelocation = (permutationIndex & 1) != 0;
+		bool enableScrolling = (permutationIndex & 2) != 0;
+
+		// only render this permutation if there is at least one volume that matches these settings
+		bool foundAMatch = false;
+		for (int32 i = 0; i < proxyEntries.Num(); ++i)
+		{
+			foundAMatch = true;
+			foundAMatch = foundAMatch && (enableRelocation == proxyEntries[i].proxy->ComponentData.EnableProbeRelocation);
+			foundAMatch = foundAMatch && (enableScrolling == proxyEntries[i].proxy->ComponentData.EnableProbeScrolling);
+			if (foundAMatch)
+				break;
+		}
+		if (!foundAMatch)
+			continue;
+
+		// get permuted vertex shader
+		FGlobalShaderMap* GlobalShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		FApplyLightingDeferredShaderVS::FPermutationDomain PermutationVectorVS;
+		PermutationVectorVS.Set<FApplyLightingDeferredShaderVS::FEnableRelocation>(enableRelocation);
+		PermutationVectorVS.Set<FApplyLightingDeferredShaderVS::FEnableScrolling>(enableScrolling);
+		TShaderMapRef<FApplyLightingDeferredShaderVS> VertexShader(GlobalShaderMap, PermutationVectorVS);
+
+		// get permuted pixel shader
+		FApplyLightingDeferredShaderPS::FPermutationDomain PermutationVectorPS;
+		PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FLightingChannelsDim>(LightingChannelsTexture != nullptr);
+		PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FEnableRelocation>(enableRelocation);
+		PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FEnableScrolling>(enableScrolling);
+		TShaderMapRef<FApplyLightingDeferredShaderPS> PixelShader(GlobalShaderMap, PermutationVectorPS);
+
+		// set parameters
+		FApplyLightingDeferredShaderParameters DefaultPassParameters;
+		FApplyLightingDeferredShaderParameters* PassParameters = GraphBuilder.AllocParameters<FApplyLightingDeferredShaderParameters>();
+		*PassParameters = DefaultPassParameters;
+		PassParameters->Normals = GBufferATexture;
+		PassParameters->Depth = SceneDepthTexture;
+		PassParameters->BaseColor = GBufferCTexture;
+		PassParameters->Metallic = GBufferBTexture;
+		PassParameters->LightingChannelsTexture = LightingChannelsTexture;
+		PassParameters->ScreenToTranslatedWorld = ScreenToTranslatedWorld;
+		PassParameters->WorldCameraOrigin = View.ViewMatrices.GetViewOrigin();
+		PassParameters->InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
+		PassParameters->RenderTargets[0] = FRenderTargetBinding(SceneColorTexture, ERenderTargetLoadAction::ELoad);
+
+		PassParameters->LinearClampSampler = TStaticSamplerState<SF_Trilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+
+		PassParameters->ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+		PassParameters->NumVolumes = proxyEntries.Num();
+		PassParameters->PreExposure = View.PreExposure;
+
+		for (int32 i = 0; i < proxyEntries.Num(); ++i)
+		{
+			PassParameters->DDGIVolume[i].ProbeIrradiance = proxyEntries[i].proxy->ProbesIrradianceTex;
+			PassParameters->DDGIVolume[i].ProbeDistance = proxyEntries[i].proxy->ProbesDistanceTex;
+			PassParameters->DDGIVolume[i].ProbeOffsets = proxyEntries[i].proxy->ProbesOffsetsUAV ? proxyEntries[i].proxy->ProbesOffsetsUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+
+			PassParameters->DDGIVolume[i].Position = proxyEntries[i].Position;
+			PassParameters->DDGIVolume[i].Radius = proxyEntries[i].Scale * 100.0f;
+			PassParameters->DDGIVolume[i].LightingChannelMask = proxyEntries[i].lightingChannelMask;
+
+			FVector volumeSize = proxyEntries[i].proxy->ComponentData.Transform.GetScale3D() * 200.0f;
+			FVector probeGridSpacing;
+			probeGridSpacing.X = volumeSize.X / float(proxyEntries[i].proxy->ComponentData.ProbeCounts.X);
+			probeGridSpacing.Y = volumeSize.Y / float(proxyEntries[i].proxy->ComponentData.ProbeCounts.Y);
+			probeGridSpacing.Z = volumeSize.Z / float(proxyEntries[i].proxy->ComponentData.ProbeCounts.Z);
+			PassParameters->DDGIVolume[i].ProbeGridSpacing = probeGridSpacing;
+
+			PassParameters->DDGIVolume[i].ProbeGridCounts = proxyEntries[i].proxy->ComponentData.ProbeCounts;
+			PassParameters->DDGIVolume[i].ProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+			PassParameters->DDGIVolume[i].ProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+			PassParameters->DDGIVolume[i].ProbeIrradianceEncodingGamma = proxyEntries[i].proxy->ComponentData.ProbeIrradianceEncodingGamma;
+			PassParameters->DDGIVolume[i].NormalBias = proxyEntries[i].proxy->ComponentData.NormalBias;
+			PassParameters->DDGIVolume[i].ViewBias = proxyEntries[i].proxy->ComponentData.ViewBias;
+			PassParameters->DDGIVolume[i].BlendDistance = proxyEntries[i].proxy->ComponentData.BlendDistance;
+			PassParameters->DDGIVolume[i].ProbeScrollOffsets = proxyEntries[i].proxy->ComponentData.ProbeScrollOffsets;
+
+			// Only apply lighting if this is the pass we should apply in.
+			// The shader needs to know about all of the volumes though for blending purposes.
+			bool applyLighting = true;
+			applyLighting = applyLighting && (enableRelocation == proxyEntries[i].proxy->ComponentData.EnableProbeRelocation);
+			applyLighting = applyLighting && (enableScrolling == proxyEntries[i].proxy->ComponentData.EnableProbeScrolling);
+			PassParameters->DDGIVolume[i].ApplyLighting = applyLighting;
+		}
+
+		// fill out the rest of the textures.
+		for (int32 i = proxyEntries.Num(); i < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++i)
+		{
+			PassParameters->DDGIVolume[i].ProbeIrradiance = GSystemTextures.BlackDummy->GetRenderTargetItem().TargetableTexture;
+			PassParameters->DDGIVolume[i].ProbeDistance = GSystemTextures.BlackDummy->GetRenderTargetItem().TargetableTexture;
+			PassParameters->DDGIVolume[i].ProbeOffsets = FDDGIVolumeSceneProxy::GetDummyUAV();
+		}
+
+		// call the shader
+		FIntRect ViewRect = View.ViewRect;
+		GraphBuilder.AddPass(
+			Forward<FRDGEventName>(RDG_EVENT_NAME("DDGI Apply Lighting")),
+			PassParameters,
+			ERDGPassFlags::Raster,
+			[PassParameters, GlobalShaderMap, VertexShader, PixelShader, ViewRect](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.SetViewport(ViewRect.Min.X, ViewRect.Min.Y, 0.0f, ViewRect.Max.X, ViewRect.Max.Y, 1.0f);
+
+				FGraphicsPipelineStateInitializer GraphicsPSOInit;
+
+				RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);
+				GraphicsPSOInit.BlendState = TStaticBlendState<CW_RGB, BO_Add, BF_One, BF_One, BO_Add, BF_One, BF_One>::GetRHI();
+				GraphicsPSOInit.RasterizerState = TStaticRasterizerState<>::GetRHI();
+				GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState<false, CF_Always>::GetRHI();
+
+				GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();
+				GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.GetVertexShader();
+				GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.GetPixelShader();
+				GraphicsPSOInit.PrimitiveType = PT_TriangleList;
+
+				SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);
+				RHICmdList.SetStencilRef(0);
+
+				SetShaderParameters(RHICmdList, VertexShader, VertexShader.GetVertexShader(), *PassParameters);
+				SetShaderParameters(RHICmdList, PixelShader, PixelShader.GetPixelShader(), *PassParameters);
+
+				RHICmdList.DrawPrimitive(0, 1, 1);
+			}
+		);
+	}
+}
+
+UDDGIVolumeComponent::UDDGIVolumeComponent(const FObjectInitializer& ObjectInitializer)
+	: Super(ObjectInitializer)
+{
+	bWantsInitializeComponent = true;
+}
+
+void UDDGIVolumeComponent::InitializeComponent()
+{
+	Super::InitializeComponent();
+
+	UpdateRenderThreadData();
+
+	TransformUpdated.AddLambda(
+		[this](USceneComponent* /*UpdatedComponent*/, EUpdateTransformFlags /*UpdateTransformFlags*/, ETeleportType /*Teleport*/)
+		{
+			UpdateRenderThreadData();
+		}
+	);
+}
+
+// Custom serialization version for assets/classes in the AnimGraphRuntime and AnimGraph modules
+struct RTXGI_API FDDGICustomVersion
+{
+	enum Type
+	{
+		AddingCustomVersion = 1,
+		SaveLoadProbeTextures,     // save pixels and w/h
+		SaveLoadProbeTexturesFmt,  // now also saving format since the desired format can change depending on project settings.
+	};
+
+	// The GUID for this custom version number
+	const static FGuid GUID;
+
+private:
+	FDDGICustomVersion() {}
+};
+const FGuid FDDGICustomVersion::GUID(0xc12f0537, 0x7346d9c5, 0x336fbba3, 0x738ab145);
+
+// Register the custom version with core
+FCustomVersionRegistration GRegisterCustomVersion(FDDGICustomVersion::GUID, FDDGICustomVersion::SaveLoadProbeTexturesFmt, TEXT("DDGIVolCompVer"));
+
+// step 1: copy the texture to one we can read CPU side
+static FDDGITexturePixels GetTexturePixelsStep1_RenderThread(FRHICommandListImmediate& RHICmdList, FTexture2DRHIRef textureGPU)
+{
+	FDDGITexturePixels ret;
+
+	if (!textureGPU)
+		return ret;
+
+	ret.w = textureGPU->GetSizeX();
+	ret.h = textureGPU->GetSizeY();
+
+	FRHIResourceCreateInfo createInfo(TEXT("DDGIGetTexturePixelsSave"));
+	ret.textureCPU = RHICreateTexture2D(textureGPU->GetSizeX(), textureGPU->GetSizeY(), textureGPU->GetFormat(), 1, 1, TexCreate_ShaderResource | TexCreate_Transient, createInfo);
+	RHICmdList.CopyTexture(textureGPU, ret.textureCPU, FRHICopyTextureInfo{});
+	return ret;
+}
+
+// step 2: read the texture data into cpu memory
+static void GetTexturePixelsStep2_RenderThread(FRHICommandListImmediate& RHICmdList, FDDGITexturePixels& texturePixels)
+{
+	if (!texturePixels.textureCPU)
+		return;
+
+	uint8* mappedTextureMemory = (uint8*)RHILockTexture2D(texturePixels.textureCPU, 0, RLM_ReadOnly, texturePixels.stride, false);
+
+	texturePixels.pixels.AddZeroed(texturePixels.h * texturePixels.stride);
+	FMemory::Memcpy(&texturePixels.pixels[0], mappedTextureMemory, texturePixels.h * texturePixels.stride);
+
+	RHIUnlockTexture2D(texturePixels.textureCPU, 0, false);
+}
+
+static void SaveFDDGITexturePixels(FArchive& Ar, FDDGITexturePixels& texturePixels, FTexture2DRHIRef textureGPU, bool saveFormat)
+{
+	check(Ar.IsSaving());
+
+	Ar << texturePixels.w;
+	Ar << texturePixels.h;
+	Ar << texturePixels.stride;
+	Ar << texturePixels.pixels;
+
+	if (saveFormat)
+	{
+		uint32 format = 0;
+
+		if (textureGPU)
+			format = (int32)textureGPU->GetFormat();
+
+		Ar << format;
+	}
+}
+
+static void LoadFDDGITexturePixels(FArchive& Ar, FDDGITexturePixels& texturePixels, EPixelFormat expectedPixelFormat, bool loadFormat)
+{
+	check(Ar.IsLoading());
+
+	// load the data
+	Ar << texturePixels.w;
+	Ar << texturePixels.h;
+	Ar << texturePixels.stride;
+	Ar << texturePixels.pixels;
+
+	if (loadFormat)
+	{
+		Ar << texturePixels.pixelFormat;
+		if (texturePixels.pixelFormat != expectedPixelFormat)
+			return;
+	}
+
+	// make sure we have data
+	if (texturePixels.w == 0 || texturePixels.h == 0 || texturePixels.stride == 0)
+		return;
+
+	// create the texture
+	FRHIResourceCreateInfo createInfo(TEXT("DDGITextureLoad"));
+	texturePixels.textureCPU = RHICreateTexture2D(texturePixels.w, texturePixels.h, expectedPixelFormat, 1, 1, TexCreate_ShaderResource | TexCreate_Transient, createInfo);
+
+	// copy the pixel data to the texture
+	ENQUEUE_RENDER_COMMAND(DDGILoadTex)(
+		[&texturePixels](FRHICommandListImmediate& RHICmdList)
+		{
+			uint32 destStride;
+			uint8* mappedTextureMemory = (uint8*)RHILockTexture2D(texturePixels.textureCPU, 0, RLM_WriteOnly, destStride, false);
+			if (texturePixels.stride == destStride)
+				FMemory::Memcpy(mappedTextureMemory, &texturePixels.pixels[0], texturePixels.h * texturePixels.stride);
+			RHIUnlockTexture2D(texturePixels.textureCPU, 0, false);
+			texturePixels.pixels.Reset();
+		}
+	);
+}
+
+void UDDGIVolumeComponent::Serialize(FArchive& Ar)
+{
+	Super::Serialize(Ar);
+
+	Ar.UsingCustomVersion(FDDGICustomVersion::GUID);
+	if(Ar.CustomVer(FDDGICustomVersion::GUID) < FDDGICustomVersion::AddingCustomVersion)
+	{
+		if (Ar.IsLoading())
+		{
+			uint32 w, h;
+			TArray<float> pixels;
+			Ar << w;
+			Ar << h;
+			Ar << pixels;
+		}
+	}
+	// save and load volume textures as a warm start when entering a level, but also for when raytracing is not available.
+	else if (Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTextures)
+	{
+		bool saveFormat = Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTexturesFmt;
+
+		FDDGIVolumeSceneProxy* proxy = SceneProxy;
+
+		if (Ar.IsSaving())
+		{
+			FDDGITexturePixels Irradiance, Distance, Offsets, States;
+
+			if (proxy)
+			{
+				// copy the textures to a cpu readable texture
+				ENQUEUE_RENDER_COMMAND(DDGISaveTexStep1)(
+					[&Irradiance, &Distance, &Offsets, &States, proxy](FRHICommandListImmediate& RHICmdList)
+					{
+						Irradiance = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesIrradianceTex);
+						Distance = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesDistanceTex);
+						Offsets = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesOffsetsTex);
+						States = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesStatesTex);
+					}
+				);
+				FlushRenderingCommands();
+
+				// read the texture data into cpu memory
+				ENQUEUE_RENDER_COMMAND(DDGISaveTexStep2)(
+					[&Irradiance, &Distance, &Offsets, &States](FRHICommandListImmediate& RHICmdList)
+					{
+						GetTexturePixelsStep2_RenderThread(RHICmdList, Irradiance);
+						GetTexturePixelsStep2_RenderThread(RHICmdList, Distance);
+						GetTexturePixelsStep2_RenderThread(RHICmdList, Offsets);
+						GetTexturePixelsStep2_RenderThread(RHICmdList, States);
+					}
+				);
+				FlushRenderingCommands();
+			}
+
+			// write the data out
+			SaveFDDGITexturePixels(Ar, Irradiance, proxy ? proxy->ProbesIrradianceTex : nullptr, saveFormat);
+			SaveFDDGITexturePixels(Ar, Distance, proxy ? proxy->ProbesDistanceTex : nullptr, saveFormat);
+			SaveFDDGITexturePixels(Ar, Offsets, proxy ? proxy->ProbesOffsetsTex : nullptr, saveFormat);
+			SaveFDDGITexturePixels(Ar, States, proxy ? proxy->ProbesStatesTex : nullptr, saveFormat);
+		}
+		else if (Ar.IsLoading())
+		{
+			bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+			bool loadFormat = Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTexturesFmt;
+
+			// read the data in and note that it's ready for load, so we can do that as soon as we have a scene context
+			LoadFDDGITexturePixels(Ar, LoadContext.Irradiance, highBitCount ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceLowBitDepth, loadFormat);
+			LoadFDDGITexturePixels(Ar, LoadContext.Distance, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistance, loadFormat);
+			LoadFDDGITexturePixels(Ar, LoadContext.Offsets, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatOffsets, loadFormat);
+			LoadFDDGITexturePixels(Ar, LoadContext.States, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatStates, loadFormat);
+			
+			FlushRenderingCommands();
+
+			LoadContext.ReadyForLoad = true;
+		}
+	}
+}
+
+void UDDGIVolumeComponent::UpdateRenderThreadData()
+{
+	//Send command to the rendering thread to update the transform and other parameters
+	if (SceneProxy)
+	{
+		// deal with probe scrolling
+		{
+			FVector CurrentOrigin = GetOwner()->GetTransform().GetLocation();
+
+			// if scrolling is on, we discretize movement by probe spacing size, and use ProbeScrollOffsets to keep the probes at the same world space position
+			if (EnableProbeScrolling && LastOrigin.SizeSquared() > 0.0f)
+			{
+				FVector movementDelta = CurrentOrigin - LastOrigin;
+
+				FVector probeGridSpacing;
+				FVector volumeSize = GetOwner()->GetTransform().GetScale3D() * 200.0f;
+				probeGridSpacing.X = volumeSize.X / float(ProbeCounts.X);
+				probeGridSpacing.Y = volumeSize.Y / float(ProbeCounts.Y);
+				probeGridSpacing.Z = volumeSize.Z / float(ProbeCounts.Z);
+
+				auto absFloor = [](float f) {
+					return f >= 0.f ? int(floor(f)) : int(ceil(f));
+				};
+
+				// calculate how many grid cells were moved
+				FIntVector ProbeScrollOffsetDelta;
+				ProbeScrollOffsetDelta.X = int(absFloor(movementDelta.X / probeGridSpacing.X));
+				ProbeScrollOffsetDelta.Y = int(absFloor(movementDelta.Y / probeGridSpacing.Y));
+				ProbeScrollOffsetDelta.Z = int(absFloor(movementDelta.Z / probeGridSpacing.Z));
+
+				// move the origin that amount
+				LastOrigin.X += float(ProbeScrollOffsetDelta.X) * probeGridSpacing.X;
+				LastOrigin.Y += float(ProbeScrollOffsetDelta.Y) * probeGridSpacing.Y;
+				LastOrigin.Z += float(ProbeScrollOffsetDelta.Z) * probeGridSpacing.Z;
+
+				// move the probe scroll offset that amount too
+				ProbeScrollOffset.X = (((ProbeScrollOffset.X + ProbeScrollOffsetDelta.X) % ProbeCounts.X) + ProbeCounts.X) % ProbeCounts.X;
+				ProbeScrollOffset.Y = (((ProbeScrollOffset.Y + ProbeScrollOffsetDelta.Y) % ProbeCounts.Y) + ProbeCounts.Y) % ProbeCounts.Y;
+				ProbeScrollOffset.Z = (((ProbeScrollOffset.Z + ProbeScrollOffsetDelta.Z) % ProbeCounts.Z) + ProbeCounts.Z) % ProbeCounts.Z;
+			}
+			// otherwise, we just move the volume
+			else
+			{
+				ProbeScrollOffset = FIntVector{ 0, 0, 0 };
+				LastOrigin = CurrentOrigin;
+			}
+		}
+
+		FDDGIVolumeSceneProxy::FComponentData ComponentData;
+		ComponentData.RaysPerProbe = RaysPerProbe;
+		ComponentData.ProbeMaxRayDistance = ProbeMaxRayDistance;
+		ComponentData.Transform = GetOwner()->GetTransform();
+		ComponentData.Transform.SetLocation(LastOrigin);
+		ComponentData.LightingChannels = LightingChannels;
+		ComponentData.ProbeCounts = ProbeCounts;
+		ComponentData.ProbeDistanceExponent = probeDistanceExponent;
+		ComponentData.ProbeIrradianceEncodingGamma = probeIrradianceEncodingGamma;
+		ComponentData.UpdatePriority = UpdatePriority;
+		ComponentData.ProbeHysteresis = ProbeHysteresis;
+		ComponentData.ProbeChangeThreshold = probeChangeThreshold;
+		ComponentData.ProbeBrightnessThreshold = probeBrightnessThreshold;
+		ComponentData.NormalBias = NormalBias;
+		ComponentData.ViewBias = ViewBias;
+		ComponentData.BlendDistance = VolumeBlendDistance;
+		ComponentData.ProbeBackfaceThreshold = ProbeBackfaceThreshold;
+		ComponentData.ProbeMinFrontfaceDistance = ProbeMinFrontfaceDistance;
+		ComponentData.EnableProbeRelocation = EnableProbeRelocation;
+		ComponentData.EnableProbeScrolling = EnableProbeScrolling;
+		ComponentData.ProbeScrollOffsets = ProbeScrollOffset;
+
+		// If the ProbeCounts are too large to make textures, let's not update the render thread data to avoid a crash.
+		// Everything is ok with not getting an update, ever, so this is safe.
+		{
+			volatile uint32 maxTextureSize = GetMax2DTextureDimension();
+
+			// DDGIRadiance
+			if (uint32(ProbeCounts.X * ProbeCounts.Y * ProbeCounts.Z) > maxTextureSize)
+				return;
+
+			FIntPoint ProxyDims = ComponentData.Get2DProbeCount();
+
+			// DDGIIrradiance
+			{
+				int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+				FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+				if (uint32(ProxyTexDims.X) > maxTextureSize || uint32(ProxyTexDims.Y) > maxTextureSize)
+					return;
+			}
+
+			// DDGIDistance
+			{
+				int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+				FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+				if (uint32(ProxyTexDims.X) > maxTextureSize || uint32(ProxyTexDims.Y) > maxTextureSize)
+					return;
+			}
+		}
+
+		FDDGIVolumeSceneProxy* DDGIProxy = SceneProxy;
+		bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+
+		FDDGITextureLoadContext TextureLoadContext = LoadContext;
+		LoadContext.ReadyForLoad = false;
+
+		ENQUEUE_RENDER_COMMAND(UpdateGIVolumeTransformCommand)(
+			[DDGIProxy, ComponentData, TextureLoadContext, highBitCount](FRHICommandListImmediate& RHICmdList)
+			{
+				bool needReallocate =
+					DDGIProxy->ComponentData.ProbeCounts != ComponentData.ProbeCounts ||
+					DDGIProxy->ComponentData.RaysPerProbe != ComponentData.RaysPerProbe ||
+					DDGIProxy->ComponentData.EnableProbeRelocation != ComponentData.EnableProbeRelocation;
+
+				// set the data
+				DDGIProxy->ComponentData = ComponentData;
+
+				// handle state textures ready to load from serialization
+				if (TextureLoadContext.ReadyForLoad)
+					DDGIProxy->TextureLoadContext = TextureLoadContext;
+
+				if (needReallocate)
+				{
+					DDGIProxy->ReallocateSurfaces_RenderThread(RHICmdList, highBitCount);
+					DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+					FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread.Add(DDGIProxy);
+				}
+			}
+		);
+	}
+}
+
+void UDDGIVolumeComponent::Startup()
+{
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	FDeferredShadingDelegates::FRenderVisualizationDelegate& RVDelegate = FDeferredShadingDelegates::OnRenderVisualization();
+	FDDGIVolumeSceneProxy::OnRenderVisualizationDelegateHandle = RVDelegate.AddStatic(FDDGIVolumeSceneProxy::RenderVisualization_RenderThread);
+#endif
+
+	FDeferredShadingDelegates::FRenderDiffuseLightingDelegate& RDLDelegate = FDeferredShadingDelegates::OnRenderDiffuseLighting();
+	FDDGIVolumeSceneProxy::OnRenderDiffuseLightingDelegateHandle = RDLDelegate.AddStatic(FDDGIVolumeSceneProxy::RenderDiffuseLighting_RenderThread);
+}
+
+void UDDGIVolumeComponent::Shutdown()
+{
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	FDeferredShadingDelegates::FRenderVisualizationDelegate& RVDelegate = FDeferredShadingDelegates::OnRenderVisualization();
+	check(FDDGIVolumeSceneProxy::OnRenderVisualizationDelegateHandle.IsValid());
+	RVDelegate.Remove(FDDGIVolumeSceneProxy::OnRenderVisualizationDelegateHandle);
+#endif
+
+	FDeferredShadingDelegates::FRenderDiffuseLightingDelegate& RDLDelegate = FDeferredShadingDelegates::OnRenderDiffuseLighting();
+	check(FDDGIVolumeSceneProxy::OnRenderDiffuseLightingDelegateHandle.IsValid());
+	RDLDelegate.Remove(FDDGIVolumeSceneProxy::OnRenderDiffuseLightingDelegateHandle);
+}
+
+bool UDDGIVolumeComponent::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	return ProcessConsoleExec(Cmd, Ar, NULL);
+}
+
+void UDDGIVolumeComponent::DDGIClearVolumes()
+{
+	ENQUEUE_RENDER_COMMAND(DDGIClearVolumesCommand)(
+		[](FRHICommandListImmediate& RHICmdList)
+		{
+			for (FDDGIVolumeSceneProxy* DDGIProxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+			{
+				DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+			}
+		}
+	);
+}
+
+void UDDGIVolumeComponent::CreateRenderState_Concurrent(FRegisterComponentContext* Context)
+{
+	Super::CreateRenderState_Concurrent(Context);
+	check(SceneProxy == nullptr);
+
+#if WITH_EDITOR
+	if (!GetOwner()->IsTemporarilyHiddenInEditor())
+#endif
+	{
+		SceneProxy = new FDDGIVolumeSceneProxy(GetScene());
+		UpdateRenderThreadData();
+	}
+}
+
+void UDDGIVolumeComponent::DestroyRenderState_Concurrent()
+{
+	Super::DestroyRenderState_Concurrent();
+
+	if (SceneProxy)
+	{
+		FDDGITextureLoadContext& ComponentLoadContext = LoadContext;
+
+		FDDGIVolumeSceneProxy* DDGIProxy = SceneProxy;
+		ENQUEUE_RENDER_COMMAND(DeleteProxy)(
+			[DDGIProxy, &ComponentLoadContext](FRHICommandListImmediate& RHICmdList)
+			{
+				// If the component has textures pending load, nothing to do here. Those are the most authoritative.
+				if (!ComponentLoadContext.ReadyForLoad)
+				{
+					// If the proxy has textures pending load which haven't been serviced yet, the component should take those
+					// in case it creates another proxy.
+					if (DDGIProxy->TextureLoadContext.ReadyForLoad)
+					{
+						ComponentLoadContext = DDGIProxy->TextureLoadContext;
+					}
+					// otherwise, we should copy the textures from this proxy into textures for the TextureLoadContext
+					// to make them survive to the next proxy for this component if one is created.
+					else
+					{
+						ComponentLoadContext.ReadyForLoad = true;
+						ComponentLoadContext.Irradiance = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesIrradianceTex);
+						ComponentLoadContext.Distance = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesDistanceTex);
+						ComponentLoadContext.Offsets = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesOffsetsTex);
+						ComponentLoadContext.States = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesStatesTex);
+					}
+				}
+
+				delete DDGIProxy;
+			}
+		);
+
+		// wait for the above command to finish, so we know we got the load context if present
+		FlushRenderingCommands();
+
+		SceneProxy = nullptr;
+	}
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.cpp
new file mode 100644
index 00000000000..e1f2fec731b
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.cpp
@@ -0,0 +1,1273 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeUpdate.h"
+
+// UE4 public interfaces
+#include "CoreMinimal.h"
+#include "Engine/TextureRenderTarget2D.h"
+#include "SceneView.h"
+#include "RenderGraph.h"
+#include "RayGenShaderUtils.h"
+#include "ShaderParameterStruct.h"
+#include "GlobalShader.h"
+#include "RTXGIPluginSettings.h"
+
+// UE4 private interfaces
+#include "ReflectionEnvironment.h"
+#include "FogRendering.h"
+#include "SceneRendering.h"
+#include "SceneTextureParameters.h"
+#include "RayTracing/RayTracingLighting.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+#include <cmath>
+
+// local includes
+#include "DDGIVolumeComponent.h"
+
+#define LOCTEXT_NAMESPACE "FRTXGIPlugin"
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+static TAutoConsoleVariable<int> CVarDDGIProbeVis(
+	TEXT("r.RTXGI.DDGIProbeVis"),
+	0,
+	TEXT("If 1, will render what the probes see. If 2, will show misses (blue), hits (green), backfaces (red). \'vis DDGIProbeVis\' to see the output.\n"),
+	ECVF_RenderThreadSafe | ECVF_Cheat);
+#endif
+
+// So we have something to give the "AddPass" calls that we add for transitions
+BEGIN_SHADER_PARAMETER_STRUCT(FDummyShaderParameters, )
+	SHADER_PARAMETER(int, Dummy)
+END_SHADER_PARAMETER_STRUCT()
+
+static FMatrix ComputeRandomRotation()
+{
+	// This approach is based on James Arvo's implementation from Graphics Gems 3 (pg 117-120).
+	// Also available at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&rep=rep1&type=pdf
+
+	// Setup a random rotation matrix using 3 uniform RVs
+	float u1 = 2.f * 3.14159265359 * FMath::FRand();
+	float cos1 = std::cosf(u1);
+	float sin1 = std::sinf(u1);
+
+	float u2 = 2.f * 3.14159265359 * FMath::FRand();
+	float cos2 = std::cosf(u2);
+	float sin2 = std::sinf(u2);
+
+	float u3 = FMath::FRand();
+	float sq3 = 2.f * std::sqrtf(u3 * (1.f - u3));
+
+	float s2 = 2.f * u3 * sin2 * sin2 - 1.f;
+	float c2 = 2.f * u3 * cos2 * cos2 - 1.f;
+	float sc = 2.f * u3 * sin2 * cos2;
+
+	// Create the random rotation matrix
+	float _11 = cos1 * c2 - sin1 * sc;
+	float _12 = sin1 * c2 + cos1 * sc;
+	float _13 = sq3 * cos2;
+
+	float _21 = cos1 * sc - sin1 * s2;
+	float _22 = sin1 * sc + cos1 * s2;
+	float _23 = sq3 * sin2;
+
+	float _31 = cos1 * (sq3 * cos2) - sin1 * (sq3 * sin2);
+	float _32 = sin1 * (sq3 * cos2) + cos1 * (sq3 * sin2);
+	float _33 = 1.f - 2.f * u3;
+
+	return FMatrix(	
+		FPlane( _11, _12, _13, 0.f ),
+		FPlane(_21, _22, _23, 0.f ),
+		FPlane(_31, _32, _33, 0.f ),
+		FPlane(0.f, 0.f, 0.f, 1.f )
+	);
+}
+
+class FRayTracingRTXGIProbeUpdateRGS : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FRayTracingRTXGIProbeUpdateRGS)
+	SHADER_USE_ROOT_PARAMETER_STRUCT(FRayTracingRTXGIProbeUpdateRGS, FGlobalShader)
+
+	class FEnableTwoSidedGeometryDim : SHADER_PERMUTATION_BOOL("ENABLE_TWO_SIDED_GEOMETRY"); // If false, it will cull back face triangles. We want this on for probe relocation and to stop light leak.
+	class FEnableMaterialsDim : SHADER_PERMUTATION_BOOL("ENABLE_MATERIALS");                 // If false, forces the geo to opaque (no alpha test). We want this off for speed.
+	class FDecoupleSampleGeneration : SHADER_PERMUTATION_BOOL("DECOUPLE_SAMPLE_GENERATION"); // Something for the skylight. We will turn this off
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableTwoSidedGeometryDim, FEnableMaterialsDim, FDecoupleSampleGeneration, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		// Set to 1 to be able to visualize this in the editor by typing "vis DDGIVolumeUpdateDebug" and later "vis none" to make it go away.
+		// Set to 0 to disable and deadstrip everything related
+		OutEnvironment.SetDefine(TEXT("DDGIVolumeUpdateDebug"), 0);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FVolumeData, )
+		SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradiance)
+		SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistance)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, ProbeOffsets)
+		SHADER_PARAMETER_UAV(RWTexture2D<uint>, ProbeStates)
+		SHADER_PARAMETER(FVector, Origin)
+		SHADER_PARAMETER(FVector, ProbeGridSpacing)
+		SHADER_PARAMETER(float, ProbeMaxRayDistance)
+		SHADER_PARAMETER(FIntVector, ProbeGridCounts)
+		SHADER_PARAMETER(FMatrix, ProbeRayRotationTransform)
+		SHADER_PARAMETER(int, NumRaysPerProbe)
+		SHADER_PARAMETER(FVector, Radius)
+		SHADER_PARAMETER(int, ProbeNumIrradianceTexels)
+		SHADER_PARAMETER(int, ProbeNumDistanceTexels)
+		SHADER_PARAMETER(float, ProbeIrradianceEncodingGamma)
+		SHADER_PARAMETER(float, NormalBias)
+		SHADER_PARAMETER(float, ViewBias)
+		SHADER_PARAMETER(FIntVector, ProbeScrollOffsets)
+		SHADER_PARAMETER_SAMPLER(SamplerState, LinearClampSampler)
+	END_SHADER_PARAMETER_STRUCT()
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER_SRV(RaytracingAccelerationStructure, TLAS)
+
+		SHADER_PARAMETER(uint32, FrameRandomSeed)
+
+		SHADER_PARAMETER_STRUCT(FVolumeData, DDGIVolume)
+
+		SHADER_PARAMETER(FVector, Sky_Color)
+		SHADER_PARAMETER_TEXTURE(Texture2D, Sky_Texture)
+		SHADER_PARAMETER_SAMPLER(SamplerState, Sky_TextureSampler)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, RadianceOutput)
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+		// assorted things needed by material resolves, even though some don't make sense outside of screenspace
+		SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SSProfilesTexture)
+		SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, ViewUniformBuffer)
+		SHADER_PARAMETER_STRUCT_REF(FRaytracingLightDataPacked, LightDataPacked)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FRayTracingRTXGIProbeUpdateRGS, "/Plugin/RTXGI/Private/ProbeUpdateRGS.usf", "ProbeUpdateRGS", SF_RayGen);
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+class FRayTracingRTXGIProbeViewRGS : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FRayTracingRTXGIProbeViewRGS)
+	SHADER_USE_ROOT_PARAMETER_STRUCT(FRayTracingRTXGIProbeViewRGS, FGlobalShader)
+
+	class FEnableTwoSidedGeometryDim : SHADER_PERMUTATION_BOOL("ENABLE_TWO_SIDED_GEOMETRY"); // If false, it will cull back face triangles. We want this on for probe relocation and to stop light leak.
+	class FEnableMaterialsDim : SHADER_PERMUTATION_BOOL("ENABLE_MATERIALS");                 // If false, forces the geo to opaque (no alpha test). We want this off for speed.
+	class FDecoupleSampleGeneration : SHADER_PERMUTATION_BOOL("DECOUPLE_SAMPLE_GENERATION"); // Something for the skylight. We will turn this off
+	class FVolumeDebugView : SHADER_PERMUTATION_INT("VOLUME_DEBUG_VIEW", 2);
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableTwoSidedGeometryDim, FEnableMaterialsDim, FDecoupleSampleGeneration, FVolumeDebugView>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_RELOCATION"), 0);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER_SRV(RaytracingAccelerationStructure, TLAS)
+
+		SHADER_PARAMETER(uint32, FrameRandomSeed)
+
+		SHADER_PARAMETER(FVector, CameraPos)
+		SHADER_PARAMETER(FMatrix, CameraMatrix)
+
+		SHADER_PARAMETER(float, DDGIVolume_PreExposure)
+		SHADER_PARAMETER(int32, DDGIVolume_ShouldUsePreExposure)
+
+		SHADER_PARAMETER(FVector, Sky_Color)
+		SHADER_PARAMETER_TEXTURE(Texture2D, Sky_Texture)
+		SHADER_PARAMETER_SAMPLER(SamplerState, Sky_TextureSampler)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, RadianceOutput)
+
+		// assorted things needed by material resolves, even though some don't make sense outside of screenspace
+		SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SSProfilesTexture)
+		SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, ViewUniformBuffer)
+		SHADER_PARAMETER_STRUCT_REF(FRaytracingLightDataPacked, LightDataPacked)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FRayTracingRTXGIProbeViewRGS, "/Plugin/RTXGI/Private/ProbeViewRGS.usf", "ProbeViewRGS", SF_RayGen);
+
+#endif // #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+class FDDGIIrradianceBlend : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIIrradianceBlend)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIIrradianceBlend, FGlobalShader)
+
+	class FRaysPerProbeEnum : SHADER_PERMUTATION_INT("RAYS_PER_PROBE_ENUM", int32(EDDGIRaysPerProbe::Count));
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FRaysPerProbeEnum, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		OutEnvironment.SetDefine(TEXT("PROBE_NUM_TEXELS"), FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_BLEND_RADIANCE"), 1);
+
+		// Set to 1 to be able to visualize this in the editor by typing "vis DDGIIrradianceBlendDebug" and later "vis none" to make it go away.
+		// Set to 0 to disable and deadstrip everything related
+		OutEnvironment.SetDefine(TEXT("DDGIIrradianceBlendDebug"), 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+
+		// DDGI volume parameters
+		// {
+			SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+			SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+			SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+			SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+			SHADER_PARAMETER(float, DDGIVolume_probeDistanceExponent)
+			SHADER_PARAMETER(float, DDGIVolume_probeInverseIrradianceEncodingGamma)
+			SHADER_PARAMETER(float, DDGIVolume_probeHysteresis)
+			SHADER_PARAMETER(float, DDGIVolume_probeChangeThreshold)
+			SHADER_PARAMETER(float, DDGIVolume_probeBrightnessThreshold)
+			SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+		// }
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+		SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIIrradianceBlend, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBlendingCS.usf", "DDGIProbeBlendingCS", SF_Compute);
+
+class FDDGIDistanceBlend : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIDistanceBlend)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIDistanceBlend, FGlobalShader)
+
+	class FRaysPerProbeEnum : SHADER_PERMUTATION_INT("RAYS_PER_PROBE_ENUM", int32(EDDGIRaysPerProbe::Count));
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FRaysPerProbeEnum, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+		OutEnvironment.SetDefine(TEXT("PROBE_NUM_TEXELS"), FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_BLEND_RADIANCE"), 0);
+
+		// Set to 1 to be able to visualize this in the editor by typing "vis DDGIDistanceBlendDebug" and later "vis none" to make it go away.
+		// Set to 0 to disable and deadstrip everything related
+		OutEnvironment.SetDefine(TEXT("DDGIDistanceBlendDebug"), 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+
+		// DDGI volume parameters
+		// {
+			SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+			SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+			SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+			SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+			SHADER_PARAMETER(float, DDGIVolume_probeDistanceExponent)
+			SHADER_PARAMETER(float, DDGIVolume_probeInverseIrradianceEncodingGamma)
+			SHADER_PARAMETER(float, DDGIVolume_probeHysteresis)
+			SHADER_PARAMETER(float, DDGIVolume_probeChangeThreshold)
+			SHADER_PARAMETER(float, DDGIVolume_probeBrightnessThreshold)
+			SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+		// }
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+		SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIDistanceBlend, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBlendingCS.usf", "DDGIProbeBlendingCS", SF_Compute);
+
+class FDDGIBorderRowUpdate : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIBorderRowUpdate)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIBorderRowUpdate, FGlobalShader)
+
+		static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER(uint32, ProbeNumIrradianceOrDistanceTexels)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIBorderRowUpdate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBorderUpdateCS.usf", "DDGIProbeBorderRowUpdateCS", SF_Compute);
+
+class FDDGIBorderColumnUpdate : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIBorderColumnUpdate)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIBorderColumnUpdate, FGlobalShader)
+
+		static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER(uint32, ProbeNumIrradianceOrDistanceTexels)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIBorderColumnUpdate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBorderUpdateCS.usf", "DDGIProbeBorderColumnUpdateCS", SF_Compute);
+
+class FDDGIProbesRelocate : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIProbesRelocate)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIProbesRelocate, FGlobalShader)
+
+	class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FDebugFormatRadiance, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_RELOCATION"), 1);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER(float, ProbeDistanceScale)
+		SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+		SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+		SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+		SHADER_PARAMETER(float, DDGIVolume_probeBackfaceThreshold)
+		SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+		SHADER_PARAMETER(float, DDGIVolume_probeMinFrontfaceDistance)
+		SHADER_PARAMETER(FIntVector, DDGIVolume_ProbeScrollOffsets)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+		SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeOffsets)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIProbesRelocate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeRelocationCS.usf", "DDGIProbeRelocationCS", SF_Compute);
+
+class FDDGIProbesClassify : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FDDGIProbesClassify)
+	SHADER_USE_PARAMETER_STRUCT(FDDGIProbesClassify, FGlobalShader)
+
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), 1);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+	}
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+		SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+		SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+		SHADER_PARAMETER(float, DDGIVolume_probeBackfaceThreshold)
+		SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+
+		SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+		SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIProbesClassify, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeStateClassifierCS.usf", "DDGIProbeStateClassifierCS", SF_Compute);
+
+namespace DDGIVolumeUpdate {
+
+	FDelegateHandle OnPrepareRayTracingDelegateHandle;
+	FDelegateHandle OnAskRaytracingPassEnabledDelegateHandle;
+
+	void DDGIUpdateVolume_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+
+	void DDGIUpdateVolume_RenderThread_DDGIProbeVis(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder);
+
+	void DDGIUpdateVolume_RenderThread_RTRadiance(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureRef ProbesRadianceTex, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+	void DDGIUpdateVolume_RenderThread_IrradianceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+	void DDGIUpdateVolume_RenderThread_DistanceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+	void DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+	void DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+	void DDGIUpdateVolume_RenderThread_RelocateProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+	void DDGIUpdateVolume_RenderThread_ClassifyProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+
+	void PrepareRayTracingShaders(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
+
+	// ---------------------- IMPLEMENTATION ------------------
+
+	bool ShouldDynamicUpdate(const FViewInfo& View)
+	{
+		return IsRayTracingEnabled() && View.RayTracingScene.RayTracingSceneRHI != nullptr;
+	}
+
+	void Startup()
+	{
+		auto& PRTDelegate = FDeferredShadingDelegates::OnPrepareRayTracing();
+		OnPrepareRayTracingDelegateHandle = PRTDelegate.AddStatic(PrepareRayTracingShaders);
+
+		auto& ARTPEDelegate = FDeferredShadingDelegates::OnAskRaytracingPassEnabled();
+		OnAskRaytracingPassEnabledDelegateHandle = ARTPEDelegate.AddStatic(
+			[](bool& anyEnabled)
+			{
+				anyEnabled |= true;
+			}
+		);
+	}
+
+	void Shutdown()
+	{
+		auto& PRTDelegate = FDeferredShadingDelegates::OnPrepareRayTracing();
+		check(OnPrepareRayTracingDelegateHandle.IsValid());
+		PRTDelegate.Remove(OnPrepareRayTracingDelegateHandle);
+
+		auto& ARTPEDelegate = FDeferredShadingDelegates::OnAskRaytracingPassEnabled();
+		check(OnAskRaytracingPassEnabledDelegateHandle.IsValid());
+		ARTPEDelegate.Remove(OnAskRaytracingPassEnabledDelegateHandle);
+	}
+
+	void DDGIUpdatePerFrame_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder)
+	{
+		// ASSUMES RENDERTHREAD
+		check(IsInRenderingThread() || IsInParallelRenderingThread());
+
+		// render the world as the probes see it, for debugging purposes
+		DDGIUpdateVolume_RenderThread_DDGIProbeVis(Scene, View, GraphBuilder);
+
+		// gather the list of volumes in this scene
+		TArray<FDDGIVolumeSceneProxy*> sceneVolumes;
+		float totalPriority = 0.0f;
+		for (FDDGIVolumeSceneProxy* proxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+		{
+			if (proxy->OwningScene != &Scene)
+				continue;
+
+			sceneVolumes.Add(proxy);
+			totalPriority += proxy->ComponentData.UpdatePriority;
+		}
+
+		// advance the scene's round robin value by the golden ratio (conjugate) and use that as a "random number"
+		// to give each volume a fair turn at weighted round robin.
+		float& value = FDDGIVolumeSceneProxy::SceneRoundRobinValue.FindOrAdd(&Scene);
+		value += 0.61803398875f;
+		value -= floor(value);
+		float desiredPriority = totalPriority * value;
+		for (int index = 0; index < sceneVolumes.Num(); ++index)
+		{
+			desiredPriority -= sceneVolumes[index]->ComponentData.UpdatePriority;
+			if (desiredPriority <= 0.0f || index == sceneVolumes.Num() - 1)
+			{
+				DDGIUpdateVolume_RenderThread(Scene, View, GraphBuilder, sceneVolumes[index]);
+				break;
+			}
+		}
+	}
+
+	void PrepareRayTracingShaders(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders)
+	{
+		const auto FeatureLevel = GMaxRHIFeatureLevel;
+		auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+
+		for (int i = 0; i < 8; ++i)
+		{
+			FRayTracingRTXGIProbeUpdateRGS::FPermutationDomain PermutationVector;
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableTwoSidedGeometryDim>(true);
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableMaterialsDim>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDecoupleSampleGeneration>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableRelocation>((i & 1) != 0 ? true : false);
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDebugFormatRadiance>((i & 2) != 0 ? true : false);
+			PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableScrolling>((i & 4) != 0 ? true : false);
+
+			TShaderMapRef<FRayTracingRTXGIProbeUpdateRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+			OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+		}
+
+		#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+		{
+			FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(0);
+			TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+			OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+		}
+
+		{
+			FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+			PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(1);
+			TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+			OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+		}
+		#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	}
+
+	static void CopyTexture_RenderThread(FRHICommandList& RHICmdList, FTexture2DRHIRef dest, FDDGITexturePixels src)
+	{
+		// bail out if incompatible
+		if (!dest || !src.textureCPU || dest->GetSizeX() != src.w || dest->GetSizeY() != src.h)
+			return;
+
+		RHICmdList.CopyTexture(src.textureCPU, dest, FRHICopyTextureInfo{});
+	}
+
+	void DDGIUpdateVolume_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+	{
+		// load the textures from disk if we should
+		if (VolProxy->TextureLoadContext.ReadyForLoad)
+		{
+			GraphBuilder.AddPass(
+				RDG_EVENT_NAME("DDGI Volume Texture Loading"),
+				GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+				ERDGPassFlags::Compute,
+				[VolProxy](FRHICommandList& RHICmdList)
+				{
+					CopyTexture_RenderThread(RHICmdList, VolProxy->ProbesIrradianceTex, VolProxy->TextureLoadContext.Irradiance);
+					CopyTexture_RenderThread(RHICmdList, VolProxy->ProbesDistanceTex, VolProxy->TextureLoadContext.Distance);
+					CopyTexture_RenderThread(RHICmdList, VolProxy->ProbesOffsetsTex, VolProxy->TextureLoadContext.Offsets);
+					CopyTexture_RenderThread(RHICmdList, VolProxy->ProbesStatesTex, VolProxy->TextureLoadContext.States);
+					VolProxy->TextureLoadContext.Clear();
+				}
+			);
+		}
+
+		if (!ShouldDynamicUpdate(View))
+			return;
+
+		bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+
+		// ASSUMES RENDERTHREAD
+		check(IsInRenderingThread() || IsInParallelRenderingThread());
+		check(VolProxy);
+
+		FMatrix randomRotation = ComputeRandomRotation();
+
+		// Create the temporary radiance texture & UAV
+		FRDGTextureRef ProbesRadianceTex;
+		FRDGTextureUAVRef ProbesRadianceUAV;
+		{
+			const FDDGIVolumeSceneProxy::FComponentData& ComponentData = VolProxy->ComponentData;
+			FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2DDesc(
+				FIntPoint
+				{
+					(int32)ComponentData.GetNumRaysPerProbe(),
+					(int32)ComponentData.ProbeCounts.X * ComponentData.ProbeCounts.Y * ComponentData.ProbeCounts.Z,
+				},
+				// This texture stores both color and distance
+				highBitCount ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatRadianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatRadianceLowBitDepth,
+				FClearValueBinding::None,
+				TexCreate_None,
+				TexCreate_ShaderResource | TexCreate_UAV,
+				false
+			);
+			ProbesRadianceTex = GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIVolumeRadiance"));
+			ProbesRadianceUAV = GraphBuilder.CreateUAV(ProbesRadianceTex);
+		}
+
+		DDGIUpdateVolume_RenderThread_RTRadiance(Scene, View, GraphBuilder, VolProxy, randomRotation, ProbesRadianceTex, ProbesRadianceUAV, highBitCount);
+		DDGIUpdateVolume_RenderThread_IrradianceBlend(View, GraphBuilder, VolProxy, randomRotation, ProbesRadianceUAV, highBitCount);
+		DDGIUpdateVolume_RenderThread_DistanceBlend(View, GraphBuilder, VolProxy, randomRotation, ProbesRadianceUAV, highBitCount);
+		DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(View, GraphBuilder, VolProxy);
+		DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(View, GraphBuilder, VolProxy);
+
+		if (VolProxy->ComponentData.EnableProbeRelocation)
+		{
+			DDGIUpdateVolume_RenderThread_RelocateProbes(GraphBuilder, VolProxy, randomRotation, ProbesRadianceUAV, highBitCount);
+		}
+
+		if (FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER)
+		{
+			DDGIUpdateVolume_RenderThread_ClassifyProbes(GraphBuilder, VolProxy, randomRotation, ProbesRadianceUAV, highBitCount);
+		}
+	}
+
+	void DDGIUpdateVolume_RenderThread_DDGIProbeVis(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder)
+	{
+		#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+		// if not doing vis, don't render this
+		int DDGIProbeVis = CVarDDGIProbeVis.GetValueOnRenderThread();
+		if (DDGIProbeVis == 0 || View.RayTracingScene.RayTracingSceneRHI == nullptr)
+			return;
+
+		static const int c_probeVisWidth = 800;
+		static const int c_probeVisHeight = 600;
+
+		// create the texture and uav being rendered to
+		FRDGTextureDesc ProbeVisTex = FRDGTextureDesc::Create2DDesc(
+			FIntPoint(c_probeVisWidth, c_probeVisHeight),
+			EPixelFormat::PF_A32B32G32R32F,
+			FClearValueBinding::None,
+			TexCreate_None,
+			TexCreate_ShaderResource | TexCreate_UAV,
+			false
+		);
+		FRDGTextureUAVRef ProbeVisUAV = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(ProbeVisTex, TEXT("DDGIProbeVis")));
+
+		// get the shader
+		const auto FeatureLevel = GMaxRHIFeatureLevel;
+		auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+		FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+		PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+		PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+		PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(DDGIProbeVis - 1);
+		TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+		// fill out shader parameters
+		FRayTracingRTXGIProbeViewRGS::FParameters DefaultPassParameters;
+		FRayTracingRTXGIProbeViewRGS::FParameters* PassParameters = GraphBuilder.AllocParameters<FRayTracingRTXGIProbeViewRGS::FParameters>();
+		*PassParameters = DefaultPassParameters;
+
+		PassParameters->DDGIVolume_PreExposure = View.PreExposure;
+		PassParameters->DDGIVolume_ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+
+		PassParameters->CameraPos = View.ViewMatrices.GetViewOrigin();
+		PassParameters->CameraMatrix = View.ViewMatrices.GetViewMatrix().Inverse();
+
+		PassParameters->TLAS = View.RayTracingScene.RayTracingSceneRHI->GetShaderResourceView();
+		check(PassParameters->TLAS);
+		PassParameters->RadianceOutput = ProbeVisUAV;
+		PassParameters->FrameRandomSeed = GFrameNumber;
+
+		// skylight parameters
+		if (Scene.SkyLight && Scene.SkyLight->ProcessedTexture)
+		{
+			PassParameters->Sky_Color = FVector(Scene.SkyLight->GetEffectiveLightColor());
+			PassParameters->Sky_Texture = Scene.SkyLight->ProcessedTexture->TextureRHI;
+			PassParameters->Sky_TextureSampler = Scene.SkyLight->ProcessedTexture->SamplerStateRHI;
+		}
+		else
+		{
+			PassParameters->Sky_Color = FVector(0.0);
+			PassParameters->Sky_Texture = GBlackTextureCube->TextureRHI;
+			PassParameters->Sky_TextureSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+		}
+
+		PassParameters->SSProfilesTexture = GraphBuilder.RegisterExternalTexture(View.RayTracingSubSurfaceProfileTexture);
+		PassParameters->ViewUniformBuffer = View.ViewUniformBuffer;
+		PassParameters->LightDataPacked = View.RayTracingLightingDataUniformBuffer;
+
+		FIntPoint DispatchSize(c_probeVisWidth, c_probeVisHeight);
+
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI RTRadiance %dx%d", DispatchSize.X, DispatchSize.Y),
+			PassParameters,
+			ERDGPassFlags::Compute,
+			[PassParameters, &View, RayGenerationShader, DispatchSize](FRHICommandList& RHICmdList)
+			{
+				FRayTracingShaderBindingsWriter GlobalResources;
+				SetShaderParameters(GlobalResources, RayGenerationShader, *PassParameters);
+
+				FRHIRayTracingScene* RayTracingSceneRHI = View.RayTracingScene.RayTracingSceneRHI;
+				RHICmdList.RayTraceDispatch(View.RayTracingMaterialPipeline, RayGenerationShader.GetRayTracingShader(), RayTracingSceneRHI, GlobalResources, DispatchSize.X, DispatchSize.Y);
+			}
+		);
+		#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	}
+
+	void DDGIUpdateVolume_RenderThread_RTRadiance(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureRef ProbesRadianceTex, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+	{
+		const auto FeatureLevel = GMaxRHIFeatureLevel;
+		auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+
+		FRayTracingRTXGIProbeUpdateRGS::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableTwoSidedGeometryDim>(true);
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableMaterialsDim>(false);
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDecoupleSampleGeneration>(false);
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDebugFormatRadiance>(highBitCount);
+		PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+		TShaderMapRef<FRayTracingRTXGIProbeUpdateRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+		FRayTracingRTXGIProbeUpdateRGS::FParameters DefaultPassParameters;
+		FRayTracingRTXGIProbeUpdateRGS::FParameters* PassParameters = GraphBuilder.AllocParameters<FRayTracingRTXGIProbeUpdateRGS::FParameters>();
+		*PassParameters = DefaultPassParameters;
+
+		PassParameters->TLAS = View.RayTracingScene.RayTracingSceneRHI->GetShaderResourceView();
+		check(PassParameters->TLAS);
+		PassParameters->RadianceOutput = ProbesRadianceUAV;
+		PassParameters->FrameRandomSeed = GFrameNumber;
+
+		// skylight parameters
+		if (Scene.SkyLight && Scene.SkyLight->ProcessedTexture)
+		{
+			PassParameters->Sky_Color = FVector(Scene.SkyLight->GetEffectiveLightColor());
+			PassParameters->Sky_Texture = Scene.SkyLight->ProcessedTexture->TextureRHI;
+			PassParameters->Sky_TextureSampler = Scene.SkyLight->ProcessedTexture->SamplerStateRHI;
+		}
+		else
+		{
+			PassParameters->Sky_Color = FVector(0.0);
+			PassParameters->Sky_Texture = GBlackTextureCube->TextureRHI;
+			PassParameters->Sky_TextureSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+		}
+
+		// DDGI Volume Parameters
+		{
+			PassParameters->DDGIVolume.ProbeIrradiance = VolProxy->ProbesIrradianceTex;
+			PassParameters->DDGIVolume.ProbeDistance = VolProxy->ProbesDistanceTex;
+			PassParameters->DDGIVolume.ProbeOffsets = VolProxy->ProbesOffsetsUAV ? VolProxy->ProbesOffsetsUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+			PassParameters->DDGIVolume.ProbeStates = VolProxy->ProbesStatesUAV ? VolProxy->ProbesStatesUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+
+			PassParameters->DDGIVolume.Origin = VolProxy->ComponentData.Transform.GetLocation();
+			PassParameters->DDGIVolume.ProbeMaxRayDistance = VolProxy->ComponentData.ProbeMaxRayDistance;
+			PassParameters->DDGIVolume.ProbeGridCounts = VolProxy->ComponentData.ProbeCounts;
+			PassParameters->DDGIVolume.ProbeRayRotationTransform = randomRotation;
+			PassParameters->DDGIVolume.NumRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+
+			// calculate grid spacing based on size (scale) and probe count
+			// regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+			FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+			FVector probeGridSpacing;
+			probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+			probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+			probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+			PassParameters->DDGIVolume.ProbeGridSpacing = probeGridSpacing;
+
+			PassParameters->DDGIVolume.Radius = VolProxy->ComponentData.Transform.GetScale3D() * 100.0f;
+			PassParameters->DDGIVolume.ProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+			PassParameters->DDGIVolume.ProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+			PassParameters->DDGIVolume.ProbeIrradianceEncodingGamma = VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+			PassParameters->DDGIVolume.NormalBias = VolProxy->ComponentData.NormalBias;
+			PassParameters->DDGIVolume.ViewBias = VolProxy->ComponentData.ViewBias;
+			PassParameters->DDGIVolume.ProbeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+
+			PassParameters->DDGIVolume.LinearClampSampler = TStaticSamplerState<SF_Trilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+		}
+
+		FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2DDesc(
+			ProbesRadianceTex->Desc.Extent,
+			ProbesRadianceTex->Desc.Format,
+			FClearValueBinding::None,
+			TexCreate_None,
+			TexCreate_ShaderResource | TexCreate_UAV,
+			false
+		);
+		PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIVolumeUpdateDebug")));
+
+		PassParameters->SSProfilesTexture = GraphBuilder.RegisterExternalTexture(View.RayTracingSubSurfaceProfileTexture);
+		PassParameters->ViewUniformBuffer = View.ViewUniformBuffer;
+		PassParameters->LightDataPacked = View.RayTracingLightingDataUniformBuffer;
+
+		FIntPoint DispatchSize = ProbesRadianceTex->Desc.Extent;
+
+		FTexture2DRHIRef irradianceTex = VolProxy->ProbesIrradianceTex;
+		FTexture2DRHIRef distanceTex = VolProxy->ProbesDistanceTex;
+
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI RTRadiance %dx%d", DispatchSize.X, DispatchSize.Y),
+			PassParameters,
+			ERDGPassFlags::Compute,
+			[PassParameters, &View, RayGenerationShader, DispatchSize, irradianceTex, distanceTex, ProbesRadianceTex](FRHICommandList& RHICmdList)
+			{
+				FRayTracingShaderBindingsWriter GlobalResources;
+				SetShaderParameters(GlobalResources, RayGenerationShader, *PassParameters);
+
+				FRHIRayTracingScene* RayTracingSceneRHI = View.RayTracingScene.RayTracingSceneRHI;
+				RHICmdList.RayTraceDispatch(View.RayTracingMaterialPipeline, RayGenerationShader.GetRayTracingShader(), RayTracingSceneRHI, GlobalResources, DispatchSize.X, DispatchSize.Y);
+
+				// Irradiance and distance are read during the probe update rgs above to give infinite bounce lighting.
+				// They are going to be written next based on these results.
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, irradianceTex);
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, distanceTex);
+				//RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, ProbesRadianceTex->GetRHI());
+			}
+		);
+	}
+
+	void DDGIUpdateVolume_RenderThread_IrradianceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+	{
+		FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		FDDGIIrradianceBlend::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FDDGIIrradianceBlend::FRaysPerProbeEnum>(int(VolProxy->ComponentData.RaysPerProbe));
+		PermutationVector.Set<FDDGIIrradianceBlend::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+		PermutationVector.Set<FDDGIIrradianceBlend::FDebugFormatRadiance>(highBitCount);
+		PermutationVector.Set<FDDGIIrradianceBlend::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+		TShaderMapRef<FDDGIIrradianceBlend> ComputeShader(ShaderMap, PermutationVector);
+
+		FDDGIIrradianceBlend::FParameters DefaultPassParameters;
+		FDDGIIrradianceBlend::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIIrradianceBlend::FParameters>();
+		*PassParameters = DefaultPassParameters;
+		
+		PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+		PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+		PassParameters->DDGIVolume_probeRayRotationTransform = randomRotation;
+		PassParameters->DDGIVolume_probeDistanceExponent = VolProxy->ComponentData.ProbeDistanceExponent;
+		PassParameters->DDGIVolume_probeInverseIrradianceEncodingGamma = 1.0f / VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+		PassParameters->DDGIVolume_probeHysteresis = VolProxy->ComponentData.ProbeHysteresis;
+		PassParameters->DDGIVolume_probeChangeThreshold = VolProxy->ComponentData.ProbeChangeThreshold;
+		PassParameters->DDGIVolume_probeBrightnessThreshold = VolProxy->ComponentData.ProbeBrightnessThreshold;
+		PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+
+		// calculate grid spacing based on size (scale) and probe count
+		// regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+		FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+		FVector probeGridSpacing;
+		probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+		probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+		probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+		PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+		PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+		PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+		PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV ? VolProxy->ProbesStatesUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+
+		FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2DDesc(
+			VolProxy->ProbesIrradianceTex->GetSizeXY(),
+			VolProxy->ProbesIrradianceTex->GetFormat(),
+			FClearValueBinding::None,
+			TexCreate_None,
+			TexCreate_ShaderResource | TexCreate_UAV,
+			false
+		);
+		PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIIrradianceBlendDebug")));
+
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+		FComputeShaderUtils::AddPass(
+			GraphBuilder,
+			RDG_EVENT_NAME("DDGI Radiance Blend"),
+			ComputeShader,
+			PassParameters,
+			FIntVector(ProbeCount2D.X, ProbeCount2D.Y, 1)
+		);
+	}
+
+	void DDGIUpdateVolume_RenderThread_DistanceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+	{
+		FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		FDDGIDistanceBlend::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FDDGIDistanceBlend::FRaysPerProbeEnum>(int(VolProxy->ComponentData.RaysPerProbe));
+		PermutationVector.Set<FDDGIDistanceBlend::FEnableRelocation>(int(VolProxy->ComponentData.EnableProbeRelocation));
+		PermutationVector.Set<FDDGIDistanceBlend::FDebugFormatRadiance>(highBitCount);
+		PermutationVector.Set<FDDGIDistanceBlend::FEnableScrolling>(int(VolProxy->ComponentData.EnableProbeScrolling));
+		TShaderMapRef<FDDGIDistanceBlend> ComputeShader(ShaderMap, PermutationVector);
+
+		FDDGIDistanceBlend::FParameters DefaultPassParameters;
+		FDDGIDistanceBlend::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIDistanceBlend::FParameters>();
+		*PassParameters = DefaultPassParameters;
+
+		PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+		PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+		PassParameters->DDGIVolume_probeRayRotationTransform = randomRotation;
+		PassParameters->DDGIVolume_probeDistanceExponent = VolProxy->ComponentData.ProbeDistanceExponent;
+		PassParameters->DDGIVolume_probeInverseIrradianceEncodingGamma = 1.0f / VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+		PassParameters->DDGIVolume_probeHysteresis = VolProxy->ComponentData.ProbeHysteresis;
+		PassParameters->DDGIVolume_probeChangeThreshold = VolProxy->ComponentData.ProbeChangeThreshold;
+		PassParameters->DDGIVolume_probeBrightnessThreshold = VolProxy->ComponentData.ProbeBrightnessThreshold;
+		PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+
+		// calculate grid spacing based on size (scale) and probe count
+		// regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+		FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+		FVector probeGridSpacing;
+		probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+		probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+		probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+		PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+		PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+		PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+		PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV ? VolProxy->ProbesStatesUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+
+		FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2DDesc(
+			VolProxy->ProbesDistanceTex->GetSizeXY(),
+			VolProxy->ProbesDistanceTex->GetFormat(),
+			FClearValueBinding::None,
+			TexCreate_None,
+			TexCreate_ShaderResource | TexCreate_UAV,
+			false
+		);
+		PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIDistanceBlendDebug")));
+
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+		FComputeShaderUtils::AddPass(
+			GraphBuilder,
+			RDG_EVENT_NAME("DDGI Distance Blend"),
+			ComputeShader,
+			PassParameters,
+			FIntVector(ProbeCount2D.X, ProbeCount2D.Y, 1)
+		);
+
+		// UAV barrier for irradiance and distance uavs so the blends are done before doing border updates
+		FTexture2DRHIRef irradianceTex = VolProxy->ProbesIrradianceTex;
+		FTexture2DRHIRef distanceTex = VolProxy->ProbesDistanceTex;
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI Pre Border Update UAV Barrier"),
+			GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+			ERDGPassFlags::Compute,
+			[irradianceTex, distanceTex](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, irradianceTex);
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, distanceTex);
+			}
+		);
+	}
+
+	void DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+	{
+		float groupSize = 8.0f;
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+
+		// Row
+		{
+			FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+			TShaderMapRef<FDDGIBorderRowUpdate> ComputeShader(ShaderMap);
+
+			FDDGIBorderRowUpdate::FParameters DefaultPassParameters;
+			FDDGIBorderRowUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderRowUpdate::FParameters>();
+			*PassParameters = DefaultPassParameters;
+
+			PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+			PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+
+			uint32 numThreadsX = (ProbeCount2D.X * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+			uint32 numThreadsY = ProbeCount2D.Y;
+			uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSize);
+			uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSize);
+
+			FComputeShaderUtils::AddPass(
+				GraphBuilder,
+				RDG_EVENT_NAME("DDGI Irradiance Border Update Row"),
+				ComputeShader,
+				PassParameters,
+				FIntVector(numGroupsX, numGroupsY, 1)
+			);
+		}
+
+		// Column
+		{
+			FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+			TShaderMapRef<FDDGIBorderColumnUpdate> ComputeShader(ShaderMap);
+
+			FDDGIBorderColumnUpdate::FParameters DefaultPassParameters;
+			FDDGIBorderColumnUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderColumnUpdate::FParameters>();
+			*PassParameters = DefaultPassParameters;
+
+			PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+			PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+
+			uint32 numThreadsX = (ProbeCount2D.X * 2);
+			uint32 numThreadsY = (ProbeCount2D.Y * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+			uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSize);
+			uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSize);
+
+			FComputeShaderUtils::AddPass(
+				GraphBuilder,
+				RDG_EVENT_NAME("DDGI Irradiance Border Update Column"),
+				ComputeShader,
+				PassParameters,
+				FIntVector(numGroupsX, numGroupsY, 1)
+			);
+		}
+	}
+
+	void DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+	{
+		float groupSize = 8.0f;
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+
+		// Row
+		{
+			FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+			TShaderMapRef<FDDGIBorderRowUpdate> ComputeShader(ShaderMap);
+
+			FDDGIBorderRowUpdate::FParameters DefaultPassParameters;
+			FDDGIBorderRowUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderRowUpdate::FParameters>();
+			*PassParameters = DefaultPassParameters;
+
+			PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+			PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+
+			uint32 numThreadsX = (ProbeCount2D.X * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+			uint32 numThreadsY = ProbeCount2D.Y;
+			uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSize);
+			uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSize);
+
+			FComputeShaderUtils::AddPass(
+				GraphBuilder,
+				RDG_EVENT_NAME("DDGI Distance Border Update Row"),
+				ComputeShader,
+				PassParameters,
+				FIntVector(numGroupsX, numGroupsY, 1)
+			);
+		}
+
+		// Column
+		{
+			FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+			TShaderMapRef<FDDGIBorderColumnUpdate> ComputeShader(ShaderMap);
+
+			FDDGIBorderColumnUpdate::FParameters DefaultPassParameters;
+			FDDGIBorderColumnUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderColumnUpdate::FParameters>();
+			*PassParameters = DefaultPassParameters;
+
+			PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+			PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+
+			uint32 numThreadsX = (ProbeCount2D.X * 2);
+			uint32 numThreadsY = (ProbeCount2D.Y * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+			uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSize);
+			uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSize);
+
+			FComputeShaderUtils::AddPass(
+				GraphBuilder,
+				RDG_EVENT_NAME("DDGI Distance Border Update Column"),
+				ComputeShader,
+				PassParameters,
+				FIntVector(numGroupsX, numGroupsY, 1)
+			);
+		}
+
+		// UAV barrier for irradiance and distance uavs so the border updates are done before they are read by the next processes
+		FTexture2DRHIRef irradianceTex = VolProxy->ProbesIrradianceTex;
+		FTexture2DRHIRef distanceTex = VolProxy->ProbesDistanceTex;
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI Post Border Update UAV Barrier"),
+			GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+			ERDGPassFlags::Compute,
+			[irradianceTex, distanceTex](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, irradianceTex);
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, distanceTex);
+			}
+		);
+	}
+
+	void DDGIUpdateVolume_RenderThread_RelocateProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+	{
+		FDDGIProbesRelocate::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FDDGIProbesRelocate::FDebugFormatRadiance>(highBitCount);
+		PermutationVector.Set<FDDGIProbesRelocate::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+		FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		TShaderMapRef<FDDGIProbesRelocate> ComputeShader(ShaderMap, PermutationVector);
+
+		FDDGIProbesRelocate::FParameters DefaultPassParameters;
+		FDDGIProbesRelocate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIProbesRelocate::FParameters>();
+		*PassParameters = DefaultPassParameters;
+
+		// run every frame with full distance scale value for continuous relocation
+		PassParameters->ProbeDistanceScale = 1.0f;
+
+		// calculate grid spacing based on size (scale) and probe count
+		// regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+		FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+		FVector probeGridSpacing;
+		probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+		probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+		probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+		PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+		PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+		PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+
+		PassParameters->DDGIVolume_ProbeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+
+		PassParameters->DDGIVolume_probeBackfaceThreshold = VolProxy->ComponentData.ProbeBackfaceThreshold;
+		PassParameters->DDGIVolume_probeRayRotationTransform = randomRotation;
+		PassParameters->DDGIVolume_probeMinFrontfaceDistance = VolProxy->ComponentData.ProbeMinFrontfaceDistance;
+
+		PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+		PassParameters->DDGIProbeOffsets = VolProxy->ProbesOffsetsUAV ? VolProxy->ProbesOffsetsUAV : FDDGIVolumeSceneProxy::GetDummyUAV();
+
+		float groupSizeX = 8.f;
+		float groupSizeY = 4.f;
+
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+		uint32 numThreadsX = ProbeCount2D.X;
+		uint32 numThreadsY = ProbeCount2D.Y;
+		uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSizeX);
+		uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSizeY);
+
+		FComputeShaderUtils::AddPass(
+			GraphBuilder,
+			RDG_EVENT_NAME("DDGI Probe Relocation"),
+			ComputeShader,
+			PassParameters,
+			FIntVector(numGroupsX, numGroupsY, 1)
+		);
+
+		// UAV barrier for ProbesOffsets
+		FTexture2DRHIRef offsetsTex = VolProxy->ProbesOffsetsTex;
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI Probe Relocation UAV Barrier"),
+			GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+			ERDGPassFlags::Compute,
+			[offsetsTex](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, offsetsTex);
+			}
+		);
+	}
+
+	void DDGIUpdateVolume_RenderThread_ClassifyProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& randomRotation, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+	{
+		// get the permuted shader
+		FDDGIProbesClassify::FPermutationDomain PermutationVector;
+		PermutationVector.Set<FDDGIProbesClassify::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+		PermutationVector.Set <FDDGIProbesClassify::FDebugFormatRadiance>(highBitCount);
+		PermutationVector.Set <FDDGIProbesClassify::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+		FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		TShaderMapRef<FDDGIProbesClassify> ComputeShader(ShaderMap, PermutationVector);
+
+		// set up the shader parameters
+		FDDGIProbesClassify::FParameters DefaultPassParameters;
+		FDDGIProbesClassify::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIProbesClassify::FParameters>();
+		*PassParameters = DefaultPassParameters;
+
+		// calculate grid spacing based on size (scale) and probe count
+		// regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+		FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+		FVector probeGridSpacing;
+		probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+		probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+		probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+		PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+		PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+		PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+		PassParameters->DDGIVolume_probeBackfaceThreshold = VolProxy->ComponentData.ProbeBackfaceThreshold;
+		PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+
+		PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+		PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV;
+
+		// dispatch the CS
+		float groupSizeX = 8.f;
+		float groupSizeY = 4.f;
+
+		FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+		uint32 numThreadsX = ProbeCount2D.X;
+		uint32 numThreadsY = ProbeCount2D.Y;
+		uint32 numGroupsX = (UINT)ceil((float)numThreadsX / groupSizeX);
+		uint32 numGroupsY = (UINT)ceil((float)numThreadsY / groupSizeY);
+
+		FComputeShaderUtils::AddPass(
+			GraphBuilder,
+			RDG_EVENT_NAME("DDGI Probe Classification"),
+			ComputeShader,
+			PassParameters,
+			FIntVector(numGroupsX, numGroupsY, 1)
+		);
+
+		// UAV barrier for ProbesStates
+		FTexture2DRHIRef statesTex = VolProxy->ProbesStatesTex;
+		GraphBuilder.AddPass(
+			RDG_EVENT_NAME("DDGI Probe Classification UAV Barrier"),
+			GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+			ERDGPassFlags::Compute,
+			[statesTex](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.TransitionResource(EResourceTransitionAccess::ERWBarrier, EResourceTransitionPipeline::EComputeToCompute, statesTex);
+			}
+		);
+	}
+
+} // namespace DDGIVolumeUpdate
+
+#undef LOCTEXT_NAMESPACE
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.h
new file mode 100644
index 00000000000..d4f5e2045f8
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeUpdate.h
@@ -0,0 +1,27 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+
+class FViewInfo;
+class FRDGBuilder;
+class UDDGIVolumeComponent;
+class FScene;
+
+namespace DDGIVolumeUpdate
+{
+	void Startup();
+	void Shutdown();
+
+	void DDGIUpdatePerFrame_RenderThread(const FScene& Scene, const FViewInfo& View,FRDGBuilder& GraphBuilder);
+}
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeVisualize.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeVisualize.cpp
new file mode 100644
index 00000000000..f7769cbbc39
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/DDGIVolumeVisualize.cpp
@@ -0,0 +1,433 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeComponent.h"
+#include "DDGIVolume.h"
+#include "DDGIVolumeUpdate.h"
+#include "RTXGIPluginSettings.h"
+#include "RenderGraphBuilder.h"
+#include "ShaderParameterStruct.h"
+#include "ShaderParameterUtils.h"
+#include "SystemTextures.h"
+
+// UE4 private interfaces
+#include "PostProcess/SceneRenderTargets.h"
+#include "SceneRendering.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+static TAutoConsoleVariable<int> CVarShowProbes(
+	TEXT("r.RTXGI.DDGIShowProbes"),
+	0,
+	TEXT("Show the probes within DDGI volumes.\n"),
+	ECVF_Cheat | ECVF_RenderThreadSafe);
+
+static TAutoConsoleVariable<float> CVarShowProbeDepthScale(
+	TEXT("r.RTXGI.DDGIShowProbeDepthScale"),
+	500.0f,
+	TEXT("The depth value is divided by this before being shown on the sphere.\n"),
+	ECVF_Cheat | ECVF_RenderThreadSafe);
+
+BEGIN_SHADER_PARAMETER_STRUCT(FVolumeVisualizeShaderParameters, )
+	SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradianceTexture)
+	SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistanceTexture)
+	SHADER_PARAMETER_TEXTURE(Texture2D, ProbeOffsets)
+	SHADER_PARAMETER_UAV(RWTexture2D<uint>, ProbeStates)
+	SHADER_PARAMETER_SAMPLER(SamplerState, ProbeSampler)
+	SHADER_PARAMETER(int, Mode)
+	SHADER_PARAMETER(float, ProbeRadius)
+	SHADER_PARAMETER(float, DepthScale)
+	SHADER_PARAMETER(int, VolumeProbeNumIrradianceTexels)
+	SHADER_PARAMETER(int, VolumeProbeNumDistanceTexels)
+	SHADER_PARAMETER(float, VolumeProbeIrradianceEncodingGamma)
+	SHADER_PARAMETER(FVector, VolumePosition)
+	SHADER_PARAMETER(FVector, VolumeProbeGridSpacing)
+	SHADER_PARAMETER(FIntVector, VolumeProbeGridCounts)
+	SHADER_PARAMETER(FMatrix, WorldToClip)
+	SHADER_PARAMETER(FVector, CameraPosition)
+	SHADER_PARAMETER(float, PreExposure)
+	SHADER_PARAMETER(int32, ShouldUsePreExposure)
+	SHADER_PARAMETER(FIntVector, VolumeProbeScrollOffsets)
+	RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+class FVolumeVisualizeShaderVS : public FGlobalShader
+{
+public:
+	DECLARE_GLOBAL_SHADER(FVolumeVisualizeShaderVS);
+	SHADER_USE_PARAMETER_STRUCT(FVolumeVisualizeShaderVS, FGlobalShader);
+
+	using FParameters = FVolumeVisualizeShaderParameters;
+
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+	}
+};
+
+class FVolumeVisualizeShaderPS : public FGlobalShader
+{
+public:
+	DECLARE_GLOBAL_SHADER(FVolumeVisualizeShaderPS);
+	SHADER_USE_PARAMETER_STRUCT(FVolumeVisualizeShaderPS, FGlobalShader);
+
+	using FParameters = FVolumeVisualizeShaderParameters;
+
+	class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+	class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+	using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling>;
+
+	static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+	{
+		FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+		OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+		// needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+		//OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+	}
+
+	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+	{
+		return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+	}
+};
+
+IMPLEMENT_GLOBAL_SHADER(FVolumeVisualizeShaderVS, "/Plugin/RTXGI/Private/VisualizeDDGIProbes.usf", "VisualizeDDGIProbesVS", SF_Vertex);
+IMPLEMENT_GLOBAL_SHADER(FVolumeVisualizeShaderPS, "/Plugin/RTXGI/Private/VisualizeDDGIProbes.usf", "VisualizeDDGIProbesPS", SF_Pixel);
+
+/**
+* Probe sphere vertex buffer. Defines a sphere of unit size.
+*/
+template<int32 NumSphereSides, int32 NumSphereRings, typename VectorType>
+class TDDGIProbeSphereVertexBuffer : public FVertexBuffer
+{
+public:
+
+	int32 GetNumRings() const
+	{
+		return NumSphereRings;
+	}
+
+	/**
+	* Initialize the RHI for this rendering resource
+	*/
+	void InitRHI() override
+	{
+		const int32 NumSides = NumSphereSides;
+		const int32 NumRings = NumSphereRings;
+		const int32 NumVerts = (NumSides + 1) * (NumRings + 1);
+
+		const float RadiansPerRingSegment = PI / (float)NumRings;
+		float Radius = 1;
+
+		TArray<VectorType, TInlineAllocator<NumRings + 1> > ArcVerts;
+		ArcVerts.Empty(NumRings + 1);
+		// Calculate verts for one arc
+		for (int32 i = 0; i < NumRings + 1; i++)
+		{
+			const float Angle = i * RadiansPerRingSegment;
+			ArcVerts.Add(FVector(0.0f, FMath::Sin(Angle), FMath::Cos(Angle)));
+		}
+
+		TResourceArray<VectorType, VERTEXBUFFER_ALIGNMENT> Verts;
+		Verts.Empty(NumVerts);
+		// Then rotate this arc NumSides + 1 times.
+		const FVector Center = FVector(0, 0, 0);
+		for (int32 s = 0; s < NumSides + 1; s++)
+		{
+			FRotator ArcRotator(0, 360.f * ((float)s / NumSides), 0);
+			FRotationMatrix ArcRot(ArcRotator);
+
+			for (int32 v = 0; v < NumRings + 1; v++)
+			{
+				const int32 VIx = (NumRings + 1) * s + v;
+				Verts.Add(Center + Radius * ArcRot.TransformPosition(ArcVerts[v]));
+			}
+		}
+
+		NumSphereVerts = Verts.Num();
+		uint32 Size = Verts.GetResourceDataSize();
+
+		// Create vertex buffer. Fill buffer with initial data upon creation
+		FRHIResourceCreateInfo CreateInfo(&Verts);
+		VertexBufferRHI = RHICreateVertexBuffer(Size, BUF_Static, CreateInfo);
+	}
+
+	int32 GetVertexCount() const { return NumSphereVerts; }
+
+	/**
+	* Calculates the world transform for a sphere.
+	* @param OutTransform - The output world transform.
+	* @param Sphere - The sphere to generate the transform for.
+	* @param PreViewTranslation - The pre-view translation to apply to the transform.
+	* @param bConservativelyBoundSphere - when true, the sphere that is drawn will contain all positions in the analytical sphere,
+	*		 Otherwise the sphere vertices will lie on the analytical sphere and the positions on the faces will lie inside the sphere.
+	*/
+	void CalcTransform(FVector4& OutPosAndScale, const FSphere& Sphere, const FVector& PreViewTranslation, bool bConservativelyBoundSphere = true)
+	{
+		float Radius = Sphere.W;
+		if (bConservativelyBoundSphere)
+		{
+			const int32 NumRings = NumSphereRings;
+			const float RadiansPerRingSegment = PI / (float)NumRings;
+
+			// Boost the effective radius so that the edges of the sphere approximation lie on the sphere, instead of the vertices
+			Radius /= FMath::Cos(RadiansPerRingSegment);
+		}
+
+		const FVector Translate(Sphere.Center + PreViewTranslation);
+		OutPosAndScale = FVector4(Translate, Radius);
+	}
+
+private:
+	int32 NumSphereVerts;
+};
+
+/**
+* Probe sphere index buffer.
+*/
+template<int32 NumSphereSides, int32 NumSphereRings>
+class TDDGIProbeSphereIndexBuffer : public FIndexBuffer
+{
+public:
+	/**
+	* Initialize the RHI for this rendering resource
+	*/
+	void InitRHI() override
+	{
+		const int32 NumSides = NumSphereSides;
+		const int32 NumRings = NumSphereRings;
+		TResourceArray<uint16, INDEXBUFFER_ALIGNMENT> Indices;
+
+		// Add triangles for all the vertices generated
+		for (int32 s = 0; s < NumSides; s++)
+		{
+			const int32 a0start = (s + 0) * (NumRings + 1);
+			const int32 a1start = (s + 1) * (NumRings + 1);
+
+			for (int32 r = 0; r < NumRings; r++)
+			{
+				Indices.Add(a0start + r + 0);
+				Indices.Add(a1start + r + 0);
+				Indices.Add(a0start + r + 1);
+				Indices.Add(a1start + r + 0);
+				Indices.Add(a1start + r + 1);
+				Indices.Add(a0start + r + 1);
+			}
+		}
+
+		NumIndices = Indices.Num();
+		const uint32 Size = Indices.GetResourceDataSize();
+		const uint32 Stride = sizeof(uint16);
+
+		// Create index buffer. Fill buffer with initial data upon creation
+		FRHIResourceCreateInfo CreateInfo(&Indices);
+		IndexBufferRHI = RHICreateIndexBuffer(Stride, Size, BUF_Static, CreateInfo);
+	}
+
+	int32 GetIndexCount() const { return NumIndices; };
+
+private:
+	int32 NumIndices;
+};
+
+struct FVisualDDGIProbesVertex
+{
+	FVector4 Position;
+	FVisualDDGIProbesVertex() {}
+	FVisualDDGIProbesVertex(const FVector4& InPosition) : Position(InPosition) {}
+};
+
+class FVisualizeDDGIProbesVertexDeclaration : public FRenderResource
+{
+public:
+
+	FVertexDeclarationRHIRef VertexDeclarationRHI;
+
+	virtual ~FVisualizeDDGIProbesVertexDeclaration() {}
+
+	virtual void InitRHI() override
+	{
+		FVertexDeclarationElementList Elements;
+		uint16 Stride = sizeof(FVisualDDGIProbesVertex);
+		Elements.Add(FVertexElement(0, STRUCT_OFFSET(FVisualDDGIProbesVertex, Position), VET_Float4, 0, Stride));
+		VertexDeclarationRHI = PipelineStateCache::GetOrCreateVertexDeclaration(Elements);
+	}
+
+	virtual void ReleaseRHI() override
+	{
+		VertexDeclarationRHI.SafeRelease();
+	}
+};
+
+TGlobalResource<FVisualizeDDGIProbesVertexDeclaration> GVisualizeDDGIProbesVertexDeclaration;
+TGlobalResource<TDDGIProbeSphereVertexBuffer<36, 24, FVector4>> GDDGIProbeSphereVertexBuffer;
+TGlobalResource<TDDGIProbeSphereIndexBuffer<36, 24>> GDDGIProbeSphereIndexBuffer;
+
+void FDDGIVolumeSceneProxy::RenderVisualization_RenderThread(const FScene& Scene, const FSceneRenderTargets& SceneContext, const FViewInfo& View, FRHICommandListImmediate& RHICmdList)
+{
+	check(IsInRenderingThread() || IsInParallelRenderingThread());
+
+	int mode = CVarShowProbes.GetValueOnRenderThread();
+	if (mode < 1 || mode > 3)
+		return;
+
+	float probeRadius = GetDefault<URTXGIPluginSettings>()->DebugProbeRadius;
+	float depthScale = CVarShowProbeDepthScale.GetValueOnRenderThread();
+
+	FRDGBuilder GraphBuilder(RHICmdList);
+
+	// Get other things we'll need for all proxies
+	FIntRect ViewRect = View.ViewRect;
+	FRDGTextureRef SceneColorTexture = GraphBuilder.RegisterExternalTexture(SceneContext.GetSceneColor());
+	FRDGTextureRef SceneDepthTexture = GraphBuilder.RegisterExternalTexture(SceneContext.SceneDepthZ);
+
+	for (FDDGIVolumeSceneProxy* proxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+	{
+		if (proxy->OwningScene != &Scene)
+			continue;
+
+		// get shader permutation
+		FVolumeVisualizeShaderVS::FPermutationDomain PermutationVectorVS;
+		PermutationVectorVS.Set<FVolumeVisualizeShaderVS::FEnableRelocation>(proxy->ComponentData.EnableProbeRelocation);
+		PermutationVectorVS.Set<FVolumeVisualizeShaderVS::FEnableScrolling>(proxy->ComponentData.EnableProbeScrolling);
+
+		FVolumeVisualizeShaderPS::FPermutationDomain PermutationVectorPS;
+		PermutationVectorPS.Set<FVolumeVisualizeShaderPS::FEnableRelocation>(proxy->ComponentData.EnableProbeRelocation);
+		PermutationVectorPS.Set<FVolumeVisualizeShaderPS::FEnableScrolling>(proxy->ComponentData.EnableProbeScrolling);
+
+		FGlobalShaderMap* GlobalShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+		TShaderMapRef<FVolumeVisualizeShaderVS> VertexShader(GlobalShaderMap, PermutationVectorVS);
+		TShaderMapRef<FVolumeVisualizeShaderPS> PixelShader(GlobalShaderMap, PermutationVectorPS);
+
+		// frustum culling
+		FVector ProxyPosition = proxy->ComponentData.Transform.GetLocation();
+		FVector ProxyScale = proxy->ComponentData.Transform.GetScale3D();
+		FVector ProxyExtent = ProxyScale * 100.0f;
+		if (!View.ViewFrustum.IntersectBox(ProxyPosition, ProxyExtent))
+			continue;
+
+		// set parameters
+		FVolumeVisualizeShaderParameters DefaultPassParameters;
+		FVolumeVisualizeShaderParameters* PassParameters = GraphBuilder.AllocParameters<FVolumeVisualizeShaderParameters>();
+		*PassParameters = DefaultPassParameters;
+		
+		PassParameters->ProbeIrradianceTexture = proxy->ProbesIrradianceTex;
+		PassParameters->ProbeDistanceTexture = proxy->ProbesDistanceTex;
+		PassParameters->ProbeOffsets = proxy->ProbesOffsetsTex;
+		PassParameters->ProbeStates = proxy->ProbesStatesUAV ? proxy->ProbesStatesUAV: FDDGIVolumeSceneProxy::GetDummyUAV();
+		PassParameters->ProbeRadius = probeRadius;
+		PassParameters->DepthScale = depthScale;
+		PassParameters->WorldToClip = View.ViewMatrices.GetViewProjectionMatrix();
+		PassParameters->CameraPosition = View.ViewLocation;
+
+		PassParameters->ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+		PassParameters->PreExposure = View.PreExposure;
+
+		PassParameters->VolumeProbeScrollOffsets = proxy->ComponentData.ProbeScrollOffsets;
+
+		PassParameters->ProbeSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+		PassParameters->Mode = mode;
+		PassParameters->VolumeProbeIrradianceEncodingGamma = proxy->ComponentData.ProbeIrradianceEncodingGamma;
+		PassParameters->VolumePosition = proxy->ComponentData.Transform.GetLocation();
+
+		FVector volumeSize = proxy->ComponentData.Transform.GetScale3D() * 200.0f;
+		FVector probeGridSpacing;
+		probeGridSpacing.X = volumeSize.X / float(proxy->ComponentData.ProbeCounts.X);
+		probeGridSpacing.Y = volumeSize.Y / float(proxy->ComponentData.ProbeCounts.Y);
+		probeGridSpacing.Z = volumeSize.Z / float(proxy->ComponentData.ProbeCounts.Z);
+		PassParameters->VolumeProbeGridSpacing = probeGridSpacing;
+
+		PassParameters->VolumeProbeGridCounts = proxy->ComponentData.ProbeCounts;
+
+		PassParameters->VolumeProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+		PassParameters->VolumeProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+
+		PassParameters->RenderTargets[0] = FRenderTargetBinding(SceneColorTexture, ERenderTargetLoadAction::ELoad);
+		PassParameters->RenderTargets.DepthStencil = FDepthStencilBinding(SceneDepthTexture, ERenderTargetLoadAction::ELoad, ERenderTargetLoadAction::ENoAction, FExclusiveDepthStencil::DepthWrite_StencilNop);
+
+		uint32 NumInstances = uint32(proxy->ComponentData.ProbeCounts.X * proxy->ComponentData.ProbeCounts.Y * proxy->ComponentData.ProbeCounts.Z);
+
+		GraphBuilder.AddPass(
+			Forward<FRDGEventName>(RDG_EVENT_NAME("DDGI Visualize Probes")),
+			PassParameters,
+			ERDGPassFlags::Raster,
+			[PassParameters, GlobalShaderMap, VertexShader, PixelShader, ViewRect, NumInstances](FRHICommandList& RHICmdList)
+			{
+				RHICmdList.SetViewport(ViewRect.Min.X, ViewRect.Min.Y, 0.0f, ViewRect.Max.X, ViewRect.Max.Y, 1.0f);
+
+				FGraphicsPipelineStateInitializer GraphicsPSOInit;
+				RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);
+
+				GraphicsPSOInit.RasterizerState = TStaticRasterizerState<FM_Solid, CM_CW>::GetRHI();
+				GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState<true, CF_DepthNearOrEqual>::GetRHI();
+				GraphicsPSOInit.BlendState = TStaticBlendStateWriteMask<CW_RGB, CW_RGBA>::GetRHI();
+
+				GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GVisualizeDDGIProbesVertexDeclaration.VertexDeclarationRHI;
+				GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.GetVertexShader();
+				GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.GetPixelShader();
+				GraphicsPSOInit.PrimitiveType = PT_TriangleList;
+				SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);
+
+				SetShaderParameters(RHICmdList, VertexShader, VertexShader.GetVertexShader(), *PassParameters);
+				SetShaderParameters(RHICmdList, PixelShader, PixelShader.GetPixelShader(), *PassParameters);
+
+				RHICmdList.SetStreamSource(0, GDDGIProbeSphereVertexBuffer.VertexBufferRHI, 0);
+				RHICmdList.DrawIndexedPrimitive(GDDGIProbeSphereIndexBuffer.IndexBufferRHI, 0, 0, GDDGIProbeSphereVertexBuffer.GetVertexCount(), 0, GDDGIProbeSphereIndexBuffer.GetIndexCount() / 3, NumInstances);
+			}
+		);
+	}
+
+	GraphBuilder.Execute();
+}
+#else
+void FDDGIVolumeSceneProxy::RenderVisualization_RenderThread(const FScene& Scene, const FSceneRenderTargets& SceneContext, const FViewInfo& View, FRHICommandListImmediate& RHICmdList)
+{
+
+}
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+FTexture2DRHIRef FDDGIVolumeSceneProxy::GetDummyTex()
+{
+	// Make sure the dummy UAV exists
+	if (DummyUAV == nullptr)
+	{
+		FRHIResourceCreateInfo createInfo(TEXT("DDGIDummyUAV"));
+		DummyTex = RHICreateTexture2D(4, 4, EPixelFormat::PF_B8G8R8A8, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+		DummyUAV = RHICreateUnorderedAccessView(DummyTex, 0);
+	}
+
+	return DummyTex;
+}
+
+FUnorderedAccessViewRHIRef FDDGIVolumeSceneProxy::GetDummyUAV()
+{
+	GetDummyTex();
+	return DummyUAV;
+}
+
+// TODO: need to compile out the delegate for visualization in shipping builds!
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPlugin.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPlugin.cpp
new file mode 100644
index 00000000000..81e7fddb15f
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPlugin.cpp
@@ -0,0 +1,60 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "RTXGIPlugin.h"
+
+#include "Modules/ModuleManager.h"
+#include "Interfaces/IPluginManager.h"
+#include "Tickable.h"
+
+#include "DDGIVolumeUpdate.h"
+#include "DDGIVolumeComponent.h"
+
+#include "Misc/Paths.h"
+#include "ShaderCore.h"
+
+#define LOCTEXT_NAMESPACE "FRTXGIPlugin"
+
+void FRTXGIPlugin::StartupDDGI()
+{
+	DDGIVolumeUpdate::Startup();
+	UDDGIVolumeComponent::Startup();
+}
+
+void FRTXGIPlugin::ShutdownDDGI()
+{
+	DDGIVolumeUpdate::Shutdown();
+	UDDGIVolumeComponent::Shutdown();
+}
+
+void FRTXGIPlugin::StartupModule()
+{
+    // Get the base directory of this plugin
+    FString BaseDir = IPluginManager::Get().FindPlugin(GetModularFeatureName())->GetBaseDir();
+
+	// register the shader directory
+	FString PluginShaderDir = FPaths::Combine(BaseDir, TEXT("Shaders"));
+	FString PluginMapping = TEXT("/Plugin/") + GetModularFeatureName();
+	AddShaderSourceDirectoryMapping(PluginMapping, PluginShaderDir);
+
+	StartupDDGI();
+}
+
+void FRTXGIPlugin::ShutdownModule()
+{
+    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
+    // we call this function before unloading the module.
+
+	ShutdownDDGI();
+}
+
+#undef LOCTEXT_NAMESPACE
+
+IMPLEMENT_MODULE(FRTXGIPlugin, RTXGI)
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.cpp
new file mode 100644
index 00000000000..e567ddbed0d
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.cpp
@@ -0,0 +1,45 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "RTXGIPluginSettings.h"
+#include "RTXGIPlugin.h"
+#include "DDGIVolumeComponent.h"
+
+#define LOCTEXT_NAMESPACE "RTXGIPlugin"
+
+#if WITH_EDITOR
+
+void URTXGIPluginSettings::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
+{
+	Super::PostEditChangeProperty(PropertyChangedEvent);
+
+	// tell the scene proxies about the irradiance bit change
+	if (PropertyChangedEvent.MemberProperty)
+	{
+		if (PropertyChangedEvent.MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(URTXGIPluginSettings, IrradianceBits))
+			FDDGIVolumeSceneProxy::OnIrradianceBitsChange();
+	}
+}
+
+FText URTXGIPluginSettings::GetSectionText() const
+{
+	return LOCTEXT("SettingsDisplayName", "RTXGI");
+}
+
+#endif	// WITH_EDITOR
+
+URTXGIPluginSettings::URTXGIPluginSettings()
+{
+	CategoryName = TEXT("Plugins");
+	SectionName  = TEXT("RTXGI");
+}
+
+#undef LOCTEXT_NAMESPACE
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.h
new file mode 100644
index 00000000000..2f4515c760f
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Private/RTXGIPluginSettings.h
@@ -0,0 +1,50 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Engine/EngineTypes.h"
+#include "Engine/DeveloperSettings.h"
+#include "RTXGIPluginSettings.generated.h"
+
+UENUM()
+enum class EDDGIIrradianceBits : uint8
+{
+	n10 UMETA(DisplayName = "10 bit"),
+	n32 UMETA(DisplayName = "32 bit (for extended luminance range rendering)")
+};
+
+/**
+ * Configure the RTXGI plug-in.
+ */
+UCLASS(config=Engine, defaultconfig)
+class URTXGIPluginSettings : public UDeveloperSettings
+{
+	GENERATED_BODY()
+
+public:
+	URTXGIPluginSettings();
+
+#if WITH_EDITOR
+	//~ UObject interface
+	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
+
+	//~ UDeveloperSettings interface
+	virtual FText GetSectionText() const override;
+#endif
+
+	/** The radius of the spheres that visualize the ddgi probes */
+	UPROPERTY(config, EditAnywhere, Category=DDGI)
+	EDDGIIrradianceBits IrradianceBits = EDDGIIrradianceBits::n10;
+
+	UPROPERTY(config, EditAnywhere, Category=DDGI)
+	float DebugProbeRadius = 5.0f;
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIBlueprintLibrary.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIBlueprintLibrary.h
new file mode 100644
index 00000000000..80cd5effbd7
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIBlueprintLibrary.h
@@ -0,0 +1,27 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "UObject/ObjectMacros.h"
+#include "Kismet/BlueprintFunctionLibrary.h"
+#include "DDGIBlueprintLibrary.generated.h"
+
+UCLASS(MinimalAPI, meta = (ScriptName = "DDGILibrary"))
+class UDDGIBlueprintLibrary : public UBlueprintFunctionLibrary
+{
+	GENERATED_UCLASS_BODY()
+
+	UFUNCTION(BlueprintCallable, Category = "DDGI")
+	static void ClearProbeData(
+		const UDDGIVolumeComponent* DDGIVolumeComponent
+	);
+};
\ No newline at end of file
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolume.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolume.h
new file mode 100644
index 00000000000..3d68d1a514e
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolume.h
@@ -0,0 +1,42 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+#include "CoreMinimal.h"
+#include "Engine/StaticMeshActor.h"
+#include "GameFramework/Actor.h"
+#include "DDGIVolume.generated.h"
+
+class UBillboardComponent;
+class UBoxComponent;
+class UDDGIVolumeComponent;
+
+UCLASS(HideCategories = (Navigation, Physics, Collision, Rendering, Tags, Cooking, Replication, Input, Actor, HLOD, Mobile, LOD))
+class RTXGI_API ADDGIVolume : public AActor
+{
+	GENERATED_UCLASS_BODY()
+
+public:
+	UPROPERTY();
+	UBoxComponent* BoxComponent;
+
+	UPROPERTY(EditAnywhere, Category = "GI");
+	UDDGIVolumeComponent* DDGIVolumeComponent;
+
+#if WITH_EDITORONLY_DATA
+	UPROPERTY()
+	UBillboardComponent* SpriteComponent;
+#endif // WITH_EDITORONLY_DATA
+
+#if WITH_EDITOR
+	void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override final;
+	void PostEditMove(bool bFinished) override final;
+#endif
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolumeComponent.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolumeComponent.h
new file mode 100644
index 00000000000..8c7246735e7
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/DDGIVolumeComponent.h
@@ -0,0 +1,316 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+#include "CoreMinimal.h"
+#include "UObject/ObjectMacros.h"
+#include "Engine/EngineTypes.h"
+#include "Components/SceneComponent.h"
+#include "RHI.h"
+#include "RHIResources.h"
+#include "DDGIVolumeComponent.generated.h"
+
+class FRDGBuilder;
+class FRHICommandListImmediate;
+class FScene;
+class FSceneInterface;
+class FSceneRenderTargets;
+class FViewInfo;
+
+// This needs to match the shader code in ProbeBlendingCS.usf
+UENUM()
+enum class EDDGIRaysPerProbe : uint8
+{
+	n144 UMETA(DisplayName = "144"),
+	n288 UMETA(DisplayName = "288"),
+	n432 UMETA(DisplayName = "432"),
+	n576 UMETA(DisplayName = "576"),
+	n720 UMETA(DisplayName = "720"),
+	n864 UMETA(DisplayName = "864"),
+	n1008 UMETA(DisplayName = "1008"),
+
+	Count UMETA(Hidden)
+};
+
+struct FDDGITexturePixels
+{
+	uint32 w = 0;
+	uint32 h = 0;
+	uint32 stride = 0;
+	uint32 pixelFormat = 0;
+	TArray<uint8> pixels;
+	FTexture2DRHIRef textureCPU;
+};
+
+struct FDDGITextureLoadContext
+{
+	bool ReadyForLoad = false;
+	FDDGITexturePixels Irradiance;
+	FDDGITexturePixels Distance;
+	FDDGITexturePixels Offsets;
+	FDDGITexturePixels States;
+
+	void Clear()
+	{
+		*this = FDDGITextureLoadContext();
+	}
+};
+
+class RTXGI_API FDDGIVolumeSceneProxy
+{
+public:
+
+	/** Initialization constructor. */
+	FDDGIVolumeSceneProxy(FSceneInterface* InOwningScene)
+		: OwningScene(InOwningScene)
+	{
+	}
+
+	virtual ~FDDGIVolumeSceneProxy()
+	{
+
+		check(IsInRenderingThread() || IsInParallelRenderingThread());
+		AllProxiesReadyForRender_RenderThread.Remove(this);
+	}
+
+	static void RenderDiffuseLighting_RenderThread(
+		const FScene& InScene,
+		const FViewInfo& View,
+		FRDGBuilder& GraphBuilder,
+		FSceneRenderTargets& SceneContext
+	);
+
+	void ReallocateSurfaces_RenderThread(FRHICommandListImmediate& RHICmdList, bool highBitCount);
+	void ResetTextures_RenderThread(FRHICommandListImmediate& RHICmdList);
+
+	static void RenderVisualization_RenderThread(const FScene& Scene, const FSceneRenderTargets& SceneContext, const FViewInfo& View, FRHICommandListImmediate& RHICmdList);
+
+	static void OnIrradianceBitsChange();
+
+	static FDelegateHandle OnRenderVisualizationDelegateHandle;
+	static FDelegateHandle OnRenderDiffuseLightingDelegateHandle;
+
+	// data from the component
+	struct FComponentData
+	{
+		// A shared location cpp side for operational defines
+		static const bool c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER = true;
+
+		// It considers this many volumes that pass frustum culling when sampling GI for the scene.
+		static const int c_RTXGI_DDGI_MAX_SHADING_VOLUMES = 6;
+
+		static const EPixelFormat c_pixelFormatRadianceLowBitDepth = EPixelFormat::PF_G32R32F;
+		static const EPixelFormat c_pixelFormatRadianceHighBitDepth = EPixelFormat::PF_A32B32G32R32F;
+		static const EPixelFormat c_pixelFormatIrradianceLowBitDepth = EPixelFormat::PF_A2B10G10R10;
+		static const EPixelFormat c_pixelFormatIrradianceHighBitDepth = EPixelFormat::PF_A32B32G32R32F;
+		static const EPixelFormat c_pixelFormatDistance = EPixelFormat::PF_G32R32F;
+		static const EPixelFormat c_pixelFormatOffsets = EPixelFormat::PF_A16B16G16R16;
+		static const EPixelFormat c_pixelFormatStates = EPixelFormat::PF_R8_UINT;
+
+		// ProbeBlendingCS (.hlsl in SDK, .usf in plugin) needs this as a define so is a hard coded constant right now.
+		// We need that shader to not require that as a define. Then, we can make it a tuneable parameter on the volume.
+		// There should be a task on the SDK about this.
+		static const uint32 c_NumTexelsIrradiance = 6;
+		static const uint32 c_NumTexelsDistance = 14;
+
+		uint32 GetNumRaysPerProbe() const
+		{
+			switch (RaysPerProbe)
+			{
+				case EDDGIRaysPerProbe::n144: return 144;
+				case EDDGIRaysPerProbe::n288: return 288;
+				case EDDGIRaysPerProbe::n432: return 432;
+				case EDDGIRaysPerProbe::n576: return 576;
+				case EDDGIRaysPerProbe::n720: return 720;
+				case EDDGIRaysPerProbe::n864: return 864;
+				case EDDGIRaysPerProbe::n1008: return 1008;
+			}
+			check(false);
+			return 144;
+		}
+
+		EDDGIRaysPerProbe RaysPerProbe = EDDGIRaysPerProbe::n144;
+		float ProbeMaxRayDistance = 1000.0f;
+		FTransform	Transform = FTransform::Identity;
+		FLightingChannels LightingChannels;
+		FIntVector ProbeCounts = FIntVector(0); // 0 = invalid, will be written with valid counts before use
+		float ProbeDistanceExponent = 1.0f;
+		float ProbeIrradianceEncodingGamma = 1.0f;
+		float UpdatePriority = 1.0f;
+		float ProbeHysteresis = 0.0f;
+		float ProbeChangeThreshold = 0.0f;
+		float ProbeBrightnessThreshold = 0.0f;
+		float NormalBias = 0.0f;
+		float ViewBias = 0.0f;
+		float BlendDistance = 0.0f;
+		float ProbeBackfaceThreshold = 0.0f;
+		float ProbeMinFrontfaceDistance = 0.0f;
+		bool EnableProbeRelocation = false;
+		bool EnableProbeScrolling = false;
+		FIntVector ProbeScrollOffsets = FIntVector{ 0, 0, 0 };
+
+		// This is GetDDGIVolumeProbeCounts() from the SDK
+		FIntPoint Get2DProbeCount() const
+		{
+			return FIntPoint(
+				ProbeCounts.Y * ProbeCounts.Z,
+				ProbeCounts.X
+			);
+		}
+	};
+	FComponentData ComponentData;
+	FDDGITextureLoadContext TextureLoadContext;
+
+	FTexture2DRHIRef ProbesIrradianceTex;
+	FTexture2DRHIRef ProbesDistanceTex;
+	FTexture2DRHIRef ProbesOffsetsTex;
+	FTexture2DRHIRef ProbesStatesTex;
+
+	FUnorderedAccessViewRHIRef ProbesIrradianceUAV;
+	FUnorderedAccessViewRHIRef ProbesDistanceUAV;
+	FUnorderedAccessViewRHIRef ProbesOffsetsUAV;
+	FUnorderedAccessViewRHIRef ProbesStatesUAV;	
+
+	static TSet<FDDGIVolumeSceneProxy*> AllProxiesReadyForRender_RenderThread;
+	static TMap<const FSceneInterface*, float> SceneRoundRobinValue;
+
+	// to only render gi volumes in the scenes they are present in.
+	FSceneInterface* OwningScene;
+
+	static FTexture2DRHIRef GetDummyTex();
+	static FUnorderedAccessViewRHIRef GetDummyUAV();
+
+private:
+	static FTexture2DRHIRef DummyTex;
+	static FUnorderedAccessViewRHIRef DummyUAV;
+};
+
+UCLASS(HideCategories = (Tags, AssetUserData, Collision, Cooking, Transform, Rendering, Mobility, LOD))
+class RTXGI_API UDDGIVolumeComponent : public USceneComponent, public FSelfRegisteringExec
+{
+	GENERATED_UCLASS_BODY()
+
+protected:
+
+	void InitializeComponent() override final;
+
+	void Serialize(FArchive& Ar) override final;
+
+	//~ Begin UActorComponent Interface
+	virtual bool ShouldCreateRenderState() const override { return true; }
+	virtual void CreateRenderState_Concurrent(FRegisterComponentContext* Context) override;
+	virtual void DestroyRenderState_Concurrent() override;
+	//~ Begin UActorComponent Interface
+
+public:
+	void UpdateRenderThreadData();
+
+	static void Startup();
+	static void Shutdown();
+
+	/**
+	 * FExec interface
+	 */
+	virtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) override;
+
+	// Clears the probe textures on all volumes
+	UFUNCTION(exec)
+	void DDGIClearVolumes();
+
+public:
+
+	// Number of rays shot for each probe when updating probe data.
+	UPROPERTY(EditAnywhere, Category = "GI");
+	EDDGIRaysPerProbe RaysPerProbe = EDDGIRaysPerProbe::n288;
+
+	// Number of probes on each axis.
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "1"));
+	FIntVector ProbeCounts = FIntVector(8, 8, 8);
+
+	// Priority for scheduling updates to this volume's probes. Higher priority gets updated more often. Weighted round robin updating.
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0.001", ClampMax = "10.0"));
+	float UpdatePriority = 1.f;
+
+	// Maximum distance a probe ray may travel. Shortening this can increase performance. If you shorten it too much, it can miss geometry.
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+	float ProbeMaxRayDistance = 100000.0f;
+
+	// Controls the influence of new rays when updating each probe. Values towards 1 will keep history longer, while values towards 0 will be more responsive to current values.
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0", ClampMax = "1"));
+	float ProbeHysteresis = 0.97f;
+
+	// Bias values for Indirect Lighting
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+	float ViewBias = 40.0f;
+
+	// Bias values for Indirect Lighting
+	UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+	float NormalBias = 10.0f;
+
+	// Objects with overlapping channel flags will receive lighting from this volume
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GI")
+		FLightingChannels LightingChannels;
+
+	// The distance in world units that this volume blends to a volume it overlaps, or fades out.
+	UPROPERTY(EditAnywhere, Category = "GI");
+	float VolumeBlendDistance = 20.0f;
+
+	// If true, probes will attempt to relocate within their cell to leave geometry.
+	UPROPERTY(EditAnywhere, Category = "GI");
+	bool EnableProbeRelocation = true;
+
+	// If true, probes will keep their same position in world space as the volume moves around. Useful for moving volumes to have more temporally stable probes.
+	UPROPERTY(EditAnywhere, Category = "GI");
+	bool EnableProbeScrolling = false;
+
+
+
+
+	// --- "Advanced" properties below aka things people shouldn't have to touch
+
+	// Exponent for depth testing. A high value will rapidly react to depth discontinuities, but risks causing banding.
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	float probeDistanceExponent = 50.f;
+
+	// Irradiance blending happens in post-tonemap space
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	float probeIrradianceEncodingGamma = 5.f;
+
+	// A threshold ratio used during probe radiance blending that determines if a large lighting change has happened.
+	// If the max color component difference is larger than this threshold, the hysteresis will be reduced.
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	float probeChangeThreshold = 0.2f;
+
+	// A threshold value used during probe radiance blending that determines the maximum allowed difference in brightness
+	// between the previous and current irradiance values. This prevents impulses from drastically changing a
+	// texel's irradiance in a single update cycle.
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	float probeBrightnessThreshold = 2.0f;
+
+	// Probe relocation moves probes that see front facing triangles closer than this value
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0"));
+	float ProbeMinFrontfaceDistance = 10.0f;
+
+	// Probe relocation and state classifier assume probes with more than this ratio of backface hits are inside of geometry.
+	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0", ClampMax = "1"));
+	float ProbeBackfaceThreshold = 0.25f;
+
+	UPROPERTY(VisibleAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	FVector LastOrigin = FVector{ 0.0f, 0.0f, 0.0f };
+
+	UPROPERTY(VisibleAnywhere, AdvancedDisplay, Category = "GI Advanced");
+	FIntVector ProbeScrollOffset = FIntVector{ 0, 0, 0 };
+
+	FDDGIVolumeSceneProxy* SceneProxy;
+
+	// When loading a volume we get data for it's textures but don't have a scene proxy yet.
+	// This is where that data is stored until the scene proxy is ready to take it.
+	FDDGITextureLoadContext LoadContext;
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/RTXGIPlugin.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/RTXGIPlugin.h
new file mode 100644
index 00000000000..fc36f2f6c62
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/Public/RTXGIPlugin.h
@@ -0,0 +1,38 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once 
+
+#include "CoreMinimal.h"
+#include "Modules/ModuleManager.h"
+#include "Features/IModularFeatures.h"
+#include "Modules/ModuleInterface.h"
+
+/**
+* The public interface of the IRTXGIPlugin
+*/
+class FRTXGIPlugin : public IModuleInterface, public IModularFeature
+{
+public:
+    static FString GetModularFeatureName()
+    {
+        static FString FeatureName = FString(TEXT("RTXGI"));
+        return FeatureName;
+    }
+
+	/** IModuleInterface implementation */
+	virtual void StartupModule() override;
+	virtual void ShutdownModule() override;
+
+private:
+	void StartupDDGI();
+	void ShutdownDDGI();
+};
+
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/RTXGI.Build.cs b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/RTXGI.Build.cs
new file mode 100644
index 00000000000..3bb307dbdca
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI/RTXGI.Build.cs
@@ -0,0 +1,59 @@
+/*
+* Copyright (c) 2019-2020, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+using UnrealBuildTool;
+using System.IO;
+
+public class RTXGI : ModuleRules
+{
+	private string ModulePath
+	{
+		get { return ModuleDirectory; }
+	}
+
+	public RTXGI(ReadOnlyTargetRules Target) : base(Target)
+	{
+		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
+
+		if (Target.Platform == UnrealTargetPlatform.Win64)
+		{
+			PublicDefinitions.Add("WITH_RTXGI=1");
+		}
+		else
+		{
+			PublicDefinitions.Add("WITH_RTXGI=0");
+		}
+
+		PrivateDependencyModuleNames.AddRange(new string[]
+		{
+			"CoreUObject",
+			"Engine",
+			"RenderCore",
+			"Renderer",
+			"RHI",
+		});
+
+		PrivateIncludePaths.AddRange(new string[]
+		{
+			"../../../../../Source/Runtime/Renderer/Private",
+		});
+
+		PublicDependencyModuleNames.AddRange(new string[]
+		{
+			"Core",
+			"Projects"
+		});
+
+		PublicIncludePaths.AddRange(new string[]
+		{
+			"../Shaders/Shared"
+		});
+	}
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/UpdatingSDK.txt b/Engine/Plugins/Runtime/Nvidia/RTXGI/UpdatingSDK.txt
new file mode 100644
index 00000000000..287d48f4262
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/UpdatingSDK.txt
@@ -0,0 +1,23 @@
+This is based on the RTXGI SDK hash below. Please update this text file if you update the SDK.
+bfcb16072306bc2e386116a0c06c055c57e86e5d
+
+Here are the instructions for updating the RTXGI SDK.
+
+The steps may change of course, if files are added, renamed, deleted from the SDK, so take this as a loose guide.
+
+Updating the SDK:
+* copy C:\gitlab\rtxgi-sdk\shaders\ddgi\* to C:\ue4\Engine\Plugins\Runtime\Nvidia\RTXGI\Shaders\Private\SDK\ddgi\*
+* rename those from hlsl to .ush and .usf as they were prior. (headers = ush, else = usf)
+* copy C:\gitlab\rtxgi-sdk\shaders\Common.hlsl to C:\ue4\Engine\Plugins\Runtime\Nvidia\RTXGI\Shaders\Private\SDK\Common.ush
+* copy C:\gitlab\rtxgi-sdk\include\RTXGI\ddgi\DDGIVolumeDefines.h and DDGIVolumeDescGPU.h to C:\ue4\Engine\Plugins\Runtime\Nvidia\RTXGI\Shaders\Private\SDK\ and rename them .ush
+* copy C:\gitlab\rtxgi-sdk\include\RTXGI\defines.h to C:\ue4\Engine\Plugins\Runtime\Nvidia\RTXGI\Shaders\Private\SDKDefines.ush and make sure the settings are correct for unreal (like handedness)
+
+There are changes in those shaders to make unreal happy, like changing how shader constants and resources are declared and interacted with. Also shader include directories. Check the diffs.
+
+Files of likely interest:
+* C:\ue4\Engine\Plugins\Runtime\Nvidia\RTXGI\Shaders\Private\
+ * ApplyLightingDeferred.usf is where diffuse irradiance is injected into the scene
+ * ProbeUpdateRGS.usf is where the rays for probe radiance and distance are shot.
+ * VisualizeDDGIProbes.usf is where the probe visualization (spheres) are rendered.
+* C:\UE4\Engine\Plugins\Runtime\Nvidia\RTXGI\Source\RTXGI\Private\
+ * this is where the CPU side logic is.
\ No newline at end of file
diff --git a/Engine/Source/Developer/Windows/ShaderFormatD3D/Private/D3DShaderCompiler.cpp b/Engine/Source/Developer/Windows/ShaderFormatD3D/Private/D3DShaderCompiler.cpp
index f6f908fba18..30b0f39cfb9 100644
--- a/Engine/Source/Developer/Windows/ShaderFormatD3D/Private/D3DShaderCompiler.cpp
+++ b/Engine/Source/Developer/Windows/ShaderFormatD3D/Private/D3DShaderCompiler.cpp
@@ -44,7 +44,7 @@ static int32 GD3DAllowRemoveUnused = 0;
 
 
 static int32 GD3DCheckForDoubles = 1;
-static int32 GD3DCheckForTypedUAVs = 1;
+static int32 GD3DCheckForTypedUAVs = 0;
 static int32 GD3DDumpAMDCodeXLFile = 0;
 
 static const uint32 GD3DMaximumNumUAVs = 8; // Limit for feature level 11.0
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
index 90b6e9dd495..55ad97ceb12 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
@@ -249,6 +249,32 @@ DECLARE_GPU_STAT(PostOpaqueExtensions);
 
 CSV_DEFINE_CATEGORY(LightCount, true);
 
+static FDeferredShadingDelegates::FPrepareRayTracingDelegate PrepareRayTracingDelegate;
+FDeferredShadingDelegates::FPrepareRayTracingDelegate& FDeferredShadingDelegates::OnPrepareRayTracing()
+{
+	return PrepareRayTracingDelegate;
+}
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+static FDeferredShadingDelegates::FRenderVisualizationDelegate RenderVisualizationDelegate;
+FDeferredShadingDelegates::FRenderVisualizationDelegate& FDeferredShadingDelegates::OnRenderVisualization()
+{
+	return RenderVisualizationDelegate;
+}
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+static FDeferredShadingDelegates::FRenderDiffuseLightingDelegate RenderDiffuseLightingDelegate;
+FDeferredShadingDelegates::FRenderDiffuseLightingDelegate& FDeferredShadingDelegates::OnRenderDiffuseLighting()
+{
+	return RenderDiffuseLightingDelegate;
+}
+
+static FDeferredShadingDelegates::FAskRaytracingPassEnabledDelegate AskRaytracingPassEnabledDelegate;
+FDeferredShadingDelegates::FAskRaytracingPassEnabledDelegate& FDeferredShadingDelegates::OnAskRaytracingPassEnabled()
+{
+	return AskRaytracingPassEnabledDelegate;
+}
+
 const TCHAR* GetDepthPassReason(bool bDitheredLODTransitionsUseStencil, EShaderPlatform ShaderPlatform)
 {
 	if (IsForwardShadingEnabled(ShaderPlatform))
@@ -1318,6 +1344,8 @@ bool FDeferredShadingSceneRenderer::DispatchRayTracingWorldUpdates(FRHICommandLi
 		PrepareRayTracingTranslucency(View, RayGenShaders);
 		PrepareRayTracingDebug(View, RayGenShaders);
 		PreparePathTracing(View, RayGenShaders);
+		FDeferredShadingDelegates::FPrepareRayTracingDelegate& PRTDelegate = FDeferredShadingDelegates::OnPrepareRayTracing();
+		PRTDelegate.Broadcast(View, RayGenShaders);
 
 		// Create ray tracing light list to obtain list of light function materials
 
@@ -3390,6 +3418,11 @@ bool AnyRayTracingPassEnabled(const FScene* Scene, const FViewInfo& View)
 	const bool bRayTracingShadows = CVarRayTracingShadows != nullptr && CVarRayTracingShadows->GetInt() > 0;
 	const bool bRayTracingStochasticRectLight = CVarStochasticRectLight != nullptr && CVarStochasticRectLight->GetInt() > 0;
 
+	// Give plugins a chance to say that they want raytracing
+	FDeferredShadingDelegates::FAskRaytracingPassEnabledDelegate& ARTPEDelegate = FDeferredShadingDelegates::OnAskRaytracingPassEnabled();
+	bool bOtherRayTracingEnabled = false;
+	ARTPEDelegate.Broadcast(bOtherRayTracingEnabled);
+
 	if (
 		ShouldRenderRayTracingAmbientOcclusion(View)
 		|| ShouldRenderRayTracingReflections(View)
@@ -3400,6 +3433,7 @@ bool AnyRayTracingPassEnabled(const FScene* Scene, const FViewInfo& View)
 		|| bRayTracingStochasticRectLight
 		|| View.RayTracingRenderMode == ERayTracingRenderMode::PathTracing
 		|| View.RayTracingRenderMode == ERayTracingRenderMode::RayTracingDebug
+		|| bOtherRayTracingEnabled
 		)
 	{
 		return true;
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
index 40b7de6d25c..02bd6a4abf5 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
@@ -28,6 +28,23 @@ class FRaytracingLightDataPacked;
 struct FSingleLayerWaterPassData;
 struct FHeightFogRenderingParameters;
 
+class RENDERER_API FDeferredShadingDelegates
+{
+public:
+	DECLARE_MULTICAST_DELEGATE_TwoParams(FPrepareRayTracingDelegate, const FViewInfo& /*View*/, TArray<FRHIRayTracingShader*>& /*OutRayGenShaders*/);
+	DECLARE_MULTICAST_DELEGATE_FourParams(FRenderDiffuseLightingDelegate, const FScene& /*InScene*/, const FViewInfo& /*View*/, FRDGBuilder& /*GraphBuilder*/, FSceneRenderTargets& /*SceneContext*/);
+	DECLARE_MULTICAST_DELEGATE_OneParam(FAskRaytracingPassEnabledDelegate, bool& /*bAnyRayTracingPassEnabled*/);
+
+	static FPrepareRayTracingDelegate& OnPrepareRayTracing();
+	static FRenderDiffuseLightingDelegate& OnRenderDiffuseLighting();
+	static FAskRaytracingPassEnabledDelegate& OnAskRaytracingPassEnabled();
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	DECLARE_MULTICAST_DELEGATE_FourParams(FRenderVisualizationDelegate, const FScene& /*InScene*/, const FSceneRenderTargets& /*SceneContext*/, const FViewInfo& /*View*/, FRHICommandListImmediate& /*RHICmdList*/);
+	static FRenderVisualizationDelegate& OnRenderVisualization();
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+};
+
 class FLightShaftsOutput
 {
 public:
diff --git a/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp b/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
index 3234a8ae364..83f4e41642f 100644
--- a/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
@@ -401,6 +401,10 @@ void FDeferredShadingSceneRenderer::RenderDiffuseIndirectAndAmbientOcclusion(FRH
 		}
 		else
 		{
+			// call into the delegate to let people inject diffuse lighting if they'd like to
+			FDeferredShadingDelegates::FRenderDiffuseLightingDelegate& RDLDelegate = FDeferredShadingDelegates::OnRenderDiffuseLighting();
+			RDLDelegate.Broadcast(*Scene, View, GraphBuilder, SceneContext);
+
 			// No need for denoising.
 			DenoiseMode = 0;
 		}
@@ -962,6 +966,12 @@ void FDeferredShadingSceneRenderer::RenderDeferredReflectionsAndSkyLighting(FRHI
 
 	GraphBuilder.Execute();
 
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	FDeferredShadingDelegates::FRenderVisualizationDelegate& PRVDelegate = FDeferredShadingDelegates::OnRenderVisualization();
+	for (int32 ViewIndexZ = 0; ViewIndexZ < Views.Num(); ViewIndexZ++)
+		PRVDelegate.Broadcast(*Scene, SceneContext, Views[ViewIndexZ], RHICmdList);
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
 	ResolveSceneColor(RHICmdList);
 }
 
diff --git a/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h b/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
index 93a6cd090d7..88f1dfed357 100644
--- a/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
+++ b/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
@@ -14,7 +14,7 @@
 
 #define RAY_TRACING_MAX_LIGHT_FUNCTIONS 16
 
-BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FRaytracingLightDataPacked, )
+BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FRaytracingLightDataPacked, RENDERER_API)
 	SHADER_PARAMETER(uint32, Count)
 	SHADER_PARAMETER(float, IESLightProfileInvCount)
 	SHADER_PARAMETER_TEXTURE(Texture2D, LTCMatTexture)
diff --git a/Engine/Source/Runtime/Renderer/Private/SystemTextures.h b/Engine/Source/Runtime/Renderer/Private/SystemTextures.h
index 260ef3dd273..129a37dbf23 100644
--- a/Engine/Source/Runtime/Renderer/Private/SystemTextures.h
+++ b/Engine/Source/Runtime/Renderer/Private/SystemTextures.h
@@ -11,7 +11,7 @@
 /**
  * Encapsulates the system textures used for scene rendering.
  */
-class FSystemTextures : public FRenderResource
+class RENDERER_API FSystemTextures : public FRenderResource
 {
 public:
 	FSystemTextures()
