

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dynamic Diffuse Global Illumination &mdash; RTXGI SDK 1.1  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/nvidia_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Unreal Engine 4 Plugin" href="UE4Plugin.html" />
    <link rel="prev" title="RTXGI SDK Overview" href="SDKOverview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> RTXGI SDK 1.1
          

          
            
            <img src="../_static/nvidia_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Index.html">User’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="License.html">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="Welcome.html">Welcome</a></li>
<li class="toctree-l2"><a class="reference internal" href="QuickStart.html">Quick Start</a></li>
<li class="toctree-l2"><a class="reference internal" href="Harness.html">Test Harness</a></li>
<li class="toctree-l2"><a class="reference internal" href="SDKOverview.html">RTXGI SDK Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dynamic Diffuse Global Illumination</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage-overview">Usage Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shaders">Shaders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#volumes">Volumes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#describing-a-volume">Describing a Volume</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-management">Resource Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-volume">Creating a Volume</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destroying-a-volume">Destroying a Volume</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#updating-a-volume">Updating a Volume</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#randomizing-the-sampling-rotation-and-updating-the-constant-buffer">Randomizing the Sampling Rotation and Updating the Constant Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#probe-ray-trace">Probe Ray Trace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#volume-movement">Volume Movement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#probe-irradiance-gamma">Probe Irradiance Gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compositing-indirect-lighting">Compositing Indirect Lighting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volume-blending">Volume Blending</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probe-state-classification">Probe State Classification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fixed-rays-for-relocation-and-classification">Fixed Rays for Relocation and Classification</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#early-access-features">Early Access Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#infinite-scrolling-volume-movement">Infinite Scrolling Volume Movement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="UE4Plugin.html">Unreal Engine 4 Plugin</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">RTXGI SDK 1.1</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="Index.html">User’s Guide</a> &raquo;</li>
        
      <li>Dynamic Diffuse Global Illumination</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="ddgi"></span><div class="section" id="dynamic-diffuse-global-illumination">
<h1>Dynamic Diffuse Global Illumination<a class="headerlink" href="#dynamic-diffuse-global-illumination" title="Permalink to this headline">¶</a></h1>
<p>Dynamic Diffuse Global Illumination (DDGI) is a global lighting algorithm that extends the traditional pre-computed irradiance probes approach. Lighting techniques built on traditional irradiance probes are commonly used today in real-time rendering (see popular commercial products and engines such as <a class="reference external" href="https://www.siliconstudio.co.jp/middleware/enlighten/en/">Enlighten</a>, <a class="reference external" href="https://unity3d.com/learn/tutorials/topics/graphics/probe-lighting">Unity</a>, and <a class="reference external" href="https://docs.unrealengine.com/en-us/Engine/Rendering/LightingAndShadows/IndirectLightingCache">Unreal Engine</a>); however, these irradiance probe solutions are unable to resolve the visibility of dynamic scene elements at runtime. The DDGI algorithm removes this restriction by employing GPU ray tracing and a fast probe update scheme to maintain per-probe irradiance <em>and</em> distance data at runtime for static <em>and</em> dynamic objects.</p>
<p>Similar to traditional irradiance probes, DDGI does not solve the complete global illumination problem, and is best used for the diffuse irradiance component of the full lighting equation. As a result of the underlying probe based data structure, the computed diffuse irradiance is inherently low frequency and can not capture fine high frequency occlusion details. For this reason, DDGI combines effectively with complimentary rendering techniques such as Ray Traced Ambient Occlusion (RTAO). To demonstrate this, RTAO is implemented and combined with DDGI in the Test Harness sample application. Head over to the <span class="xref std std-ref">Harness</span> section to learn more.</p>
<p>The remainder of this documentation focuses on the implementation of DDGI provided in this SDK. More information about Dynamic Diffuse Global Illumination can be found in the <a class="reference external" href="http://jcgt.org/published/0008/02/01/">academic publication</a> and <a class="reference external" href="https://www.gdcvault.com/play/1026182/">NVIDIA’s GDC 2019 “Dynamic Diffuse Global Illumination with Ray Traced Irradiance Fields”</a> talk.</p>
<div class="section" id="usage-overview">
<span id="ddgi-overview"></span><h2>Usage Overview<a class="headerlink" href="#usage-overview" title="Permalink to this headline">¶</a></h2>
<p>The computation of diffuse global illumination using the DDGI algorithm in this SDK is supported inside volumes of user defined size. This is functionality provided by the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> class, and supported by various helper functions in the <code class="docutils literal notranslate"><span class="pre">rtxgi</span></code> namespace.</p>
<p>The basic use pattern of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> for <strong>dynamic global illumination</strong> is as follows:</p>
<ol class="arabic">
<li><p>Create one or more <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> (see <a class="reference internal" href="#volumes">Volumes</a>).</p></li>
<li><p>Each Frame:</p>
<ol class="loweralpha">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update(...)</span></code></p>
<p>Note: this function call updates the volume’s random sampling pattern and constant buffer (see <a class="reference internal" href="#updating-a-volume">Updating a Volume</a>).</p>
</li>
<li><p>Trace rays for the volume’s probes (see <a class="reference internal" href="#probe-ray-trace">Probe Ray Trace</a>).</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes(...)</span></code></p>
<p>Note: this function call updates the irradiance and distance values for all probes in the volume based on the results from ray tracing (see <a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a>).</p>
</li>
<li><p>Sample the diffuse irradiance at a point in the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> with the <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeIrradiance(...)</span></code> HLSL function, and composite with direct illumination (see <a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a>).</p></li>
</ol>
</li>
<li><p>Destroy the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> on shutdown (see <a class="reference internal" href="#destroying-a-volume">Destroying a Volume</a>).</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Test Harness sample application implements the process described above in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/main.cpp</span></code>. The frame loop of Step 2 is implemented in the following places:</p>
<p>Line 226: <code class="docutils literal notranslate"><span class="pre">volume-&gt;Update(...)</span></code> <br/>
Line 234: <code class="docutils literal notranslate"><span class="pre">Harness::RayTraceProbes(...)</span></code>  <br/>
Line 244: <code class="docutils literal notranslate"><span class="pre">volume-&gt;UpdateProbes(...)</span></code>  <br/>
Line 295: <code class="docutils literal notranslate"><span class="pre">Harness::RenderIndirect(...)</span></code>  <br/></p>
</div>
<p>There are several alternate ways a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> may be used, depending on the constraints and performance requirements of the application and target platform. For example, one could create a volume and run a number of ray tracing iterations and probe updates at level load time to bake the current lighting conditions into the volume. This approach is not as dynamic as the pattern described above, but it eliminates the common practice of pre-computing several sets of probe irradiance textures for scenarios such as time of day changes at level transitions. This can result in substantial storage savings, and lighting that more accurately matches the time of day. This pattern is implemented as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Create one or more <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> (see <a class="reference internal" href="#volumes">Volumes</a>).</p></li>
<li><p>For N iterations (e.g. at level load or map transition)</p>
<ol class="loweralpha simple">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">DDGIVolume-&gt;Update(...)</span></code></p></li>
<li><p>Trace rays for the volume’s probes (see <a class="reference internal" href="#probe-ray-trace">Probe Ray Trace</a>)</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">DDGIVolume-&gt;UpdateProbes(...)</span></code></p></li>
</ol>
</li>
<li><p>Level Load / Map Transition Completes</p></li>
<li><p>Each Frame:</p>
<ol class="loweralpha simple">
<li><p>Sample the diffuse irradiance at a point in the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> with the <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeIrradiance(...)</span></code> HLSL function, and composite with direct illumination (see <a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a>).</p></li>
</ol>
</li>
<li><p>Level Load / Map Transition initiated. Go back to Step 2.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="configuration">
<span id="ddgi-config"></span><h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>The configuration of the DDGI implementation is primarily controlled through a set of defines found in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>. These defines are alsodiscussed in the relevant sections of this document. The following table provides an overview:</p>
<table class="colwidths-given docutils align-default" id="id2">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">DDGIVolumeDefines.h</span></code> Configuration</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 56%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Setting</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>More details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_SDK_MANAGED_RESOURCES</span></code></p></td>
<td><p>Set to 0 for the application to manage resources, and 1 for the SDK to manage resources.</p></td>
<td><p><a class="reference internal" href="#resource-management">Resource Management</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_RADIANCE</span></code></p></td>
<td><p>Set to 0 for radiance textures to use the <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32_FLOAT</span></code> format. <br/> Set to 1 for radiance texture to use the <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32B32A32_FLOAT</span></code> format. <br/> <br/> When radiance textures use the <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32_FLOAT</span></code> format, radiance is stored in <code class="docutils literal notranslate"><span class="pre">R11G11B10_UINT</span></code> format inside the 32-bit R channel, and distance is stored as a 32-bit float in the G channel. Using the larger <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32B32A32_FLOAT</span></code> format stores radiance in the first three channels, and distance in the fourth channel. This larger format can be useful to rule out the radiance bit depth as a source of visual errors or corruption.</p></td>
<td><p><a class="reference internal" href="#resource-management">Resource Management</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE</span></code></p></td>
<td><p>Set to 0 for irradiance textures to use the <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R10G10B10A2_UNORM</span></code> format. <br/> Set to 1 to use the larger <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32B32A32_FLOAT</span></code> format (useful when debugging).</p></td>
<td><p><a class="reference internal" href="#resource-management">Resource Management</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_OFFSETS</span></code></p></td>
<td><p>Set to 0 for offset textures to use <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R16G16B16A16_FLOAT</span></code>. <br/> Set to 1 for to use <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32B32A32_FLOAT</span></code> (useful when debugging).</p></td>
<td><p><a class="reference internal" href="#resource-management">Resource Management</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY</span></code></p></td>
<td><p>Set to 1 to use shared memory optimizations in the probe radiance and distance blending shaders.</p></td>
<td><p><a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_PROBE_INDEXING</span></code></p></td>
<td><p>Set to 1 to visualize probe indices for debugging. Requires <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE</span></code> to also be set to 1.</p></td>
<td><p><a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING</span></code></p></td>
<td><p>Set to 1 to override irradiance textures with debug coloring that visualizes probe octants.</p></td>
<td><p><a class="reference internal" href="#describing-a-volume">Describing a Volume</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING</span></code></p></td>
<td><p>Set to 1 to override irradiance textures with debug coloring that visualizes probe border copy indexing.</p></td>
<td><p><a class="reference internal" href="#describing-a-volume">Describing a Volume</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_COMPUTE_IRRADIANCE</span></code></p></td>
<td><p>A define used by the host application. Set to 1 to enable using DDGI to compute irradiance. See <code class="docutils literal notranslate"><span class="pre">samples/test-harness/shaders/Indirect.hlsl</span></code> in the Test Harness for an example.</p></td>
<td><p><a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE</span></code></p></td>
<td><p>A define used by the host application. Set to 1 to enable using DDGI to compute irradiance recursively for probe rays. See <code class="docutils literal notranslate"><span class="pre">samples/test-harness/shaders/ProbeTraceRGS.hlsl</span></code> in the Test Harness for an example.</p></td>
<td><p><a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_RELOCATION</span></code></p></td>
<td><p>Set to 1 to enable Probe Relocation.</p></td>
<td><p><a class="reference internal" href="#probe-offsets"><span class="std std-ref">Probe Relocation and Position Optimization</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_STATE_CLASSIFIER</span></code></p></td>
<td><p>Set to 1 to enable Probe Classification.</p></td>
<td><p><a class="reference internal" href="#probe-states"><span class="std std-ref">Probe State Classification</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_SCROLL</span></code></p></td>
<td><p>Set to 1 to enable Infinite Scrolling Volume Movement.</p></td>
<td><p><a class="reference internal" href="#infinite-scrolling-volume-movement">Infinite Scrolling Volume Movement</a></p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some of these configuration options are only used in the <span class="xref std std-ref">Harness</span>, but are provided in the SDK for convenience.</p>
</div>
</div>
<div class="section" id="shaders">
<span id="ddgi-shaders"></span><h2>Shaders<a class="headerlink" href="#shaders" title="Permalink to this headline">¶</a></h2>
<p>In addition to host side source code, the necessary DDGI shader code is provided in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/ddgi</span></code>. The following table provides a brief description of each shader file:</p>
<table class="colwidths-given docutils align-default" id="id3">
<caption><span class="caption-text">DDGI HLSL Shaders</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>File Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ProbeCommon.hlsl</span></code></p></td>
<td><p>Contains commonly used probe indexing, octahedral indexing, ray generation, and probe relocation/classification functions. This file can be included anywhere, since all resources are passed through function parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Irradiance.hlsl</span></code></p></td>
<td><p>Contains the helper functions used when sampling irradiance for arbitrary points in a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>. Include this shader file in a fullscreen Pixel Shader that is executed somewhere in the post-processing pipeline, and call the <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeIrradiance()</span></code> function. See <a class="reference internal" href="#computing-indirect-lighting-from-a-volume">Computing Indirect Lighting from a Volume</a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ProbeBlendingCS.hlsl</span></code></p></td>
<td><p>Compute shader code that blends radiance or distance values into the appropriate octahedral texture map. All probes of a volume are processed in parallel. This shader is dispatched by the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes()</span></code> function. See <a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ProbeBorderUpdateCS.hlsl</span></code></p></td>
<td><p>Compute shader code that updates the 1-texel border of irradiance or distance octahedral texture maps. All probes of a volume are processed in parallel. This shader is dispatched by the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes()</span></code> function. See <a class="reference internal" href="#probe-irradiance-and-distance-update">Probe Irradiance and Distance Update</a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ProbeRelocationCS.hlsl</span></code></p></td>
<td><p>Compute shader code that attempts to reposition probes if they are inside of geometry (e.g. walls). This shader is dispatched by the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::RelocateProbes()</span></code> function. See <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ProbeStateClassifierCS.hlsl</span></code></p></td>
<td><p>Compute shader code that classifies probes into various states for performance optimization. See <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="volumes">
<span id="ddgi-volumes"></span><h2>Volumes<a class="headerlink" href="#volumes" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is a volume of space within which irradiance queries at arbitrary world-space points are supported. The underlying data structure of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is a regular grid of probes (see the note below) that spans a volume’s extent, and is centered about a user defined volume origin. A <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> may cover the entire scene or some sub-volume of the scene, depending on the desired effect. Each probe is represented by an unwrapped octahedral texture map of irradiance and distance values for the set of directions  around that probe (also referred to as an irradiance field). At a high level, the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> provides the ability to:</p>
<ol class="arabic simple">
<li><p>Update the per-probe irradiance and filtered distance values</p></li>
<li><p>Compute the irradiance for arbitrary world-space locations within the volume</p></li>
</ol>
<p>Before creation, a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is described using a pair of descriptor structs that configure the various properites and resources of the volume. These structs are <code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code> and <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A regularly spaced probe grid is not strictly required. The probe grid can be adjusted using the per-probe offsets that are part of the <a class="reference internal" href="#probe-offsets"><span class="std std-ref">Probe Relocation and Position Optimization</span></a> feature.</p>
</div>
<div class="section" id="describing-a-volume">
<span id="ddgi-describevolume"></span><h3>Describing a Volume<a class="headerlink" href="#describing-a-volume" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code> is a descriptor structure that specifies the attributes of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>.</p>
<p>This structure is defined in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolume.h</span></code> and each member variable is described in the table below:</p>
<table class="colwidths-given docutils align-default" id="id4">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code> Members</span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Member</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">std::string</span></code></p></td>
<td><p>The name of the volume.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">origin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float3</span></code></p></td>
<td><p>The world-space origin of the volume.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeGridSpacing</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float3</span></code></p></td>
<td><p>The world-space distance between probes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeGridCounts</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int3</span></code></p></td>
<td><p>The number of probes on each axis (x, y, z).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeMaxRayDistance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>The maximum distance a ray cast from a probe may travel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeHysteresis</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>Controls the influence of new rays when updating probes. A value close to 1.0 slowly changes probe data, improving stability but reducing accuracy when objects move in the scene. Values of 0.9 or lower will rapidly react to scene changes, but may cause flickering or other instabilities in lighting.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeChangeThreshold</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>A ratio used during probe radiance blending. Specifies a threshold to identify when large lighting changes occur. When the difference in the maximum color components between the previous and current irradiance is larger than this threshold, the hysteresis will be reduced.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeBrightnessThreshold</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>A threshold value used during probe radiance blending that determines the maximum allowed difference in brightness between the previous and current irradiance values. This prevents impulses from drastically changing a texel’s irradiance in a single update cycle.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeDistanceExponent</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>The exponent used during visibility testing. A high value rapidly reacts to depth discontinuities, but may cause banding.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeIrradianceEncodingGamma</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>An exponent that perceptually encodes irradiance for faster light-to-dark convergence. (See <a class="reference internal" href="#probe-irradiance-gamma">Probe Irradiance Gamma</a>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">numIrradianceTexels</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>The number of texels in one dimension of the probe irradiance texture (octahedral maps are square), not including the 1-texel border.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">numDistanceTexels</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>The number of texels in one dimension of the probe distance texture (octahedral maps are square), not including the 1-texel border.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">numRaysPerProbe</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>The number of rays to cast per probe. When using <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY</span></code>, set this value to a multiple of the irradiance/distance probe texel resolution for best behavior.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">viewBias</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>A small offset along the camera view ray applied to the shaded surface point to avoid numerical instabilities when determining visibility.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">normalBias</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>A small offset along the surface normal applied to the shaded surface point to avoid numerical instabilities when determining visibility.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeMinFrontfaceDistance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>The minimum distance allowed to a front facing triangle before Probe Relocation moves the probe (see <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeBackfaceThreshold</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>The ratio of rays cast for a probe that may hit back facing triangles before Probe Relocation and State Classification assume the probes is inside of geometry (used by <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a> and <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">movementType</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EDDGIVolumeMovementType</span></code></p></td>
<td><p>The mode of movement used for the volume. Can be either <code class="docutils literal notranslate"><span class="pre">Default</span></code> or <code class="docutils literal notranslate"><span class="pre">Scrolling</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeScrollOffsets</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int3</span></code></p></td>
<td><p>The probe grid-space offsets used for scrolling movement.</p></td>
</tr>
</tbody>
</table>
<p><strong>Octahedral Texture Maps</strong></p>
<p>Octahedral Texture Maps are unwrapped as described in <a class="reference external" href="http://jcgt.org/published/0003/02/01/">Cigolle et al 2014</a>. To support fast hardware bilinear texture sampling, our octahedral texture maps include a 1-texel border. These border texels are <strong>added</strong> to the values specified in the <cite>numIrradianceTexels</cite> and <cite>numDistanceTexels</cite> members of <code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code>.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="../_images/octahedral-param.jpg"><img alt="../_images/octahedral-param.jpg" src="../_images/octahedral-param.jpg" style="width: 672.4000000000001px; height: 233.60000000000002px;" /></a>
<p class="caption"><span class="caption-text">The octahedral parameterization of a sphere unwrapped to the unit square as described by <a class="reference external" href="http://jcgt.org/published/0003/02/01/">Cigolle et al. 2014</a></span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="../_images/octahedral-border.png"><img alt="../_images/octahedral-border.png" src="../_images/octahedral-border.png" style="width: 1050.6px; height: 334.8px;" /></a>
<p class="caption"><span class="caption-text">Three annotated diagrams of the unwrapped octahedral unit square for a single probe. The left and center diagrams highlight the 1-texel border added to the 6x6 texel interior, and identify the texels that map to the “front” and “back” of the probe. The scheme to populate border texels with the necessary data for bilinear interpolation is shown on the right.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Test Harness application includes a mode to visualize each probe’s unwrapped octahedral texture map at runtime. See <a class="reference internal" href="Harness.html#harness-texture-viz"><span class="std std-ref">Texture Visualization</span></a> for more information.</p>
</div>
</div>
<div class="section" id="resource-management">
<span id="ddgi-describeresources"></span><h3>Resource Management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> uses a variety of GPU resources. Since applications vary widely in how resource allocation and tracking is handled, two modes are provided for resource management:</p>
<ul class="simple">
<li><p><strong>SDK Managed</strong>: the SDK internally manages the allocation and deallocation of <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> GPU resources.</p></li>
<li><p><strong>Application Managed</strong>: the application manages the allocation and deallocation of <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> GPU resources, and passes resource pointers to the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>.</p></li>
</ul>
<p>The resource management mode is specified at compile time by setting the <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_SDK_MANAGED_RESOURCES</span></code> define in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>. Set <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_SDK_MANAGED_RESOURCES</span></code> to 0 for application management or 1 for SDK management.</p>
<p><strong>Descriptor Heap and Constant Buffer(s)</strong></p>
<p>Regardless of the selected resource management mode, the application is responsible for allocating, managing, and providing information about the descriptor heap where the descriptors for <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> resources are placed. The application provides this information to a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> using the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> structure at volume creation time. This structure is defined in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolume.h</span></code>, and the descriptor heap members are described in the table below:</p>
<table class="colwidths-given docutils align-default" id="id7">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> Descriptor Heap Members</span><a class="headerlink" href="#id7" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">descriptorHeap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12DescriptorHeap*</span></code></p></td>
<td><p>A pointer to a valid D3D12 CBV/SRV/UAV descriptor heap.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">descriptorHeapDescSize</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>The size of each entry on the descriptor heap.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">descriptorHeapOffset</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>The offset to the first free descriptor heap slot a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> can use.</p></td>
</tr>
</tbody>
</table>
<p>In addition to descriptor heap space, the application must allocate a GPU resource for constant buffer data. Unlike the descriptor heap, a resource pointer for the constant buffer is not passed to the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> at creation time, and is instead passed through the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update(ID3D12Resource*,</span> <span class="pre">UINT64)</span></code> function (see <a class="reference internal" href="#updating-a-volume">Updating a Volume</a>). In order for the application to know how many descriptor heaps slots to reserve and how many constant buffer bytes to allocate per volume, the following helper functions are available in the <code class="docutils literal notranslate"><span class="pre">rtxgi</span></code> namespace:</p>
<table class="colwidths-given docutils align-default" id="id8">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">rtxgi</span></code> Namespace Functions for Resource Allocation</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GetDDGIVolumeConstantBufferSize()</span></code></p></td>
<td><p>Get the number of constant buffer bytes required by a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GetDDGIVolumeNumDescriptors()</span></code></p></td>
<td><p>Get the number of CBV/SRV/UAV resource descriptor slots required by a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To support double (or triple) buffering, the constant buffer should be allocated with a size that is a multiple of the value returned by <code class="docutils literal notranslate"><span class="pre">GetDDGIVolumeConstantBufferSize()</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Test Harness application provides an example that sets the descriptor heap information with the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> struct and allocates a constant buffer (for double buffering) in the <code class="docutils literal notranslate"><span class="pre">Harness::CreateVolumeMulti(...)</span></code> function of <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/Harness.cpp</span></code>.</p>
</div>
<div class="section" id="sdk-managed-resources">
<span id="ddgi-sdkresources"></span><h4>SDK Managed Resources<a class="headerlink" href="#sdk-managed-resources" title="Permalink to this headline">¶</a></h4>
<p>In SDK managed mode, the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> creates and manages the necessary GPU resources (except for the descriptor heap and constant buffer as described above), including the root signature, textures, descriptors, and pipeline state objects (PSO). The intent in providing a mode where the SDK manages GPU resources directly is to simplify the resource management process for applications that may benefit from a black box approach. Resources are allocated at volume creation time when calling the  <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Create(...)</span></code> function.</p>
<p>Although the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> manages resources in this mode, it does not handle shader compilation since most game engines and renderers already have existing infrastructure for this task. Pointers to compiled DXIL shader bytecode blobs for the blending and update compute shaders (provided in the SDK) must be passed to the volume through the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> descriptor struct. These fields are described in the table below:</p>
<table class="colwidths-given docutils align-default" id="id9">
<caption><span class="caption-text">SDK Managed <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> Members (<code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_SDK_MANAGED_RESOURCES</span> <span class="pre">==</span> <span class="pre">1</span></code>)</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">device</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Device*</span></code></p></td>
<td><p>The D3D12 device to use for resource allocation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeRadianceBlendingCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe radiance blending compute shader bytecode.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeDistanceBlendingCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe distance blending compute shader bytecode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeBorderRowCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe irradiance or distance border row update compute shader bytecode.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeBorderColumnCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe irradiance or distance border column update compute shader bytecode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeRelocationCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe relocation compute shader bytecode (used for <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeStateClassifierCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe state classifier bytecode (used for <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeStateClassifierActivateAllCS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3DBlob*</span></code></p></td>
<td><p>Compiled DXIL probe state classifier “activate all” bytecode (used for <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the SDK does not compile shaders, it will create the appropriate compute pipeline state objects for the shaders in SDK managed mode.</p>
</div>
</div>
<div class="section" id="application-managed-resources">
<span id="ddgi-app-resources"></span><h4>Application Managed Resources<a class="headerlink" href="#application-managed-resources" title="Permalink to this headline">¶</a></h4>
<p>For applications that require tighter control over the resource management process, the Application Managed resource mode leaves the task of resource allocation entirely to the host application. Like the SDK Managed mode, resource pointers are provided to the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> through the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> struct at creation time; however, the application must provide the entire set of necessary GPU resources. These fields are described in the table below:</p>
<table class="colwidths-given docutils align-default" id="id10">
<caption><span class="caption-text">Application Managed <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> Members (<code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_SDK_MANAGED_RESOURCES</span> <span class="pre">==</span> <span class="pre">0</span></code>)</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rootSignature</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12RootSignature*</span></code></p></td>
<td><p>A pointer to the root signature for the compute shaders. See <code class="docutils literal notranslate"><span class="pre">GetDDGIVolumeRootSignatureDesc(...)</span></code> below.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeRTRadiance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Resource*</span></code></p></td>
<td><p>A pointer to the probe radiance texture resource (to be used in ray tracing).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeIrradiance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Resource*</span></code></p></td>
<td><p>A pointer to the probe irradiance texture resource.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeDistance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Resource*</span></code></p></td>
<td><p>A pointer to the probe distance texture resource. The R channel stores mean distance, the G channel stores mean distance^2.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeOffsets</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Resource*</span></code></p></td>
<td><p>A pointer to the probe relocation world-space offsets texture resource (used in <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeStates</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12Resource*</span></code></p></td>
<td><p>A pointer to the probe state texture resource (used in <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeRadianceBlendingPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe radiance blending compute pipeline state object resource.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeDistanceBlendingPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe distance blending compute  pipeline state object resource.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeBorderRowPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe irradiance or distance border row update compute pipeline state object resource.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeBorderColumnPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe irradiance or distance border column update compute pipeline state object resource.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeRelocationPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe relocation compute pipeline state object resource (used in <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probeStateClassifierPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe state classifier compute pipeline state object resource (used in <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">probeStateClassifierActivateAllPSO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ID3D12PipelineState*</span></code></p></td>
<td><p>A pointer to the probe state classifier activate all compute pipeline state object resource (used in <a class="reference internal" href="#probe-state-classification">Probe State Classification</a>).</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In application managed resource mode, a <code class="docutils literal notranslate"><span class="pre">D3D12Device</span></code> pointer is not passed through the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> struct, since all resources are allocated by the host application. As a consequence, pipeline state object resources pointers are passed for each required compute shader instead of compiled DXIL bytecode.</p>
</div>
<p><strong>Allocation Helpers</strong></p>
<p>To aid the application in the resource allocation process, the following namespace functions are available in the <code class="docutils literal notranslate"><span class="pre">rtxgi</span></code> namespace:</p>
<table class="colwidths-given docutils align-default" id="id11">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">rtxgi</span></code> Namespace Helper Functions for Resource Allocation</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT</span> <span class="pre">GetDDGIVolumeTextureFormat(ETextureType</span> <span class="pre">type)</span></code></p></td>
<td><p>Get the required DXGI_FORMAT of the given texture resource type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">GetDDGIVolumeProbeCounts(const</span> <span class="pre">DDGIVolumeDesc</span> <span class="pre">&amp;desc,</span> <span class="pre">UINT</span> <span class="pre">&amp;probeCountX,</span> <span class="pre">UINT</span> <span class="pre">&amp;probeCountY)</span></code></p></td>
<td><p>Get the number of probes on the X and Y dimensions of the irradiance and distance textures.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">GetDDGIVolumeTextureDimensions(const</span> <span class="pre">DDGIVolumeDesc</span> <span class="pre">&amp;desc,</span> <span class="pre">ETextureType</span> <span class="pre">type,</span> <span class="pre">UINT</span> <span class="pre">&amp;width,</span> <span class="pre">UINT</span> <span class="pre">&amp;height)</span></code></p></td>
<td><p>Get the dimensions, in texels, of the given texture type for a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> with the given descriptor.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">GetDDGIVolumeRootSignatureDesc(int</span> <span class="pre">descriptorHeapOffset,</span> <span class="pre">ID3DBlob**</span> <span class="pre">signature)</span></code></p></td>
<td><p>Get the root signature descriptor blob for the given descriptor heap offset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DDGIVolumeDescGPU</span> <span class="pre">GetDDGIVolumeGPUDesc(DDGIVolumeDesc</span> <span class="pre">&amp;desc)</span></code></p></td>
<td><p>Get the compacted GPU version of the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> descriptor.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The format of various textures can be changed at compile time (usually for debug purposes) by changing the following defines in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_RADIANCE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_OFFSETS</span></code></p></li>
</ul>
<p><br/> See <a class="reference internal" href="#configuration">Configuration</a> for more information.</p>
</div>
</div>
</div>
<div class="section" id="creating-a-volume">
<span id="ddgi-createvolume"></span><h3>Creating a Volume<a class="headerlink" href="#creating-a-volume" title="Permalink to this headline">¶</a></h3>
<p>A minimum of one <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is required to use the DDGI algorithm. Volumes are specified as part of the scene, which is left to the host application. A common pattern is for artists and level designers to specify volumes in editor tools that expose RTXGI SDK functionality through their user interface. <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> parameters are then stored in data files, and used at level load time to instantiate the volumes. Alternatively, a volume may be programmatically generated based on scene parameters (bounding boxes, resolution, etc.).</p>
<p>Assuming the set of desired parameters are available, the volume creation process begins by mapping each parameter into the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code> struct (see <a class="reference internal" href="#describing-a-volume">Describing a Volume</a> for details). Once the volume descriptor has the appropriate parameters, the required volume resources are set in a <code class="docutils literal notranslate"><span class="pre">DDGIVolumeResources</span></code> struct (see <a class="reference internal" href="#resource-management">Resource Management</a> for details). After the parameter descriptor and resource descriptor are set up, the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is created using the constructor after which the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Create(...)</span></code> is called to finish creating the volume. See the <code class="docutils literal notranslate"><span class="pre">Harness::CreateVolume(...)</span></code> function in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/Harness.cpp</span></code> for an example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <span class="xref std std-ref">Harness</span> provides an example implementation of how to use one or more <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> to add global illumination to a scene.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While this section focused on creation of a single volume, multiple volumes may be created by repeating the creation process in this section. See <a class="reference internal" href="#volume-blending">Volume Blending</a> for more information on how to use multiple volumes to compute global illumination.</p>
</div>
</div>
<div class="section" id="destroying-a-volume">
<span id="ddgi-destroyvolume"></span><h3>Destroying a Volume<a class="headerlink" href="#destroying-a-volume" title="Permalink to this headline">¶</a></h3>
<p>When no longer needed, a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> and its GPU resources can be released. Regardless of resource management mode (see <a class="reference internal" href="#resource-management">Resource Management</a>), the host application is responsible for releasing the descriptor heap and constant buffer resources allocated for the volume. In SDK managed resource mode, all additional GPU resources created for a volume are released when <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Destroy()</span></code> is called. In application managed resource mode, no GPU resources are released when <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Destroy</span></code> is called, and the deallocation process is left entirely to the host application.</p>
</div>
</div>
<div class="section" id="updating-a-volume">
<span id="ddgi-updatevolume"></span><h2>Updating a Volume<a class="headerlink" href="#updating-a-volume" title="Permalink to this headline">¶</a></h2>
<p>The DDGI algorithm is referred to as <em>Dynamic</em> Diffuse Global Illumination since it is possible to update irradiance and distance data at runtime. A common update frequency is to update the probes with newly ray traced data every frame; however, this is not the only option. Aternatively, updates could be scheduled at a lower frequency than the frame rate, or even as asynchronous workloads that execute continuously on lower priority background queues - essentially streaming radiance and distance data to <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> probes.</p>
<p>The set of operations to perform a single update of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> are:</p>
<ol class="arabic simple">
<li><p>Randomize the sampling rotation and update the constant buffer data by calling <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update(...)</span></code>.</p>
<ul class="simple">
<li><p>See <code class="docutils literal notranslate"><span class="pre">volume-&gt;Update(...)</span></code> in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/main.cpp</span></code></p></li>
</ul>
</li>
<li><p>Trace rays from the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> probes and store the radiance and distance results.</p>
<ul class="simple">
<li><p>See <code class="docutils literal notranslate"><span class="pre">Harness::RayTraceProbes(...)</span></code> in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/main.cpp</span></code></p></li>
</ul>
</li>
<li><p>Update probe irradiance and distance data based on the ray tracing results by calling <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes(...)</span></code>.</p>
<ul class="simple">
<li><p>See <code class="docutils literal notranslate"><span class="pre">volume-&gt;UpdateProbes(...)</span></code> in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/main.cpp</span></code></p></li>
</ul>
</li>
</ol>
<div class="section" id="randomizing-the-sampling-rotation-and-updating-the-constant-buffer">
<span id="ddgi-rotationsandcb"></span><h3>Randomizing the Sampling Rotation and Updating the Constant Buffer<a class="headerlink" href="#randomizing-the-sampling-rotation-and-updating-the-constant-buffer" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update()</span></code> function randomizes the rotation matrix applied to each probe’s set of ray directions and updates the constant buffer. Well distributed random rotations are computed using <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&amp;rep=rep1&amp;type=pdf">James Arvo’s implementation from Graphics Gems 3 (pg 117-120)</a> in the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::ComputeRandomRotation()</span></code> function. If this step is skipped, the previous rotation and constant buffer state are used, and the same data as the previous frame is unnecessarily recomputed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update(...)</span></code> function accepts a GPU resource pointer to a constant buffer along with a byte offset. The update function calls <code class="docutils literal notranslate"><span class="pre">Map()</span></code> and applies the byte offset before performing a <code class="docutils literal notranslate"><span class="pre">memcpy(...)</span></code> and <code class="docutils literal notranslate"><span class="pre">Unmap()</span></code> on the constant buffer. It is possible to double buffer the constant buffer data by swapping byte offsets each time <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update</span></code> is called. The Test Harness provides an example of this in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/main.cpp</span></code>.</p>
</div>
</div>
<div class="section" id="probe-ray-trace">
<span id="ddgi-probetrace"></span><h3>Probe Ray Trace<a class="headerlink" href="#probe-ray-trace" title="Permalink to this headline">¶</a></h3>
<p>After updating the constant buffer data, the application is expected to perform ray tracing for probes in the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> to estimate the incoming irradiance and distance to geometry in all directions around each probe. This can be accomplished a number of ways, and for flexibility the SDK leaves this task to the host application. Regardless of how ray tracing is implemented, a set of ray directions for the volume’s probes must be computed. <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/ddgi/ProbeCommon.hlsl</span></code> provides the <code class="docutils literal notranslate"><span class="pre">DDGIGetProbeRayDirection(...)</span></code> utility function that computes a set of unique, low discrepancy, spherically distributed directions on the unit sphere that apply the randomly rotation transform computed by <code class="docutils literal notranslate"><span class="pre">DDGIVolume::Update(...)</span></code>. This function should be used to generate probe ray directions before ray tracing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An example of this is provided in the <code class="docutils literal notranslate"><span class="pre">Harness::RayTraceProbes(...)</span></code>  function of the Test Harness in <code class="docutils literal notranslate"><span class="pre">samples/test-harness/src/harness/Harness.cpp</span></code>, and <code class="docutils literal notranslate"><span class="pre">RayGen()</span></code> HLSL entry point of the <code class="docutils literal notranslate"><span class="pre">samples/test-harness/shaders/ProbeTraceRGS.hlsl</span></code> DXR ray generation shader.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Higher ray counts per probe increase the rate of convergence and produce better visual results, since each probe’s irradiance and distance representation is more accurate.</p>
</div>
</div>
<div class="section" id="probe-irradiance-and-distance-update">
<span id="ddgi-update"></span><h3>Probe Irradiance and Distance Update<a class="headerlink" href="#probe-irradiance-and-distance-update" title="Permalink to this headline">¶</a></h3>
<p>The results of the probe ray tracing step are used to update the irradiance and distance data for each probe by calling <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes(...)</span></code>. The update operation consists of two phases, and six compute shader dispatches:</p>
<p><strong>Phase 1: Blending</strong></p>
<ol class="arabic simple">
<li><p>Blend the ray traced <strong>radiance</strong> values for each probe’s irradiance octahedral texture map.</p></li>
<li><p>Blend the ray traced <strong>distance</strong> values for each probe’s distance octahedral texture map.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_NUM_FIXED_RAYS</span></code> define represents the number of rays used for <a class="reference internal" href="#probe-relocation-and-position-optimization">Probe Relocation and Position Optimization</a> and/or <a class="reference internal" href="#probe-state-classification">Probe State Classification</a> (when enabled). The radiance and distance results for these rays are not included in the blending phase since their directions are <strong>not</strong> randomly updated each frame. Inclusion of their results would create biased results. See <a class="reference internal" href="#fixed-rays-for-relocation-and-classification">Fixed Rays for Relocation and Classification</a> for more information.</p>
</div>
<p><strong>Phase 2: Border Texel Update</strong></p>
<ol class="arabic simple" start="3">
<li><p>Update all <strong>rows</strong> of border texels for <strong>irradiance</strong> octahedral texture maps.</p></li>
<li><p>Update all <strong>columns</strong> of border texels for <strong>irradiance</strong> octahedral texture maps.</p></li>
<li><p>Update all <strong>rows</strong> of border texels for <strong>distance</strong> octahedral texture maps.</p></li>
<li><p>Update all <strong>columns</strong> of border texels for <strong>distance</strong> octahedral texture maps.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY</span></code> to 1 to enable shared memory in the probe blending shaders. <strong>Enabling shared memory is strongly recommended</strong>, since optimizations using shared memory provide a substantial performance benefit by cooperatively loading and computing values that are common within thread groups.</p>
</div>
<p>During the probe update process, performance markers are inserted into the GPU command list of when <code class="docutils literal notranslate"><span class="pre">RTXGI_PERF_MARKERS</span></code> is set to 1. An example of these annotatations in Nsight Graphics is shown below:</p>
<div class="figure align-center" id="id12">
<a class="reference internal image-reference" href="../_images/probe_update_nsight.jpg"><img alt="../_images/probe_update_nsight.jpg" src="../_images/probe_update_nsight.jpg" style="width: 100%;" /></a>
<p class="caption"><span class="caption-text">The Nsight Graphics scrubber view, showing performance markers from the Test Harness. The probe update markers are highlighted.</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume::UpdateProbes(...)</span></code> function places two performance markers in the command list (one for irradiance and one for distance) for the border update phase, instead of one for each compute dispatch. This is why two border update performance markers appear in the scrubber view in Nsight Graphics instead of four.</p>
</div>
</div>
</div>
<div class="section" id="volume-movement">
<span id="ddgi-volumemovement"></span><h2>Volume Movement<a class="headerlink" href="#volume-movement" title="Permalink to this headline">¶</a></h2>
<p>For general use, the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> is designed to be stationary, and placed in a fixed scene location. However, for the best results in scenarios where the space that requires global illumination is itself not stationary, the <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> may also need to move. Examples of this include elevators, trains, cars, and spaceships. To achieve consistent global lighting results for moving spaces, a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> can be attached to the moving space’s frame of reference and translated with the <code class="docutils literal notranslate"><span class="pre">DDGIVolume-&gt;Move(...)</span></code> function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">volume-&gt;Move(...)</span></code> <em>translates</em> a volume, the transformation is only correct for frames of reference undergoing translation only (i.e. not rotation also). As a result, the axis-aligned bounding box of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> needs to be large enough to cover the desired space when the space is under rotation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume-&gt;Move(...)</span></code> functionality is also useful for debugging purposes, so that one may visualize how a set of probes function in different locations of a scene without creating multiple volumes.</p>
</div>
<p>To achieve dynamic global illumination results in an open or large world setting, it is desirable to anchor a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> to a player character or the camera view, and then update the volume as the player or camera moves. This effectively provides an <strong>“infinite” volume of global illumination</strong> for the player without needing an infinite amount of probes (and memory) to store radiance and distance information. In practice, simply moving a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> at the same rate as the player causes visual artifacts. In this release of the SDK, we are providing a new <em>infinite scrolling volume</em> feature in early access. Head over to the <a class="reference internal" href="#infinite-scrolling-volume-movement">Infinite Scrolling Volume Movement</a> section to learn more.</p>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="computing-indirect-lighting-from-a-volume">
<span id="ddgi-indirectlighting"></span><h2>Computing Indirect Lighting from a Volume<a class="headerlink" href="#computing-indirect-lighting-from-a-volume" title="Permalink to this headline">¶</a></h2>
<p>To compute indirect lighting using a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>, the application needs to provide:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The world-space position of the surface point that recieves the indirect light (i.e. the point being shaded)</p></li>
<li><p>A small surface bias value, computed with the <code class="docutils literal notranslate"><span class="pre">DDGIGetSurfaceBias(...)</span></code> helper function provided in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/ddgi/Irradiance.hlsl</span></code>.</p></li>
<li><p>The normal direction of the surface point.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> constant buffer data.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> texture resources (probe irradiance and distance SRVs, and a texture sampler).</p></li>
</ol>
</div></blockquote>
<p>Each of the requirements above are passed to the <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeIrradiance(...)</span></code> function in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/ddgi/Irradiance.hlsl</span></code>. <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeIrradiance(...)</span></code> computes the proper irradiance contribution based on the given <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> by determining which probes are relevant to the given world-space point, evaluating the stored irradiance, and using the probe distance values to determine visibility and eliminate contributions from occluded probes.</p>
<p>The Test Harness provides an example of this in the <code class="docutils literal notranslate"><span class="pre">samples/test-harness/shaders/Indirect.hlsl</span></code> fullscreen Pixel Shader.</p>
<div class="section" id="probe-irradiance-gamma">
<span id="ddgi-irradiancegamma"></span><h3>Probe Irradiance Gamma<a class="headerlink" href="#probe-irradiance-gamma" title="Permalink to this headline">¶</a></h3>
<p>To improve the light-to-dark convergence and the efficiency of texture storage, our implementation of DDGI uses exponential weighting when storing irradiance. The default gamma exponent is <code class="docutils literal notranslate"><span class="pre">5.f</span></code>, but it can be modified by changing the <code class="docutils literal notranslate"><span class="pre">probeIrradianceEncodingGamma</span></code> member of the <code class="docutils literal notranslate"><span class="pre">DDGIVolumeDesc</span></code> struct (see <a class="reference internal" href="#describing-a-volume">Describing a Volume</a>). This exponent moves the stored irradiance value into a non-linear space that more closely matches human perception, while also allowing for a smaller texture format. If <code class="docutils literal notranslate"><span class="pre">probeIrradianceEncodingGamma</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1.f</span></code>, then the stored value remains in linear space and the quality of the lighting will decrease. To account for this quality loss when in linear space, <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code> to use the larger <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R32G32B32A32_FLOAT</span></code> texture format for irradiance. By default, the smaller <code class="docutils literal notranslate"><span class="pre">DXGI_FORMAT_R10G10B10A2_UNORM</span></code> is used (see <a class="reference internal" href="#configuration">Configuration</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While we recommend using the default value for <code class="docutils literal notranslate"><span class="pre">probeIrradianceEncodingGamma</span></code> for most situations, values near the default of <code class="docutils literal notranslate"><span class="pre">5.f</span></code> may improve light-to-dark convergence in specific situations.</p>
</div>
</div>
<div class="section" id="compositing-indirect-lighting">
<span id="ddgi-compositing"></span><h3>Compositing Indirect Lighting<a class="headerlink" href="#compositing-indirect-lighting" title="Permalink to this headline">¶</a></h3>
<p>One example of how to composite irradiance sampled from a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> with direct lighting and ambient occlusion is provided by the <code class="docutils literal notranslate"><span class="pre">Harness::RenderIndirect(...)</span></code> function and <code class="docutils literal notranslate"><span class="pre">samples/test-harness/shaders/Indirect.hlsl</span></code> fullscreen Pixel Shader.</p>
</div>
<div class="section" id="volume-blending">
<span id="ddgi-volumeblending"></span><h3>Volume Blending<a class="headerlink" href="#volume-blending" title="Permalink to this headline">¶</a></h3>
<p>The SDK provides a separate HLSL shader function, <code class="docutils literal notranslate"><span class="pre">DDGIGetVolumeBlendWeight(...)</span></code>, to enable blending between multiple <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> and regions <strong>not</strong> covered by a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>. This use case may arise if there is a region of the scene that needs dynamic diffuse irradiance and another part that strictly does not (for example, due to artistic or performance reasons), or if a scene has multiple overlapping volumes.</p>
<p id="ddgi-multipleblending">To see how to use this function to blend between multiple volumes, see <code class="docutils literal notranslate"><span class="pre">samples/test-haress/shaders/Indirect.hlsl</span></code>. The test harness implementation takes an array of volumes (in order of descending priority) and blends together their contributions until it either finishes iterating through all volumes, or the total contribution reaches an acceptable threshold (1 by default). In the case of blending between a volume and a non-volume region, the example provided in the <code class="docutils literal notranslate"><span class="pre">samples/test-haress/shaders/Indirect.hlsl</span></code> shader can be modified as shown below:</p>
<div class="highlight-hlsl notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Hard coded ambient term (black), might be passed in</span>
<span class="kt">float3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>

<span class="c1">// Get the volume blend weight (0-1)</span>
<span class="kt">float</span> <span class="n">volumeBlendWeight</span> <span class="o">=</span> <span class="n">DDGIGetVolumeBlendWeight</span><span class="p">(</span> <span class="n">worldPosHitT</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">DDGIVolume</span><span class="p">);</span>

<span class="c1">// Only get irradiance if it will be used</span>
<span class="k">if</span> <span class="p">(</span><span class="n">volumeBlendWeight</span> <span class="o">&gt;</span> <span class="mf">0.f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get irradiance from the DDGIVolume</span>
    <span class="n">irradiance</span> <span class="o">=</span> <span class="n">DDGIGetVolumeIrradiance</span><span class="p">(</span>
        <span class="n">worldPosHitT</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span>
        <span class="n">surfaceBias</span><span class="p">,</span>
        <span class="n">normal</span><span class="p">,</span>
        <span class="n">DDGIVolume</span><span class="p">,</span>
        <span class="n">resources</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Blend between irradiance and the constant ambient term</span>
<span class="n">irradiance</span> <span class="o">=</span> <span class="n">volumeBlendWeight</span> <span class="o">*</span> <span class="n">irradiance</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="n">volumeBlendWeight</span><span class="p">)</span> <span class="o">*</span> <span class="n">ambient</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="probe-relocation-and-position-optimization">
<span id="probe-offsets"></span><h2>Probe Relocation and Position Optimization<a class="headerlink" href="#probe-relocation-and-position-optimization" title="Permalink to this headline">¶</a></h2>
<p>Any regular grid has a hard time adapting to correctly handle all kinds of scenes, and the regular grids of DDGI are no exception. To mitigate this shortcoming, we provide a feature that allows world-space offsets to be added to each probe, and enable users to experiment with probe offset optimization using the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::RelocateProbes(...)</span></code> function in the Test Harness. You can enable this functionality by changing the corresponding SDK define (see note below).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume::RelocateProbes(...)</span></code> function attempts to move probes out of the interior of geometry by assuming that some proportion of probe rays intersecting back faces indicates the probe is inside geometry. The <code class="docutils literal notranslate"><span class="pre">probeBackfaceThreshold</span></code> variable, described in the <a class="reference internal" href="#describing-a-volume">Describing a Volume</a> section, controls the threshold beyond which a probe is considered “inside geometry”. When a probe is determined to be inside of geometry, the maximum allowable displacement is computed as 45% of the grid cell distance. This is implemented in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/ddgi/ProbeRelocationCS.hlsl</span></code>. For those probes that are not found to be inside geometry, the position optimizer attempts to move probes closer to nearby frontfacing geometry.</p>
<p>Probe relocation can run at arbitrary frequencies, and is designed to produce stable results when run continuously. As an example of this, the Test Harness runs probe relocation once every frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enable probe relocation by setting <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_RELOCATION</span></code> to 1 in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>.</p>
</div>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Probe falling inside of geometry without probe relocation</p></th>
<th class="head"><p>Probes adjusted to more useful positions with probe relocation enabled</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><img alt="probe_relocation-1" src="../_images/probe_relocation-1.jpg" /></p></td>
<td><p><img alt="probe_relocation-2" src="../_images/probe_relocation-2.jpg" /></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="probe-state-classification">
<span id="probe-states"></span><h2>Probe State Classification<a class="headerlink" href="#probe-state-classification" title="Permalink to this headline">¶</a></h2>
<p>Not all scenes require all probes in a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> to contribute to the global illumination result. Some probes may be stuck inside geometry (e.g. walls), exist in space without nearby geometry, or be far enough outside the scene to not be useful. In these cases, it is best for these probes to not trace rays or spend time updating textures that ultimately won’t be used. The SDK provides a probe state classification feature that identifies probes that may be safely disabled, and maintains a per-probe state that is updated dynamically at runtime on the GPU.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enable probe state classification by setting <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_STATE_CLASSIFIER</span></code> to 1 in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>.</p>
</div>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Disabled probes (in red) that are stuck inside geometry</p></th>
<th class="head"><p>Disabled probes (in red) don’t have nearby geometry due to the dense grid</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><img alt="probe_classification_geometry" src="../_images/probe_classification_geometry.jpg" /></p></td>
<td><p><img alt="probe_classification_space" src="../_images/probe_classification_space.jpg" /></p></td>
</tr>
</tbody>
</table>
<div class="section" id="fixed-rays-for-relocation-and-classification">
<h3>Fixed Rays for Relocation and Classification<a class="headerlink" href="#fixed-rays-for-relocation-and-classification" title="Permalink to this headline">¶</a></h3>
<p>Since probe relocation and classification can be run at arbitrary frequencies, temporal stability is essential to ensure the best conditions for fast irradiance and distance convergence. Using random rays to drive the relocation and/or classification processes (as was done in the RTXGI SDK 1.0 early access version of this feature) leads to unstable jittering and/or oscillation of probe locations and states. To guarantee stable results, the <code class="docutils literal notranslate"><span class="pre">DDGIGetProbeRayDirection(...)</span></code> function <strong>does not apply the random rotation transform</strong> to the first <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_NUM_FIXED_RAYS</span></code> rays. These “fixed rays” always have the same directions every update cycle. As a result, the relocation and classification shaders only inspect the “fixed rays” for each probe; the quantity of which is specified by the <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_NUM_FIXED_RAYS</span></code> define. While these “fixed rays” are essential for stable relocation and classification, they are excluded from probe blending since their regularity causes artifacts due to bias. The Test Harness provides an example of probe classification running once every frame. See the <code class="docutils literal notranslate"><span class="pre">DDGIVolume::ClassifyProbes(...)</span></code> function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can change the value of <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_NUM_FIXED_RAYS</span></code> in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/shaders/Common.hlsl</span></code>. All probes trace at least <code class="docutils literal notranslate"><span class="pre">RTXGI_NUM_FIXED_RAYS</span></code> “fixed rays” every frame. If a probe is marked as disabled, only the fixed rays are traced and blending is disabled for the probe.</p>
</div>
</div>
</div>
<div class="section" id="early-access-features">
<span id="ddgi-earlyaccess"></span><h2>Early Access Features<a class="headerlink" href="#early-access-features" title="Permalink to this headline">¶</a></h2>
<p>The following early access features are available for experimental use, but may change substantially in future versions of the RTXGI SDK.</p>
</div>
<div class="section" id="infinite-scrolling-volume-movement">
<span id="ddgi-scrollingmovement"></span><h2>Infinite Scrolling Volume Movement<a class="headerlink" href="#infinite-scrolling-volume-movement" title="Permalink to this headline">¶</a></h2>
<p>To achieve dynamic global illumination results in an open or large world setting, it is desirable to anchor a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> to a player character or the camera view, and then update the anchored volume as the player or camera moves. This effectively provides an <strong>“infinite” volume of global illumination</strong> for the player without needing an infinite amount of probes (and memory) to store radiance and distance information. In practice, naively adjusting the position of a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> relative to the environment causes visual artifacts. All probe locations change during volume movement, and all irradiance and distance data gathered for the volume’s probes become invalid. Probes must reconverge before their data is useful again.</p>
<p>To mitigate this issue, the <em>infinite scrolling volume movement</em> feature is now available in early access. With this feature enabled for a <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code>, movement of the volume does <strong>not</strong> move all of the probes within the volume; but instead, relocates a subset of the probes (a “plane” or “slice” of probes) from one end of the volume to the other. All interior probes remain stationary in their original positions. We refer to this process as probe <strong>scrolling</strong>. The stationary probes retain valid irradiance and distance values, and only the probes on the edges of the volume have to reconverge. This style of movement is analagous to how tank tread rolls forward while its individual segments stay fixed while in contact with the ground.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DDGIVolume</span></code> provides two <code class="docutils literal notranslate"><span class="pre">Scroll(...)</span></code> functions that translate the volume in this manner. The <code class="docutils literal notranslate"><span class="pre">Scroll(int3</span> <span class="pre">translation)</span></code> function takes an <code class="docutils literal notranslate"><span class="pre">int3</span></code> argument, where the integers represent the number of probe “planes”. For example, <code class="docutils literal notranslate"><span class="pre">Scroll(int3(2,</span> <span class="pre">0,</span> <span class="pre">0))</span></code> means “scroll two planes of probes along the X axis to the other end of the volume”.  The <code class="docutils literal notranslate"><span class="pre">Scroll(float3</span> <span class="pre">translation,</span> <span class="pre">float3</span> <span class="pre">deadzoneRadii)</span></code> function takes a <code class="docutils literal notranslate"><span class="pre">float3</span></code> argument in world-space for the translation, and a second <code class="docutils literal notranslate"><span class="pre">float3</span></code> to define a “dead zone”. The dead zone defines the space (i.e. a padding) where the probes do not need to react to volume movement. A larger dead zone causes the volume to scroll in larger probe plane increments. On the other extreme, a dead zone of zero causes volume scrolling by a single probe plane as soon as the accumulated translation is larger than the inter-probe distance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enable infinite scrolling volume movement by setting <code class="docutils literal notranslate"><span class="pre">RTXGI_DDGI_PROBE_SCROLL</span></code> to 1 in <code class="docutils literal notranslate"><span class="pre">rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h</span></code>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="UE4Plugin.html" class="btn btn-neutral float-right" title="Unreal Engine 4 Plugin" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="SDKOverview.html" class="btn btn-neutral float-left" title="RTXGI SDK Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019-2020, NVIDIA

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>