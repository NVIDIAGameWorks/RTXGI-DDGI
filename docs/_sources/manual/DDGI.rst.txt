.. _DDGI:

.. |reg| unicode:: U+000AE .. REGISTERED SIGN
   :ltrim:

.. |br| raw:: html

   <br/>

====================================
Dynamic Diffuse Global Illumination
====================================

Dynamic Diffuse Global Illumination (DDGI) is a global lighting algorithm that extends the traditional pre-computed irradiance probes approach. Lighting techniques built on traditional irradiance probes are commonly used today in real-time rendering (see popular commercial products and engines such as `Enlighten <https://www.siliconstudio.co.jp/middleware/enlighten/en/>`_, `Unity <https://unity3d.com/learn/tutorials/topics/graphics/probe-lighting>`_, and `Unreal Engine <https://docs.unrealengine.com/en-us/Engine/Rendering/LightingAndShadows/IndirectLightingCache>`_); however, these irradiance probe solutions are unable to resolve the visibility of dynamic scene elements at runtime. The DDGI algorithm removes this restriction by employing GPU ray tracing and a fast probe update scheme to maintain per-probe irradiance *and* distance data at runtime for static *and* dynamic objects. 

Similar to traditional irradiance probes, DDGI does not solve the complete global illumination problem, and is best used for the diffuse irradiance component of the full lighting equation. As a result of the underlying probe based data structure, the computed diffuse irradiance is inherently low frequency and can not capture fine high frequency occlusion details. For this reason, DDGI combines effectively with complimentary rendering techniques such as Ray Traced Ambient Occlusion (RTAO). To demonstrate this, RTAO is implemented and combined with DDGI in the Test Harness sample application. Head over to the :ref:`Harness` section to learn more.

The remainder of this documentation focuses on the implementation of DDGI provided in this SDK. More information about Dynamic Diffuse Global Illumination can be found in the `academic publication <http://jcgt.org/published/0008/02/01/>`_ and `NVIDIA's GDC 2019 "Dynamic Diffuse Global Illumination with Ray Traced Irradiance Fields" <https://www.gdcvault.com/play/1026182/>`_ talk.

.. _DDGI-Overview:

-------------------------
Usage Overview
-------------------------

The computation of diffuse global illumination using the DDGI algorithm in this SDK is supported inside volumes of user defined size. This is functionality provided by the ``DDGIVolume`` class, and supported by various helper functions in the ``rtxgi`` namespace.

The basic use pattern of a ``DDGIVolume`` for **dynamic global illumination** is as follows:

1. Create one or more ``DDGIVolume`` (see `Volumes`_).
2. Each Frame:

   a. Call ``DDGIVolume::Update(...)``

      Note: this function call updates the volume's random sampling pattern and constant buffer (see `Updating a Volume`_).

   b. Trace rays for the volume's probes (see `Probe Ray Trace`_).
   c. Call ``DDGIVolume::UpdateProbes(...)`` 
   
      Note: this function call updates the irradiance and distance values for all probes in the volume based on the results from ray tracing (see `Probe Irradiance and Distance Update`_).

   d. Sample the diffuse irradiance at a point in the ``DDGIVolume`` with the ``DDGIGetVolumeIrradiance(...)`` HLSL function, and composite with direct illumination (see `Computing Indirect Lighting from a Volume`_).

3. Destroy the ``DDGIVolume`` on shutdown (see `Destroying a Volume`_).

.. note:: The Test Harness sample application implements the process described above in ``samples/test-harness/src/harness/main.cpp``. The frame loop of Step 2 is implemented in the following places:
   
   Line 210: ``volume->Update(...)`` |br| 
   Line 213: ``Harness::RayTraceProbes(...)``  |br| 
   Line 220: ``volume->UpdateProbes(...)``  |br| 
   Line 281: ``Harness::RenderIndirect(...)``  |br| 

There are several alternate ways a ``DDGIVolume`` may be used, depending on the constraints and performance requirements of the application and target platform. For example, one could create a volume and run a number of ray tracing iterations and probe updates at level load time to bake the current lighting conditions into the volume. This approach is not as dynamic as the pattern described above, but it eliminates the common practice of pre-computing several sets of probe irradiance textures for scenarios such as time of day changes at level transitions. This can result in substantial storage savings, and lighting that more accurately matches the time of day. This pattern is implemented as follows:

   1. Create one or more ``DDGIVolume`` (see `Volumes`_).
   2. For N iterations (e.g. at level load or map transition)

      a. Call ``DDGIVolume->Update(...)``
      b. Trace rays for the volume's probes (see `Probe Ray Trace`_)
      c. Call ``DDGIVolume->UpdateProbes(...)``

   3. Level Load / Map Transition Completes
   4. Each Frame: 
   
      a. Sample the diffuse irradiance at a point in the ``DDGIVolume`` with the ``DDGIGetVolumeIrradiance(...)`` HLSL function, and composite with direct illumination (see `Computing Indirect Lighting from a Volume`_).

   5. Level Load / Map Transition initiated. Go back to Step 2.  

.. _DDGI-Config:

-------------------------
Configuration
-------------------------

The configuration of the DDGI implementation is primarily controlled through a set of defines found in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h``. These defines are alsodiscussed in the relevant sections of this document. The following table provides an overview:

.. list-table:: ``DDGIVolumeDefines.h`` Configuration
   :widths: 21 55 22
   :header-rows: 1

   * - Setting
     - Description
     - More details
   * - ``RTXGI_DDGI_SDK_MANAGED_RESOURCES``
     - Set to 0 for the application to manage resources, and 1 for the SDK to manage resources.
     - `Resource Management`_
   * - ``RTXGI_DDGI_DEBUG_FORMAT_RADIANCE``
     - Radiance textures currently use the ``DXGI_FORMAT_R32G32B32A32_FLOAT`` format regardless of settings.
     - `Resource Management`_
   * - ``RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE``
     -  Set to 0 for irradiance textures to use the ``DXGI_FORMAT_R10G10B10A2_UNORM`` format. |br| Set to 1 to use the larger ``DXGI_FORMAT_R32G32B32A32_FLOAT`` format (useful when debugging).
     - `Resource Management`_
   * - ``RTXGI_DDGI_DEBUG_FORMAT_OFFSETS``
     - Set to 0 for offset textures to use ``DXGI_FORMAT_R16G16B16A16_FLOAT``. |br| Set to 1 for to use ``DXGI_FORMAT_R32G32B32A32_FLOAT`` (useful when debugging). 
     - `Resource Management`_
   * - ``RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY``
     - Set to 1 to use shared memory optimizations in the probe radiance and distance blending shaders.
     - `Probe Irradiance and Distance Update`_
   * - ``RTXGI_DDGI_DEBUG_PROBE_INDEXING``
     - Set to 1 to visualize probe indices for debugging. Requires ``RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE`` to also be set to 1.
     - `Probe Irradiance and Distance Update`_
   * - ``RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING``
     - Set to 1 to override irradiance textures with debug coloring that visualizes probe octants.
     - `Describing a Volume`_
   * - ``RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING``
     - Set to 1 to override irradiance textures with debug coloring that visualizes probe border copy indexing.
     - `Describing a Volume`_
   * - ``RTXGI_DDGI_COMPUTE_IRRADIANCE``
     - A define used by the host application. Set to 1 to enable using DDGI to compute irradiance. See ``samples/test-harness/shaders/Indirect.hlsl`` in the Test Harness for an example.
     - `Computing Indirect Lighting from a Volume`_
   * - ``RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE``
     - A define used by the host application. Set to 1 to enable using DDGI to compute irradiance recursively for probe rays. See ``samples/test-harness/shaders/ProbeTraceRGS.hlsl`` in the Test Harness for an example.
     - `Computing Indirect Lighting from a Volume`_
   * - ``RTXGI_DDGI_PROBE_RELOCATION``
     - Set to 1 to enable the early access feature for Probe Relocation.
     - :ref:`probe_offsets`
   * - ``RTXGI_DDGI_PROBE_STATE_CLASSIFIER``
     - Set to 1 to enable the early access feature for Probe Classification.
     - :ref:`probe_states`

.. note:: Some of these configuration options are only used in the :ref:`Harness`, but are provided in the SDK for convenience.

.. _DDGI-Shaders:

--------------------------------------------
Shaders
--------------------------------------------

In addition to host side source code, the necessary DDGI shader code is provided in ``rtxgi-sdk/shaders/ddgi``. The following table provides a brief description of each shader file:

.. list-table:: DDGI HLSL Shaders
   :widths: 25 75
   :header-rows: 1

   * - File Name
     - Description
   * - ``ProbeCommon.hlsl``
     - Contains commonly used probe indexing, octahedral indexing, ray generation, and probe relocation/classification functions. This file can be included anywhere, since all resources are passed through function parameters.
   * - ``Irradiance.hlsl``
     - Contains the helper functions used when sampling irradiance for arbitrary points in a ``DDGIVolume``. Include this shader file in a fullscreen Pixel Shader that is executed somewhere in the post-processing pipeline, and call the ``DDGIGetVolumeIrradiance()`` function. See `Computing Indirect Lighting from a Volume`_.
   * - ``ProbeBlendingCS.hlsl``
     - Compute shader code that blends radiance or distance values into the appropriate octahedral texture map. All probes of a volume are processed in parallel. This shader is dispatched by the ``DDGIVolume::UpdateProbes()`` function. See `Probe Irradiance and Distance Update`_.
   * - ``ProbeBorderUpdateCS.hlsl``
     - Compute shader code that updates the 1-texel border of irradiance or distance octahedral texture maps. All probes of a volume are processed in parallel. This shader is dispatched by the ``DDGIVolume::UpdateProbes()`` function. See `Probe Irradiance and Distance Update`_.


.. list-table:: DDGI HLSL Shaders (early access features)
   :widths: 25 75
   :header-rows: 1

   * - File Name
     - Description
   * - ``ProbeRelocationCS.hlsl``
     - Compute shader code that attempts to reposition probes if they are inside of geometry (e.g. walls). This shader is dispatched by the ``DDGIVolume::RelocateProbes()`` function. See `Probe Relocation and Position Optimization`_.
   * - ``ProbeStateClassifierCS.hlsl``
     - Compute shader code that classifies probes into various states for performance optimization. See `Probe State Classification`_.

.. _DDGI-Volumes:

------------------------
Volumes
------------------------

A ``DDGIVolume`` is a volume of space within which irradiance queries at arbitrary world-space points are supported. The underlying data structure of a ``DDGIVolume`` is a regular grid of probes (see the note below) that spans a volume's extent, and is centered about a user defined volume origin. A ``DDGIVolume`` may cover the entire scene or some sub-volume of the scene, depending on the desired effect. Each probe is represented by an unwrapped octahedral texture map of irradiance and distance values for the set of directions  around that probe (also referred to as an irradiance field). At a high level, the ``DDGIVolume`` provides the ability to: 

1. Update the per-probe irradiance and filtered distance values
2. Compute the irradiance for arbitrary world-space locations within the volume

Before creation, a ``DDGIVolume`` is described using a pair of descriptor structs that configure the various properites and resources of the volume. These structs are ``DDGIVolumeDesc`` and ``DDGIVolumeResources``.

.. note:: A regularly spaced probe grid is not strictly required. The probe grid can be adjusted using the per-probe offsets that are part of the :ref:`probe_offsets` early access feature.

.. _DDGI-DescribeVolume:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Describing a Volume
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``DDGIVolumeDesc`` is a descriptor structure that specifies the attributes of a ``DDGIVolume``. 

This structure is defined in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolume.h`` and each member variable is described in the table below:

.. list-table:: ``DDGIVolumeDesc`` Members
   :widths: 15 10 75
   :header-rows: 1

   * - Member
     - Type
     - Description
   * - ``origin``
     - ``float3``
     - The world-space origin of the volume.
   * - ``probeGridSpacing``
     - ``float3``
     - The world-space distance between probes.
   * - ``probeGridCounts``
     - ``int3``
     - The number of probes on each axis (x, y, z).
   * - ``probeMaxRayDistance``
     - ``float``
     - The maximum distance a ray cast from a probe may travel.
   * - ``probeHysteresis``
     - ``float``
     - Controls the influence of new rays when updating probes. A value close to 1.0 slowly changes probe data, improving stability but reducing accuracy when objects move in the scene. Values of 0.9 or lower will rapidly react to scene changes, but may cause flickering or other instabilities in lighting.
   * - ``probeChangeThreshold``
     - ``float``
     - A ratio used during probe radiance blending. Specifies a threshold to identify when large lighting changes occur. When the difference in the maximum color components between the previous and current irradiance is larger than this threshold, the hysteresis will be reduced.
   * - ``probeBrightnessThreshold``
     - ``float``
     - A threshold value used during probe radiance blending that determines the maximum allowed difference in brightness between the previous and current irradiance values. This prevents impulses from drastically changing a texel's irradiance in a single update cycle.
   * - ``probeDistanceExponent``
     - ``float``
     - The exponent used during visibility testing. A high value rapidly reacts to depth discontinuities, but may cause banding.
   * - ``probeIrradianceEncodingGamma``
     - ``float``
     - An exponent that perceptually encodes irradiance for faster light-to-dark convergence. (See `Probe Irradiance Gamma`_).
   * - ``numIrradianceTexels``
     - ``int``
     - The number of texels in one dimension of the probe irradiance texture (octahedral maps are square), not including the 1-texel border.
   * - ``numDistanceTexels``
     - ``int``
     - The number of texels in one dimension of the probe distance texture (octahedral maps are square), not including the 1-texel border.
   * - ``numRaysPerProbe``
     - ``int``
     - The number of rays to cast per probe. When using ``RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY``, set this value to a multiple of the irradiance/distance probe texel resolution for best behavior.
   * - ``viewBias``
     - ``float``
     - A small offset along the camera view ray applied to the shaded surface point to avoid numerical instabilities when determining visibility.
   * - ``normalBias``
     - ``float``
     - A small offset along the surface normal applied to the shaded surface point to avoid numerical instabilities when determining visibility.
   

.. list-table:: ``DDGIVolumeDesc`` Members (early access features)
   :widths: 15 10 75
   :header-rows: 1

   * - Member
     - Type
     - Description
   * - ``probeMinFrontfaceDistance``
     - ``float``
     - The minimum distance allowed to a front facing triangle before Probe Relocation moves the probe (see `Probe Relocation and Position Optimization`_).
   * - ``probeBackfaceThreshold``
     - ``float``
     - The ratio of rays cast for a probe that may hit back facing triangles before Probe Relocation and State Classification assume the probes is inside of geometry (used by `Probe Relocation and Position Optimization`_ and `Probe State Classification`_).

**Octahedral Texture Maps**

Octahedral Texture Maps are unwrapped as described in `Cigolle et al 2014 <http://jcgt.org/published/0003/02/01/>`_. To support fast hardware bilinear texture sampling, our octahedral texture maps include a 1-texel border. These border texels are **added** to the values specified in the `numIrradianceTexels` and `numDistanceTexels` members of ``DDGIVolumeDesc``.

.. figure:: ../images/octahedral-param.jpg
   :scale: 40%
   :align: center

   The octahedral parameterization of a sphere unwrapped to the unit square as described by `Cigolle et al. 2014 <http://jcgt.org/published/0003/02/01/>`_

.. figure:: ../images/octahedral-border.png
   :scale: 60%
   :align: center

   Three annotated diagrams of the unwrapped octahedral unit square for a single probe. The left and center diagrams highlight the 1-texel border added to the 6x6 texel interior, and identify the texels that map to the "front" and "back" of the probe. The scheme to populate border texels with the necessary data for bilinear interpolation is shown on the right.


.. note:: The Test Harness application includes a mode to visualize each probe's unwrapped octahedral texture map at runtime. See :ref:`Texture Visualization <Harness-Texture-Viz>` for more information.

.. _DDGI-DescribeResources:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Resource Management
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``DDGIVolume`` uses a variety of GPU resources. Since applications vary widely in how resource allocation and tracking is handled, two modes are provided for resource management: 

- **SDK Managed**: the SDK internally manages the allocation and deallocation of ``DDGIVolume`` GPU resources.
- **Application Managed**: the application manages the allocation and deallocation of ``DDGIVolume`` GPU resources, and passes resource pointers to the ``DDGIVolume``.

The resource management mode is specified at compile time by setting the ``RTXGI_DDGI_SDK_MANAGED_RESOURCES`` define in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h``. Set ``RTXGI_DDGI_SDK_MANAGED_RESOURCES`` to 0 for application management or 1 for SDK management.

**Descriptor Heap and Constant Buffer(s)**

Regardless of the selected resource management mode, the application is responsible for allocating, managing, and providing information about the descriptor heap where the descriptors for ``DDGIVolume`` resources are placed. The application provides this information to a ``DDGIVolume`` using the ``DDGIVolumeResources`` structure at volume creation time. This structure is defined in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolume.h``, and the descriptor heap members are described in the table below:

.. list-table:: ``DDGIVolumeResources`` Descriptor Heap Members
   :widths: 15 10 75
   :header-rows: 1

   * - Variable
     - Type
     - Description
   * - ``descriptorHeap``
     - ``ID3D12DescriptorHeap*``
     - A pointer to a valid D3D12 CBV/SRV/UAV descriptor heap.
   * - ``descriptorHeapDescSize``
     - ``int``
     - The size of each entry on the descriptor heap.
   * - ``descriptorHeapOffset``
     - ``int``
     - The offset to the first free descriptor heap slot a ``DDGIVolume`` can use.

In addition to descriptor heap space, the application must allocate a GPU resource for constant buffer data. Unlike the descriptor heap, a resource pointer for the constant buffer is not passed to the ``DDGIVolume`` at creation time, and is instead passed through the ``DDGIVolume::Update(ID3D12Resource*, UINT64)`` function (see `Updating a Volume`_). In order for the application to know how many descriptor heaps slots to reserve and how many constant buffer bytes to allocate per volume, the following helper functions are available in the ``rtxgi`` namespace:

.. list-table:: ``rtxgi`` Namespace Functions for Resource Allocation
   :widths: 25 75
   :header-rows: 1

   * - Function
     - Description
   * - ``int GetDDGIVolumeConstantBufferSize()``
     - Get the number of constant buffer bytes required by a ``DDGIVolume``.
   * - ``int GetDDGIVolumeNumDescriptors()``
     - Get the number of CBV/SRV/UAV resource descriptor slots required by a ``DDGIVolume``.

.. note:: To support double (or triple) buffering, the constant buffer should be allocated with a size that is a multiple of the value returned by ``GetDDGIVolumeConstantBufferSize()``. 

.. note:: The Test Harness application provides an example that sets the descriptor heap information with the ``DDGIVolumeResources`` struct and allocates a constant buffer (for double buffering) in the ``Harness::CreateVolume(...)`` function of ``samples/test-harness/src/harness/Harness.cpp``.

.. _DDGI-SDKResources:

"""""""""""""""""""""""
SDK Managed Resources
"""""""""""""""""""""""

In SDK managed mode, the ``DDGIVolume`` creates and manages the necessary GPU resources (except for the descriptor heap and constant buffer as described above), including the root signature, textures, descriptors, and pipeline state objects (PSO). The intent in providing a mode where the SDK manages GPU resources directly is to simplify the resource management process for applications that may benefit from a black box approach. Resources are allocated at volume creation time when calling the  ``DDGIVolume::Create(...)`` function.

Although the ``DDGIVolume`` manages resources in this mode, it does not handle shader compilation since most game engines and renderers already have existing infrastructure for this task. Pointers to compiled DXIL shader bytecode blobs for the blending and update compute shaders (provided in the SDK) must be passed to the volume through the ``DDGIVolumeResources`` descriptor struct. These fields are described in the table below:

.. list-table:: SDK Managed ``DDGIVolumeResources`` Members (``RTXGI_DDGI_SDK_MANAGED_RESOURCES == 1``)
   :widths: 15 10 75
   :header-rows: 1

   * - Variable
     - Type
     - Description
   * - ``device``
     - ``ID3D12Device*``
     - The D3D12 device to use for resource allocation.
   * - ``probeRadianceBlendingCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe radiance blending compute shader bytecode.
   * - ``probeDistanceBlendingCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe distance blending compute shader bytecode.
   * - ``probeBorderRowCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe irradiance or distance border row update compute shader bytecode.
   * - ``probeBorderColumnCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe irradiance or distance border column update compute shader bytecode.
   * - ``probeRelocationCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe relocation compute shader bytecode (used for `Probe Relocation and Position Optimization`_).
   * - ``probeStateClassifierCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe state classifier bytecode (used for `Probe State Classification`_).
   * - ``probeStateClassifierActivateAllCS``
     - ``ID3DBlob*``
     - Compiled DXIL probe state classifier "activate all" bytecode (used for `Probe State Classification`_).

.. note:: Although the SDK does not compile shaders, it will create the appropriate compute pipeline state objects for the shaders in SDK managed mode.


.. _DDGI-App-Resources:

"""""""""""""""""""""""""""""""
Application Managed Resources
"""""""""""""""""""""""""""""""

For applications that require tighter control over the resource management process, the Application Managed resource mode leaves the task of resource allocation entirely to the host application. Like the SDK Managed mode, resource pointers are provided to the ``DDGIVolume`` through the ``DDGIVolumeResources`` struct at creation time; however, the application must provide the entire set of necessary GPU resources. These fields are described in the table below:

.. list-table:: Application Managed ``DDGIVolumeResources`` Members (``RTXGI_DDGI_SDK_MANAGED_RESOURCES == 0``)
   :widths: 15 10 75
   :header-rows: 1

   * - Variable
     - Type
     - Description
   * - ``rootSignature``
     - ``ID3D12RootSignature*``
     - A pointer to the root signature for the compute shaders. See ``GetDDGIVolumeRootSignatureDesc(...)`` below.
   * - ``probeRTRadiance``
     - ``ID3D12Resource*``
     - A pointer to the probe radiance texture resource (to be used in ray tracing).
   * - ``probeIrradiance``
     - ``ID3D12Resource*``
     - A pointer to the probe irradiance texture resource.
   * - ``probeDistance``
     - ``ID3D12Resource*``
     - A pointer to the probe distance texture resource. The R channel stores mean distance, the G channel stores mean distance^2.
   * - ``probeOffsets``
     - ``ID3D12Resource*``
     - A pointer to the probe relocation world-space offsets texture resource (used in `Probe Relocation and Position Optimization`_).
   * - ``probeStates``
     - ``ID3D12Resource*``
     - A pointer to the probe state texture resource (used in `Probe State Classification`_).
   * - ``probeRadianceBlendingPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe radiance blending compute pipeline state object resource.
   * - ``probeDistanceBlendingPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe distance blending compute  pipeline state object resource.
   * - ``probeBorderRowPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe irradiance or distance border row update compute pipeline state object resource.
   * - ``probeBorderColumnPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe irradiance or distance border column update compute pipeline state object resource.
   * - ``probeRelocationPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe relocation compute pipeline state object resource (used in `Probe Relocation and Position Optimization`_).
   * - ``probeStateClassifierPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe state classifier compute pipeline state object resource (used in `Probe State Classification`_).
   * - ``probeStateClassifierActivateAllPSO``
     - ``ID3D12PipelineState*``
     - A pointer to the probe state classifier activate all compute pipeline state object resource (used in `Probe State Classification`_).

.. note:: In application managed resource mode, a ``D3D12Device`` pointer is not passed through the ``DDGIVolumeResources`` struct, since all resources are allocated by the host application. As a consequence, pipeline state object resources pointers are passed for each required compute shader instead of compiled DXIL bytecode.

**Allocation Helpers**

To aid the application in the resource allocation process, the following namespace functions are available in the ``rtxgi`` namespace:

.. list-table:: ``rtxgi`` Namespace Helper Functions for Resource Allocation
   :widths: 25 75
   :header-rows: 1

   * - Function
     - Description
   * - ``DXGI_FORMAT GetDDGIVolumeTextureFormat(ETextureType type)``
     - Get the required DXGI_FORMAT of the given texture resource type.
   * - ``void GetDDGIVolumeProbeCounts(const DDGIVolumeDesc &desc, UINT &probeCountX, UINT &probeCountY)``
     - Get the number of probes on the X and Y dimensions of the irradiance and distance textures.
   * - ``void GetDDGIVolumeTextureDimensions(const DDGIVolumeDesc &desc, ETextureType type, UINT &width, UINT &height)``
     - Get the dimensions, in texels, of the given texture type for a ``DDGIVolume`` with the given descriptor.
   * - ``bool GetDDGIVolumeRootSignatureDesc(int descriptorHeapOffset, ID3DBlob** signature)``
     - Get the root signature descriptor blob for the given descriptor heap offset.
   * - ``DDGIVolumeDescGPU GetDDGIVolumeGPUDesc(DDGIVolumeDesc &desc)``
     - Get the compacted GPU version of the ``DDGIVolume`` descriptor.

.. note:: The format of various textures can be changed at compile time (usually for debug purposes) by changing the following defines in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h``:

   * ``RTXGI_DDGI_DEBUG_FORMAT_RADIANCE``
   * ``RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE``
   * ``RTXGI_DDGI_DEBUG_FORMAT_OFFSETS``
   
   |br| See `Configuration`_ for more information.

.. _DDGI-CreateVolume:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Creating a Volume
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A minimum of one ``DDGIVolume`` is required to use the DDGI algorithm. Volumes are specified as part of the scene, which is left to the host application. A common pattern is for artists and level designers to specify volumes in editor tools that expose RTXGI SDK functionality through their user interface. ``DDGIVolume`` parameters are then stored in data files, and used at level load time to instantiate the volumes. Alternatively, a volume may be programmatically generated based on scene parameters (bounding boxes, resolution, etc.).

Assuming the set of desired parameters are available, the volume creation process begins by mapping each parameter into the ``DDGIVolumeDesc`` struct (see `Describing a Volume`_ for details). Once the volume descriptor has the appropriate parameters, the required volume resources are set in a ``DDGIVolumeResources`` struct (see `Resource Management`_ for details). After the parameter descriptor and resource descriptor are set up, the ``DDGIVolume`` is created using the contructor after which the ``DDGIVolume::Create(...)`` is called to finish creating the volume. See the ``Harness::CreateVolume(...)`` function in ``samples/test-harness/src/harness/Harness.cpp`` for an example.

.. note:: The :ref:`Harness` provides an example implementation of how to use a single ``DDGIVolume`` to add global illumination to a scene.

.. note:: While this section focused on creation of a single volume, multiple volumes may be created by repeating the creation process in this section. See `Multiple Volume Blending`_ for more information on how to use multiple volumes to compute global illumination.


.. _DDGI-DestroyVolume:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Destroying a Volume
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When no longer needed, a ``DDGIVolume`` and its GPU resources can be released. Regardless of resource management mode (see `Resource Management`_), the host application is responsible for releasing the descriptor heap and constant buffer resources allocated for the volume. In SDK managed resource mode, all additional GPU resources created for a volume are released when ``DDGIVolume::Destroy()`` is called. In application managed resource mode, no GPU resources are released when ``DDGIVolume::Destroy`` is called, and the deallocation process is left entirely to the host application. 

.. _DDGI-UpdateVolume:

---------------------
Updating a Volume
---------------------

The DDGI algorithm is referred to as *Dynamic* Diffuse Global Illumination since it is possible to update irradiance and distance data at runtime. A common update frequency is to update the probes with newly ray traced data every frame; however, this is not the only option. Aternatively, updates could be scheduled at a lower frequency than the frame rate, or even as asynchronous workloads that execute continuously on lower priority background queues - essentially streaming radiance and distance data to ``DDGIVolume`` probes.

The set of operations to perform a single update of a ``DDGIVolume`` are:

1. Randomize the sampling rotation and update the constant buffer data by calling ``DDGIVolume::Update(...)``.

   * See ``volume->Update(...)`` in ``samples/test-harness/src/harness/main.cpp``

2. Trace rays from the ``DDGIVolume`` probes and store the radiance and distance results.

   * See ``Harness::RayTraceProbes(...)`` in ``samples/test-harness/src/harness/main.cpp``

3. Update probe irradiance and distance data based on the ray tracing results by calling ``DDGIVolume::UpdateProbes(...)``.

   * See ``volume->UpdateProbes(...)`` in ``samples/test-harness/src/harness/main.cpp``

.. _DDGI-RotationsAndCB:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Randomizing the Sampling Rotation and Updating the Constant Buffer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``DDGIVolume::Update()`` function randomizes the rotation matrix applied to each probe's set of ray directions and updates the constant buffer. Well distributed random rotations are computed using `James Arvo's implementation from Graphics Gems 3 (pg 117-120) <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&rep=rep1&type=pdf>`_ in the ``DDGIVolume::ComputeRandomRotation()`` function. If this step is skipped, the previous rotation and constant buffer state are used, and the same data as the previous frame is unnecessarily recomputed.

.. note:: The ``DDGIVolume::Update(...)`` function accepts a GPU resource pointer to a constant buffer along with a byte offset. The update function calls ``Map()`` and applies the byte offset before performing a ``memcpy(...)`` and ``Unmap()`` on the constant buffer. It is possible to double buffer the constant buffer data by swapping byte offsets each time ``DDGIVolume::Update`` is called. The Test Harness provides an example of this in ``samples/test-harness/src/harness/main.cpp``.

.. _DDGI-ProbeTrace:

^^^^^^^^^^^^^^^^^^^^^^^^
Probe Ray Trace
^^^^^^^^^^^^^^^^^^^^^^^^

After updating the constant buffer data, the application is expected to perform ray tracing for probes in the ``DDGIVolume`` to estimate the incoming irradiance and distance to geometry in all directions around each probe. This can be accomplished a number of ways, and for flexibility the SDK leaves this task to the host application. Regardless of how ray tracing is implemented, a set of ray directions for the volume's probes must be computed. ``rtxgi-sdk/shaders/ddgi/ProbeCommon.hlsl`` provides the ``DDGIGetProbeRayDirection(...)`` utility function that computes a set of unique, low discrepancy, spherically distributed directions on the unit sphere that apply the randomly rotation transform computed by ``DDGIVolume::Update(...)``. This function should be used to generate probe ray directions before ray tracing.

.. note:: An example of this is provided in the ``Harness::RayTraceProbes(...)``  function of the Test Harness in ``samples/test-harness/src/harness/Harness.cpp``, and ``RayGen()`` HLSL entry point of the ``samples/test-harness/shaders/ProbeTraceRGS.hlsl`` DXR ray generation shader.

.. note:: Higher ray counts per probe increase the rate of convergence and produce better visual results, since each probe's irradiance and distance representation is more accurate.

.. _DDGI-Update:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Probe Irradiance and Distance Update
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The results of the probe ray tracing step are used to update the irradiance and distance data for each probe by calling ``DDGIVolume::UpdateProbes(...)``. The update operation consists of two phases, and six compute shader dispatches:

**Phase 1: Blending**

1. Blend the ray traced **radiance** values for each probe's irradiance octahedral texture map.
2. Blend the ray traced **distance** values for each probe's distance octahedral texture map.

**Phase 2: Border Texel Update**

3. Update all **rows** of border texels for **irradiance** octahedral texture maps.
4. Update all **columns** of border texels for **irradiance** octahedral texture maps.
5. Update all **rows** of border texels for **distance** octahedral texture maps.
6. Update all **columns** of border texels for **distance** octahedral texture maps.

.. note:: Set ``RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY`` to 1 to enable shared memory in the probe blending shaders. Enabling shared memory is strongly recommended, since optimizations using shared memory provide a substantial performance benefit by cooperatively loading and computing values that are common within thread groups.

During the probe update process, performance markers are inserted into the GPU command list of when ``RTXGI_PERF_MARKERS`` is set to 1. An example of these annotatations in Nsight Graphics is shown below:

.. figure:: ../images/probe_update_nsight.jpg
  :width: 100%
  :align: center

  The Nsight Graphics scrubber view, showing performance markers from the Test Harness. The probe update markers are highlighted.

.. note:: The ``DDGIVolume::UpdateProbes(...)`` function places two performance markers in the command list (one for irradiance and one for distance) for the border update phase, instead of one for each compute dispatch. This is why two border update performance markers appear in the scrubber view in Nsight Graphics instead of four.

.. _DDGI-VolumeMovement:

------------------
Volume Movement
------------------

For general use, the ``DDGIVolume`` is designed to be stationary, and placed in a fixed scene location. However, for the best results in scenarios where the space that requires global illumination is itself not stationary, the ``DDGIVolume`` may also need to move. Examples of this scenario include elevators, trains, cars, and spaceships. To achieve consistent global lighting results for moving spaces, a ``DDGIVolume`` can be attached to the moving space's frame of reference and translated with the ``DDGIVolume->Move(...)`` function.

.. note:: Since ``volume->Move(...)`` *translates* a volume, the transformation is only correct for frames of reference undergoing translation only (i.e. not rotation also). As a result, the axis-aligned bounding box of a ``DDGIVolume`` needs to be large enough to cover the desired space when the space is under rotation.

.. note:: The ``DDGIVolume->Move(...)`` functionality is also useful for debugging purposes, so that one may visualize how a set of probes function in different locations of a scene without creating multiple volumes.

 .. _DDGI-IndirectLighting:

------------------------------------------
Computing Indirect Lighting from a Volume
------------------------------------------

To compute indirect lighting using a ``DDGIVolume``, the application needs to provide:

  1. The world-space position of the surface point that recieves the indirect light (i.e. the point being shaded)
  2. A small surface bias value, computed with the ``DDGIGetSurfaceBias(...)`` helper function provided in ``rtxgi-sdk/shaders/ddgi/Irradiance.hlsl``.
  3. The normal direction of the surface point.
  4. The ``DDGIVolume`` constant buffer data.
  5. The ``DDGIVolume`` texture resources (probe irradiance and distance SRVs, and a texture sampler).

Each of the requirements above are passed to the ``DDGIGetVolumeIrradiance(...)`` function in ``rtxgi-sdk/shaders/ddgi/Irradiance.hlsl``. ``DDGIGetVolumeIrradiance(...)`` computes the proper irradiance contribution based on the given ``DDGIVolume`` by determining which probes are relevant to the given world-space point, evaluating the stored irradiance, and using the probe distance values to determine visibility and eliminate contributions from occluded probes.

The Test Harness provides an example of this in the ``samples/test-harness/shaders/Indirect.hlsl`` fullscreen Pixel Shader.

.. _DDGI-IrradianceGamma:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Probe Irradiance Gamma
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To improve the light-to-dark convergence and the efficiency of texture storage, our implementation of DDGI uses exponential weighting when storing irradiance. The default gamma exponent is ``5.f``, but it can be modified by changing the ``probeIrradianceEncodingGamma`` member of the ``DDGIVolumeDesc`` struct (see `Describing a Volume`_). This exponent moves the stored irradiance value into a non-linear space that more closely matches human perception, while also allowing for a smaller texture format. If ``probeIrradianceEncodingGamma`` is set to ``1.f``, then the stored value remains in linear space and the quality of the lighting will decrease. To account for this quality loss when in linear space, ``RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE`` can be set to ``1`` in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h`` to use the larger ``DXGI_FORMAT_R32G32B32A32_FLOAT`` texture format for irradiance. By default, the smaller ``DXGI_FORMAT_R10G10B10A2_UNORM`` is used (see `Configuration`_).

.. note:: While we recommend using the default value for ``probeIrradianceEncodingGamma`` for most situations, values near the default of ``5.f`` may improve light-to-dark convergence in specific situations.

.. _DDGI-Compositing:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Compositing Indirect Lighting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

One example of how to composite irradiance sampled from a ``DDGIVolume`` with direct lighting and ambient occlusion is provided by the ``Harness::RenderIndirect(...)`` function and ``samples/test-harness/shaders/Indirect.hlsl`` fullscreen Pixel Shader. 

.. _DDGI-VolumeBlending:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Volume Blending for Regions Outside of a Volume
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Although no example is provided in the Test Harness, a separate HLSL shader function - ``DDGIGetVolumeBlendWeight(...)`` - is provided by the SDK to enable blending between regions covered by a ``DDGIVolume`` and regions **not** covered by a ``DDGIVolume``. This use case may arise if there is a region of the scene that needs dynamic diffuse irradiance and another part that strictly does not (for example, due to artistic or performance reasons).

In this case, the example provided in the ``samples/test-haress/shaders/Indirect.hlsl`` shader can be modified as shown below:

.. code-block:: hlsl
    :linenos:

    // Hard coded ambient term (black), might be passed in
    float3 ambient = 0.f;

    // Get the volume blend weight (0-1)
    float volumeBlendWeight = DDGIGetVolumeBlendWeight( worldPosHitT.xyz, DDGIVolume);

    // Only get irradiance if it will be used
    if (volumeBlendWeight > 0.f)
    {
        // Get irradiance from the DDGIVolume
        irradiance = DDGIGetVolumeIrradiance(
            worldPosHitT.xyz,
            surfaceBias,
            normal,
            DDGIVolume,
            resources);
    }

    // Blend between irradiance and the constant ambient term
    irradiance = volumeBlendWeight * irradiance + (1.f - volumeBlendWeight) * ambient;

.. _DDGI-MultipleBlending:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Multiple Volume Blending
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The use of multiple volumes is also possible; however, for best results the indirect lighting computed by each volume should be blended with overlapping and/or nearby volumes. There is no example implementation in the Test Harness for multiple volumes, but this scenario can be understood by replacing a single ``DDGIVolume`` with an array of volumes in the ``samples/test-harness/shaders/Indirect.hlsl`` fullscreen Pixel Shader. Here we assume the volumes in the array are ordered such that the last volume is the "fallback volume". 

The irradiance computation would work as follows:

.. code-block:: hlsl
    :linenos:

    // Start with a full irradiance contribution remaining (for the final volume)
    float remainingVolumeBlendWeight = 1.f;
    float3 volumeIrradiance = 0.f;

    // Loop over all but the final volume
    for (int volumeIndex = 0; volumeIndex < volumeCount - 1; volumeIndex++)
    {
        // Get the volume blend weight (0-1)
        float volumeBlendWeight = DDGIGetVolumeBlendWeight( worldPosHitT.xyz, DDGIVolume);

        // Only get irradiance if it will be used
        if (volumeBlendWeight > 0)
        {
            // Get irradiance from the DDGIVolume
            volumeIrradiance = DDGIGetVolumeIrradiance(
                worldPosHitT.xyz,
                surfaceBias,
                normal,
                DDGIVolume[volumeIndex],
                resources);
        }

        // Blend this volume's irradiance and reduce the remaining irradiance for the final volume
        irradiance += volumeIrradiance * volumeBlendWeight;
        remainingVolumeBlendWeight = clamp(remainingVolumeBlendWeight - volumeBlendWeight);
    }

    // Get irradiance from the final DDGIVolume
    volumeIrradiance = DDGIGetVolumeIrradiance(
        worldPosHitT.xyz,
        surfaceBias,
        normal,
        DDGIVolume[volumeCount - 1],
        resources);

    // Blend between irradiance and the constant ambient term
    irradiance += remainingVolumeBlendWeight * volumeIrradiance;


.. _DDGI-EarlyAccess:

--------------------------------------------
Early Access Features
--------------------------------------------

The following early access features are available for experimental use, but may change substantially in future versions of the RTXGI SDK.

.. _probe_offsets:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Probe Relocation and Position Optimization
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any regular grid has a hard time adapting to correctly handle all kinds of scenes, and the regular grids of DDGI are no exception. To mitigate this shortcoming, we provide a feature that allows world-space offsets to be added to each probe, and enable users to experiment with probe offset optimization using the ``DDGIVolume::RelocateProbes(...)`` function in the Test Harness. You can enable this functionality by changing the corresponding SDK define (see note below).

The ``DDGIVolume::RelocateProbes(...)`` function attempts to move probes out of the interior of geometry by assuming that some proportion of probe rays intersecting back faces indicates the probe is inside geometry. The ``probeBackfaceThreshold`` variable, described in the `Describing a Volume`_ section, controls the threshold beyond which the optimizer considers a probe "inside backfacing geometry". When a probe is determined to be inside of geometry, the maximum allowable displacement is computed as 45% of the grid cell distance. This is implemented in ``rtxgi-sdk/shaders/ddgi/ProbeRelocationCS.hlsl``. 

The Test Harness provides an example of a simple linear descent optimizer using ``RTXGI_DDGI_MAX_PROBE_RELOCATION_ITERATIONS`` iterations to improve the probe offsets. At each iteration, the ``probeDistanceScale`` is reduced, allowing smaller magnitude probe displacement until probes reach a favorable location. In our example, these optimization iterations happen on the first ``RTXGI_DDGI_MAX_PROBE_RELOCATION_ITERATIONS`` frames, though these optimizations could be done as an offline pre-process or at level load time.

.. note:: Enable probe relocation and the position optimizer by setting ``RTXGI_DDGI_PROBE_RELOCATION`` to 1 in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h``.

.. _probe_states:

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Probe State Classification
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Not all scenes will require all probes in a ``DDGIVolume`` to contribute to diffuse global illumination. Some probes may be stuck inside geometry (e.g. walls), exist in space without nearby geometry, or be far enough outside the scene to not be useful. In these cases, it is best for these probes to not trace rays or spend time updating textures that won't be used. An early preview of this kind of optimization technique is provided by ``DDGIVolume::ClassifyProbes(...)`` function.

The ``DDGIVolume::ClassifyProbes(...)`` function uses the latest results from the probe ray trace update to determine whether each probe should be ``active`` or ``inactive``. Inactive probes do not trace rays. When a sudden change in scene geometry occurs, currently ``inactive`` probes should be made ``active`` to account for the potential affects to lighting. The ``DDGIVolume::ActivateAllProbes(...)`` function can be called to mark all probes as ``active``. After the next ray tracing opportunity, run the ``DDGIVolume::ClassifyProbes(...)`` function again to reclassify probes (and subsequently set some as ``inactive``).

.. note:: Enable probe state classification by setting ``RTXGI_DDGI_PROBE_STATE_CLASSIFIER`` to 1 in ``rtxgi-sdk/include/rtxgi/ddgi/DDGIVolumeDefines.h``.

.. warning:: ``DDGIVolume::ClassifyProbes(...)`` is a one way operation and only moves probes from ``active`` to ``inactive``.

.. note:: When combining probe state classification with `Probe Relocation and Position Optimization`_, it is a good practice to avoid classifying probes as inactive until their positions have become relatively stable. The optimization process occasionally moves probes on different sides of geometry due to the randomization of probe rays. This may change their classification.

